## study-buddy/src/utils/notifications.ts
```ts
import * as Notifications from 'expo-notifications';
import { Alert, Platform } from 'react-native';
import { track } from '@utils/analytics';
import { t } from '@utils/intl/i18n';

export async function ensureNotificationsSetup(): Promise<void> {
  try {
    const { status: existingStatus } = await Notifications.getPermissionsAsync();
    let finalStatus = existingStatus;
    if (existingStatus !== 'granted') {
      try {
        await new Promise<void>((resolve) => {
          Alert.alert(
            t('notificationsPermissionTitle'),
            t('notificationsPermissionBody'),
            [
              { text: t('notNow'), onPress: () => resolve() },
              { text: t('continue'), onPress: () => resolve() }
            ]
          );
        });
      } catch {}
      const { status } = await Notifications.requestPermissionsAsync();
      finalStatus = status;
    }
    track('notifications_permission', { status: finalStatus });
    if (finalStatus !== 'granted') return;

    // Android: idempotent channel setup
    if (Platform.OS === 'android') {
      await Notifications.setNotificationChannelAsync('checkins', {
        name: t('checkinTitle'),
        importance: Notifications.AndroidImportance.DEFAULT,
        vibrationPattern: [0, 250, 250, 250],
        lightColor: '#FF231F7C',
      });
    }

    // iOS/Android: idempotent categories
    await Notifications.setNotificationCategoryAsync('checkin-actions', [
      { identifier: 'RESUME', buttonTitle: t('resume') },
      { identifier: 'BREAK', buttonTitle: t('break5') },
      { identifier: 'DONE', buttonTitle: t('imDone') },
    ]);
  } catch {}
}

export function extractActionIdFromResponse(response: Notifications.NotificationResponse | { actionIdentifier?: string }): string {
  return (response as any)?.actionIdentifier || '';
}
```

---

## study-buddy/src/utils/notificationsSchedule.ts
```ts
import type { AgeGroup } from '@types/index';
import { generatePeerLine } from '@utils/content/peerLines';
import { t } from '@utils/intl/i18n';

type BuildArgs = {
  ageGroup: AgeGroup;
  subjectId: string;
  sessionTime: number; // seconds elapsed at scheduling time
  intervalMs: number;  // base check-in interval in ms
  sessionLength: number; // seconds
  sessionId: string; // seed string (e.g., `${startTime}:${salt}`)
};

export function buildCheckInNotifications({
  ageGroup,
  subjectId,
  sessionTime,
  intervalMs,
  sessionLength,
  sessionId,
}: BuildArgs): Array<{ content: { title: string; body: string; categoryIdentifier: string }; trigger: { seconds: number } }> {
  const items = [1, 2, 3].map((i) => {
    const secondsOffset = Math.floor((intervalMs * i) / 1000);
    const seconds = sessionTime + secondsOffset;
    const body = generatePeerLine({
      ageGroup,
      subjectId: subjectId || 'other',
      seconds,
      sessionLength,
      context: 'backgroundReturn',
      sessionId,
    }).replace(/[^\w\s]/g, '');
    return {
      content: {
        title: t('checkinTitle'),
        body,
        categoryIdentifier: 'checkin-actions',
      },
      trigger: { seconds: Math.max(5, secondsOffset) },
    };
  });
  return items;
}
```

---

## study-buddy/src/utils/notifications.test.ts
```ts
import * as Notifications from 'expo-notifications';
import { ensureNotificationsSetup } from './notifications';

describe('notifications setup', () => {
  it('creates channel and category when granted', async () => {
    jest.spyOn(Notifications, 'getPermissionsAsync' as any).mockResolvedValueOnce({ status: 'granted' } as any);
    const channelSpy = jest.spyOn(Notifications, 'setNotificationChannelAsync' as any).mockResolvedValueOnce(undefined as any);
    const categorySpy = jest.spyOn(Notifications, 'setNotificationCategoryAsync' as any).mockResolvedValueOnce(undefined as any);

    await ensureNotificationsSetup();

    expect(categorySpy).toHaveBeenCalled();
    // Android-only channel may not be called on CI; assert category at minimum

    channelSpy.mockRestore();
    categorySpy.mockRestore();
  });
});
```

---

## study-buddy/scripts/check-config.js
```javascript
// Minimal runtime guard to ensure production config is present
const assert = (cond, msg) => { if (!cond) { console.error(msg); process.exit(1); } };

try {
  const Constants = require('expo-constants').default;
  const extra = (Constants?.manifest?.extra || {});
  const ph = extra?.posthog || {};
  const rc = extra?.revenuecat || {};
  const sentry = extra?.sentry || {};

  const isCI = process.env.CI === 'true' || process.env.GITHUB_ACTIONS === 'true';
  const isProd = process.env.APP_ENV === 'production' || process.env.NODE_ENV === 'production';

  if (isCI && isProd) {
    assert(!!ph.apiKey && !!ph.host, 'PostHog config missing in production');
    assert(!!rc.iosApiKey || !!rc.androidApiKey, 'RevenueCat API key missing in production');
    assert(typeof rc.entitlementId === 'string' && rc.entitlementId.length > 0, 'RevenueCat entitlementId missing');
    assert(typeof sentry.dsn === 'string' && sentry.dsn.length > 0, 'Sentry DSN missing in production');
  }

  console.log('Config check passed.');
  process.exit(0);
} catch (e) {
  console.error('Config check failed:', e?.message || e);
  process.exit(1);
}
```

## study-buddy/src/utils/config/appConfig.ts
```ts
import Constants from 'expo-constants';
import { z } from 'zod';

export type AppConfig = {
  revenuecat: { iosApiKey: string; androidApiKey: string; entitlementId: string };
  manageSubscriptions: { ios: string; android: string };
  sentry: { dsn: string };
  posthog: { apiKey: string; host: string };
  remote: { paywall: { sessionsTillPaywall: number; variants: Record<string, number> }; surprise: { frequencyMultiplier: number } };
  urls: { privacyPolicy: string; termsOfService: string; support: string };
};

export function getAppConfig(): AppConfig {
  const extra: any = (Constants?.manifest?.extra || {});
  const AppConfigSchema = z.object({
    revenuecat: z.object({
      iosApiKey: z.string().optional().default(''),
      androidApiKey: z.string().optional().default(''),
      entitlementId: z.string().optional().default('premium')
    }).optional().default({ iosApiKey: '', androidApiKey: '', entitlementId: 'premium' }),
    manageSubscriptions: z.object({
      ios: z.string().optional().default('itms-apps://apps.apple.com/account/subscriptions'),
      android: z.string().optional().default('https://play.google.com/store/account/subscriptions')
    }).optional().default({ ios: 'itms-apps://apps.apple.com/account/subscriptions', android: 'https://play.google.com/store/account/subscriptions' }),
    sentry: z.object({ dsn: z.string().optional().default('') }).optional().default({ dsn: '' }),
    posthog: z.object({ apiKey: z.string().optional().default(''), host: z.string().optional().default('') }).optional().default({ apiKey: '', host: '' }),
    remote: z.object({
      paywall: z.object({
        sessionsTillPaywall: z.number().int().min(1).max(10).default(3),
        variants: z.record(z.number()).default({ A: 1 })
      }).default({ sessionsTillPaywall: 3, variants: { A: 1 } }),
      surprise: z.object({ frequencyMultiplier: z.number().min(0).max(3).default(1.0) }).default({ frequencyMultiplier: 1.0 })
    }).optional().default({ paywall: { sessionsTillPaywall: 3, variants: { A: 1 } }, surprise: { frequencyMultiplier: 1.0 } }),
    urls: z.object({
      privacyPolicy: z.string().optional().default('https://example.com/privacy'),
      termsOfService: z.string().optional().default('https://example.com/terms'),
      support: z.string().optional().default('https://example.com/support')
    }).optional().default({ privacyPolicy: 'https://example.com/privacy', termsOfService: 'https://example.com/terms', support: 'https://example.com/support' })
  });

  const parsed = AppConfigSchema.safeParse(extra);
  if (!parsed.success) {
    try { console.warn('Invalid AppConfig; using defaults', parsed.error.format()); } catch {}
  }
  const data = parsed.success ? parsed.data : AppConfigSchema.parse({});
  return data as AppConfig;
}
```

## study-buddy/src/types/index.ts
```ts
export type AgeGroup = 'young' | 'elementary' | 'tween' | 'teen';

export interface Subject {
  id: string;
  label: string;
  emoji: string;
  category: string;
  difficulty: 'easy' | 'medium' | 'hard';
  checkIns: string[];
}

export interface Buddy {
  id: string;
  name: string;
  emoji: string;
  color: string;
  personality: string;
  sounds?: string[];
  animationStyle?: string;
  description?: string;
}

export interface VoiceConfig {
  language: string;
  rate: number;
  pitch: number;
  voice?: string;
}

export interface ParentGate {
  question: string;
  answer: string;
}

export interface AgeConfig {
  id: AgeGroup;
  displayRange: string;
  sessionLength: number; // seconds
  breakDuration: number; // seconds
  checkInFrequency: number; // minutes
  interactionFrequency: number; // minutes
  voicePitch: number;
  voiceRate: number;
  primaryColor: string;
  secondaryColor?: string;
  accentColor?: string;
  startMessage?: string;
  welcomeBackMessage?: string;
  completionMessage?: string;
  streakLabel?: string;
  statsLabel?: string;
  [key: string]: unknown;
}

export interface SessionLogEntry {
  time: number; // seconds
  question: string;
  response: string;
  timestamp: string; // ISO
}

export interface GeneratePeerLineInput {
  ageGroup: AgeGroup;
  buddyPersonality?: string;
  subjectId: string;
  seconds: number;
  sessionLength: number;
  context?: 'tick' | 'backgroundReturn';
  sessionId?: string;
}

// React Navigation augmentation (global)
import type { RootStackParamList } from '../App';
declare global {
  namespace ReactNavigation {
    interface RootParamList extends RootStackParamList {}
  }
}
```

# Study Buddy - Complete App Structure (Modular Architecture)

## Project Structure Overview
```
study-buddy/
├── app.json
├── package.json
├── tsconfig.json
├── babel.config.js
├── App.tsx
├── scripts/
│   └── check-config.js
├── src/
│   ├── screens/
│   │   ├── OnboardingScreen.tsx
│   │   ├── ModeSelectionScreen.tsx
│   │   ├── MainScreen.tsx
│   │   ├── CalmModeScreen.tsx
│   │   ├── ParentSettingsScreen.tsx
│   │   ├── CelebrationScreen.tsx
│   │   ├── PaywallScreen.tsx
│   │   └── ConsentScreen.tsx
│   ├── components/
│   │   ├── BuddyCharacter.tsx
│   │   ├── StudyTimer.tsx
│   │   ├── CheckInMessage.tsx
│   │   ├── BigButton.tsx
│   │   └── ScreenBackground.tsx
│   ├── utils/
│   │   ├── core/
│   │   │   ├── storage.ts
│   │   │   └── storageKeys.ts
│   │   ├── config/
│   │   │   └── constants.ts
│   │   ├── content/
│   │   │   └── peerLines.ts
│   │   ├── intl/
│   │   │   └── i18n.ts
│   │   ├── media/
│   │   │   ├── audio.ts
│   │   │   └── photoManager.ts
│   │   ├── voice/
│   │   │   ├── speech.ts
│   │   │   └── voice.ts
│   │   ├── analytics/
│   │   │   ├── index.ts
│   │   │   └── events.ts
│   │   ├── purchases/
│   │   │   └── index.ts
│   │   ├── errors/
│   │   │   └── index.ts
│   │   ├── nav/
│   │   │   └── index.ts
│   │   └── scheduler/
│   │       └── index.ts
│   ├── assets/
│   │   ├── animations/
│   │   │   ├── buddy-animations.ts
│   │   │   ├── confetti.json
│   │   │   ├── studying.json
│   │   │   ├── celebrating.json
│   │   │   ├── idle.json
│   │   │   └── encouraging.json
│   │   ├── icons/
│   │   │   ├── icon.png
│   │   │   └── adaptive-icon.png
│   │   ├── splash.png
│   │   └── favicon.png
│   ├── ui/
│   │   ├── tokens.ts
│   │   ├── alerts.ts
│   │   └── components/
│   │       ├── Button.tsx
│   │       ├── Card.tsx
│   │       └── ModalFrame.tsx
│   └── types/
│       └── index.ts
└── README.md
```

---

## study-buddy/package.json
```json
{
  "name": "study-buddy",
  "version": "1.0.0",
  "main": "node_modules/expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "check:config": "node ./scripts/check-config.js",
    "postinstall": "npx expo install --fix || true",
    "test": "jest",
    "test:e2e:ios": "detox test -c ios.sim.debug",
    "test:e2e:android": "detox test -c android.emu.debug"
  },
  "dependencies": {
    "expo": "~53.0.0",
    "expo-status-bar": "~1.6.0",
    "expo-av": "~13.4.1",
    "expo-speech": "~11.3.0",
    "expo-haptics": "~12.4.0",
    "expo-keep-awake": "~12.3.0",
    "expo-camera": "~13.4.0",
    "expo-local-authentication": "~13.4.0",
    "expo-crypto": "~12.6.0",
    "react": "19.0.0",
    "react-native": "0.79.0",
    "@react-navigation/native": "^6.1.7",
    "@react-navigation/stack": "^6.3.17",
    "react-native-safe-area-context": "4.6.3",
    "react-native-screens": "~3.22.0",
    "react-native-gesture-handler": "~2.12.0",
    "@react-native-async-storage/async-storage": "1.18.2",
    "lottie-react-native": "^6.0.0",
    "react-native-svg": "13.9.0",
    "expo-notifications": "~0.20.1",
    "react-native-reanimated": "~3.3.0",
    "react-native-purchases": "^7.0.0",
    "@react-native-community/slider": "4.4.2",
    "expo-localization": "~14.2.1",
    "expo-file-system": "~15.4.5",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "jest": "^29.7.0",
    "jest-expo": "~53.0.0",
    "@types/jest": "^29.5.12",
    "detox": "^20.0.0"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "private": true
}
```

---

## study-buddy/src/utils/notifications.errors.test.ts
```ts
import * as Notifications from 'expo-notifications';
import { ensureNotificationsSetup } from './notifications';

describe('notifications error paths', () => {
  beforeEach(() => {
    jest.resetAllMocks();
  });

  it('permission denied path exits without throwing', async () => {
    jest.spyOn(Notifications, 'getPermissionsAsync' as any).mockResolvedValueOnce({ status: 'denied' } as any);
    await expect(ensureNotificationsSetup()).resolves.toBeUndefined();
  });

  it('channel/category throw is caught and does not crash', async () => {
    jest.spyOn(Notifications, 'getPermissionsAsync' as any).mockResolvedValueOnce({ status: 'granted' } as any);
    jest.spyOn(Notifications, 'setNotificationChannelAsync' as any).mockRejectedValueOnce(new Error('channel-fail'));
    jest.spyOn(Notifications, 'setNotificationCategoryAsync' as any).mockRejectedValueOnce(new Error('category-fail'));
    await expect(ensureNotificationsSetup()).resolves.toBeUndefined();
  });
});
```

---

## study-buddy/src/utils/voice/speech-errors.test.ts
```ts
import * as Speech from 'expo-speech';
import { smartSpeak } from '@utils/voice/speech';

describe('smartSpeak error paths', () => {
  it('survives isSpeakingAsync rejection', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockResolvedValue(undefined as any);
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => {} as any);
    const isSpeakingSpy = jest.spyOn(Speech, 'isSpeakingAsync' as any).mockRejectedValueOnce(new Error('fail'));
    await expect(smartSpeak('hello', { forceSpeak: true })).resolves.toBeUndefined();
    stopSpy.mockRestore();
    speakSpy.mockRestore();
    isSpeakingSpy.mockRestore();
  });

  it('survives stop/speak rejections', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockRejectedValueOnce(new Error('fail'));
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => { throw new Error('speak-fail'); });
    const isSpeakingSpy = jest.spyOn(Speech, 'isSpeakingAsync' as any).mockResolvedValue(false as any);
    await expect(smartSpeak('hello', { forceSpeak: true })).resolves.toBeUndefined();
    stopSpy.mockRestore();
    speakSpy.mockRestore();
    isSpeakingSpy.mockRestore();
  });
});
```

---
## study-buddy/src/screens/__tests__/parentGate.test.ts
```ts
import { generateParentGate } from '@utils/config/constants';

describe('Parent gate generation', () => {
  it('generates valid question/answer for age template', () => {
    const gate = generateParentGate({ parentGate: { minNumber: 10, maxNumber: 30, operation: 'addition' } as any });
    expect(gate.question).toMatch(/What|\?|\d+/);
    expect(gate.answer).toMatch(/^\d+$/);
  });
});
```

---

## study-buddy/src/utils/config/appConfig.test.ts
```ts
import { getAppConfig } from '@config/appConfig';

describe('AppConfig URLs and manage subscriptions', () => {
  it('provides well-formed default URLs', () => {
    const cfg = getAppConfig();
    expect(cfg.urls.privacyPolicy).toMatch(/^https?:\/\//);
    expect(cfg.urls.termsOfService).toMatch(/^https?:\/\//);
    expect(cfg.urls.support).toMatch(/^https?:\/\//);
    expect(cfg.manageSubscriptions.ios).toMatch(/itms-apps:\/\//);
    expect(cfg.manageSubscriptions.android).toMatch(/^https?:\/\//);
  });
});
```

---

## study-buddy/src/screens/__tests__/purchases.test.ts
```ts
import Purchases from 'react-native-purchases';

describe('Purchases error handling', () => {
  it('configure/getCustomerInfo failures do not crash', async () => {
    const configureSpy = jest.spyOn(Purchases, 'configure' as any).mockRejectedValueOnce(new Error('fail'));
    const infoSpy = jest.spyOn(Purchases, 'getCustomerInfo' as any).mockRejectedValueOnce(new Error('fail'));
    // Minimal expectation: spies called, no throw here (actual App.tsx flow depends on runtime)
    await expect(Purchases.configure({ apiKey: 'x' } as any)).rejects.toThrow();
    await expect(Purchases.getCustomerInfo()).rejects.toThrow();
    configureSpy.mockRestore();
    infoSpy.mockRestore();
  });
});
```

---

## study-buddy/src/utils/voice/speech-disabled.test.ts
```ts
import * as Speech from 'expo-speech';
import { smartSpeak } from '@utils/voice/speech';

describe('smartSpeak screen disabled', () => {
  it('does not speak when screen disabled (no force)', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockResolvedValue(undefined as any);
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => {} as any);
    // Temporarily mock load settings to disable main screen
    const mod = await import('@utils/voice/speech');
    (mod as any).loadSpeechSettings = async () => ({ mainScreenEnabled: false, calmModeEnabled: true, celebrationEnabled: true, rate: 1, pitch: 1 });
    await smartSpeak('hello', { screenType: 'main' });
    expect(speakSpy).not.toHaveBeenCalled();
    stopSpy.mockRestore();
    speakSpy.mockRestore();
  });
});
```

---

## study-buddy/src/utils/media/photoPermissions.test.ts
```ts
import { ensureCameraPermission } from '@utils/permissions';
import * as CameraMod from 'expo-camera';

describe('Camera permission', () => {
  it('denied permission returns granted=false', async () => {
    jest.spyOn(CameraMod.Camera, 'getCameraPermissionsAsync' as any).mockResolvedValueOnce({ granted: false } as any);
    jest.spyOn(CameraMod.Camera, 'requestCameraPermissionsAsync' as any).mockResolvedValueOnce({ granted: false } as any);
    const res = await ensureCameraPermission();
    expect(res.granted).toBe(false);
  });
});
```

## study-buddy/src/utils/notificationsSchedule.test.ts
```ts
import { buildCheckInNotifications } from './notificationsSchedule';

describe('buildCheckInNotifications', () => {
  it('produces 3 scheduled notifications with increasing triggers', () => {
    const intervalMs = 6000; // 6s for test profile
    const out = buildCheckInNotifications({
      ageGroup: 'tween',
      subjectId: 'science',
      sessionTime: 120, // 2 min elapsed
      intervalMs,
      sessionLength: 1200,
      sessionId: 'seed-123',
    });
    expect(out).toHaveLength(3);
    expect(out[0].trigger.seconds).toBeGreaterThan(0);
    expect(out[1].trigger.seconds).toBeGreaterThan(out[0].trigger.seconds);
    expect(out[2].trigger.seconds).toBeGreaterThan(out[1].trigger.seconds);
    expect(out[0].content.title).toBe('Study Buddy');
    expect(typeof out[0].content.body).toBe('string');
    expect(out[0].content.body.length).toBeGreaterThan(0);
  });
});
```

---

## study-buddy/app.json
```json
{
  "expo": {
    "name": "Study Buddy",
    "slug": "study-buddy",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./src/assets/icons/icon.png",
    "userInterfaceStyle": "light",
    "runtimeVersion": { "policy": "sdkVersion" },
    "splash": {
      "image": "./src/assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#4A90E2"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.focusflow.studybuddy",
      "buildNumber": "1",
      "infoPlist": {
        "NSMicrophoneUsageDescription": "Study Buddy needs microphone access to record encouraging messages.",
        "NSCameraUsageDescription": "Study Buddy uses the camera to take an optional photo of completed homework.",
        "NSPhotoLibraryAddUsageDescription": "Study Buddy saves homework photos to your device only.",
        "UIFileSharingEnabled": false,
        "LSSupportsOpeningDocumentsInPlace": false
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./src/assets/icons/adaptive-icon.png",
        "backgroundColor": "#4A90E2"
      },
      "package": "com.focusflow.studybuddy",
      "versionCode": 1,
      "permissions": ["RECORD_AUDIO", "VIBRATE", "CAMERA", "POST_NOTIFICATIONS"]
    },
    "web": {
      "favicon": "./src/assets/favicon.png"
    },
    "plugins": [
      ["sentry-expo"]
    ],
    "extra": {
      "eas": {
        "projectId": "your-project-id"
      },
      "revenuecat": {
        "iosApiKey": "REPLACE_WITH_REVENUECAT_IOS_API_KEY",
        "androidApiKey": "REPLACE_WITH_REVENUECAT_ANDROID_API_KEY",
        "entitlementId": "premium"
      },
      "manageSubscriptions": {
        "ios": "itms-apps://apps.apple.com/account/subscriptions",
        "android": "https://play.google.com/store/account/subscriptions?package=com.focusflow.studybuddy"
      },
      "sentry": {
        "dsn": "REPLACE_WITH_SENTRY_DSN"
      },
      "posthog": {
        "apiKey": "REPLACE_WITH_POSTHOG_API_KEY",
        "host": "https://us.i.posthog.com"
      },
      "remote": {
        "paywall": { "sessionsTillPaywall": 3, "variants": { "A": 0.5, "B": 0.5 } },
        "surprise": { "frequencyMultiplier": 1.0 }
      },
      "urls": {
        "privacyPolicy": "https://example.com/privacy",
        "termsOfService": "https://example.com/terms",
        "support": "https://example.com/support"
      }
    }
  }
}
```

---

## study-buddy/babel.config.js
```javascript
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      ['module-resolver', {
        root: ['./'],
        alias: {
          '@screens': './src/screens',
          '@components': './src/components',
          '@utils': './src/utils',
          '@assets': './src/assets',
          '@config': './src/utils/config',
          '@config/*': './src/utils/config/*',
          '@content': './src/utils/content',
          '@types': './src/types',
          '@ui': './src/ui',
          '@ui/*': './src/ui/*'
        },
        extensions: ['.ts', '.tsx', '.js', '.json']
      }],
      'react-native-reanimated/plugin' // must be last
    ]
  };
};
```

---

## study-buddy/tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2019",
    "module": "ESNext",
    "jsx": "react-native",
    "strict": true,
    "noImplicitAny": true,
    "moduleResolution": "node",
    "allowJs": false,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@screens/*": ["src/screens/*"],
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"],
      "@assets/*": ["src/assets/*"],
      "@config": ["src/utils/config"],
      "@config/*": ["src/utils/config/*"],
      "@content/*": ["src/utils/content/*"],
      "@types/*": ["src/types/*"],
      "@ui": ["src/ui"],
      "@ui/*": ["src/ui/*"]
    }
  }
}
```

---

## study-buddy/.github/workflows/ci.yml
```yaml
name: CI

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]

jobs:
  unit-tests:
    name: Split project and run unit tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Split consolidated app into project files
        run: |
          cd "apps/get-rich-game/docs/study buddy"
          python3 ./split_study_buddy.py --create

      - name: Install dependencies
        run: |
          cd "apps/get-rich-game/docs/study buddy/study-buddy"
          npm ci

      - name: Run unit tests (Jest)
        run: |
          cd "apps/get-rich-game/docs/study buddy/study-buddy"
          npm run test -- --ci
```

---

## study-buddy/.github/workflows/build.yml
```yaml
name: Build (EAS)

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*.*.*'

jobs:
  build-ios:
    runs-on: macos-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest

      - name: Split consolidated app
        run: |
          cd "apps/get-rich-game/docs/study buddy"
          python3 ./split_study_buddy.py --create

      - name: Install deps
        run: |
          cd "apps/get-rich-game/docs/study buddy/study-buddy"
          npm ci

      - name: EAS build iOS
        working-directory: apps/get-rich-game/docs/study buddy/study-buddy
        env:
          EAS_TOKEN: ${{ secrets.EAS_TOKEN }}
        run: |
          eas build --platform ios --non-interactive --profile production

  build-android:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest

      - name: Split consolidated app
        run: |
          cd "apps/get-rich-game/docs/study buddy"
          python3 ./split_study_buddy.py --create

      - name: Install deps
        run: |
          cd "apps/get-rich-game/docs/study buddy/study-buddy"
          npm ci

      - name: EAS build Android
        working-directory: apps/get-rich-game/docs/study buddy/study-buddy
        env:
          EAS_TOKEN: ${{ secrets.EAS_TOKEN }}
        run: |
          eas build --platform android --non-interactive --profile production
```

---

## study-buddy/App.tsx
```tsx
import React, { useState, useEffect, createContext } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { StatusBar } from 'expo-status-bar';
import * as KeepAwake from 'expo-keep-awake';
import * as Notifications from 'expo-notifications';
import { Platform, View, Text, Alert } from 'react-native';
import Purchases from 'react-native-purchases';
import Constants from 'expo-constants';
import * as Sentry from 'sentry-expo';
import { initAnalytics, track } from '@utils/analytics';
import { ensureNotificationPermission } from '@utils/permissions';
import { extractActionIdFromResponse } from '@utils/notifications';
import { getAppConfig } from '@config/appConfig';

import OnboardingScreen from '@screens/OnboardingScreen';
import ModeSelectionScreen from '@screens/ModeSelectionScreen';
import MainScreen from '@screens/MainScreen';
import CalmModeScreen from '@screens/CalmModeScreen';
import ParentSettingsScreen from '@screens/ParentSettingsScreen';
import CelebrationScreen from '@screens/CelebrationScreen';
import PaywallScreen from '@screens/PaywallScreen';
import ConsentScreen from '@screens/ConsentScreen';
import { getStorageItem, setStorageItem } from '@utils/core/storage';
import { getStringKey, setStringKey } from '@utils/core/storageKeys';
import { initializeLanguage } from '@utils/intl/i18n';
import { cleanOldPhotos } from '@utils/media/photoManager';

const APP_CONFIG = getAppConfig();
Sentry.init({
  dsn: APP_CONFIG.sentry.dsn,
  enableInExpoDevelopment: true,
  debug: __DEV__,
});

class ErrorBoundary extends React.Component<{ children: React.ReactNode }, { hasError: boolean }>{
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  componentDidCatch(error, errorInfo) {
    this.setState({ hasError: true });
    Sentry.Native.captureException(error, { extra: errorInfo });
  }
  render() {
    if (this.state.hasError) {
      return (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
          <Text style={{ fontSize: 40 }}>😢</Text>
          <Text>Oops! Your buddy needs a quick break.</Text>
        </View>
      );
    }
    return this.props.children as any;
  }
}

export type RootStackParamList = {
  Onboarding: undefined;
  ModeSelection: undefined;
  Main: { selectedSubject?: { id: string; label: string }; quickStart?: { workMinutes?: number; breakMinutes?: number } } | undefined;
  CalmMode: undefined;
  ParentSettings: { sessionLog?: unknown[] } | undefined;
  Celebration: { sessionTime: number; totalTime: number; streak: number; ageGroup: string; workPhoto?: string | null; sessionLog: unknown[]; tokenAward?: number };
  Paywall: { ageGroup: string };
  Consent: undefined;
};

const Stack = createStackNavigator<RootStackParamList>();

export interface SubscriptionContextValue {
  isPremium: boolean;
  checkPremiumStatus: () => Promise<void> | void;
}

export const SubscriptionContext = createContext<SubscriptionContextValue>({
  isPremium: false,
  checkPremiumStatus: () => {},
});

export default function App(): JSX.Element {
  const [isFirstLaunch, setIsFirstLaunch] = useState<boolean | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [isPremium, setIsPremium] = useState<boolean>(false);

  useEffect(() => {
    runMigrations();
    checkFirstLaunch();
    KeepAwake.activateKeepAwakeAsync();
    ensureNotificationPermission();
    initializeLanguage();
    cleanOldPhotos();
    initializeRevenueCat();
    initAnalytics();

    const sub = Notifications.addNotificationResponseReceivedListener(async (response) => {
      try {
        const actionId = extractActionIdFromResponse(response);
        await setStorageItem('lastNotifAction', actionId || '');
      } catch (e) {}
    });
    return () => sub.remove();
  }, []);

  const initializeRevenueCat = async () => {
    try {
      const iosKey = APP_CONFIG.revenuecat.iosApiKey;
      const androidKey = APP_CONFIG.revenuecat.androidApiKey;
      const apiKey = Platform.select({ ios: iosKey, android: androidKey });
      if (apiKey) {
        await Purchases.configure({ apiKey });
        await checkPremiumStatus();
      }
    } catch {}
  };

  const checkPremiumStatus = async () => {
    try {
      const customerInfo = await Purchases.getCustomerInfo();
      const extra = (Constants?.manifest?.extra as any) || {};
      const entitlementId = extra?.revenuecat?.entitlementId || 'premium';
      setIsPremium(customerInfo.entitlements.active[entitlementId] !== undefined);
    } catch {}
  };

  // notifications moved to @utils/notifications

  const checkFirstLaunch = async () => {
    const hasLaunched = await getStorageItem('hasLaunched');
    setIsFirstLaunch(!hasLaunched);
    setIsLoading(false);
  };

  // Simple storage schema migration harness
  const runMigrations = async (): Promise<void> => {
    try {
      const VERSION_KEY = 'storageVersion' as any;
      const current = await getStringKey(VERSION_KEY);
      const ver = current ? parseInt(current) : 0;
      // v1 example: ensure streak keys exist with sane defaults
      if (ver < 1) {
        const streak = await getStringKey('currentStreak' as any);
        if (streak === null) await setStringKey('currentStreak' as any, '0');
        const total = await getStringKey('totalFocusTime' as any);
        if (total === null) await setStringKey('totalFocusTime' as any, '0');
        await setStringKey(VERSION_KEY, '1');
      }
      // future migrations go here
    } catch {}
  };

  if (isLoading) return null;

  // Gate production if critical config missing
  if (!__DEV__) {
    const ph = APP_CONFIG.posthog;
    const rc = APP_CONFIG.revenuecat;
    const sentryCfg = APP_CONFIG.sentry;
    const missing = !ph.apiKey || !ph.host || (!(rc.iosApiKey || rc.androidApiKey)) || !sentryCfg.dsn;
    if (missing) {
      return (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', padding: 24 }}>
          <Text style={{ fontSize: 22, fontWeight: 'bold', marginBottom: 8 }}>Configuration Required</Text>
          <Text style={{ textAlign: 'center', color: '#2C3E50' }}>
            Missing analytics, error reporting, or purchase configuration. Please update app settings and relaunch.
          </Text>
        </View>
      );
    }
  }

  return (
    <SubscriptionContext.Provider value={{ isPremium, checkPremiumStatus }}>
      <ErrorBoundary>
        <NavigationContainer>
          <StatusBar style="dark" />
          <Stack.Navigator screenOptions={{ headerShown: false, gestureEnabled: false }}>
            {isFirstLaunch ? (
              <Stack.Screen name="Onboarding" component={OnboardingScreen} />
            ) : null}
            <Stack.Screen name="ModeSelection" component={ModeSelectionScreen} />
            <Stack.Screen name="Main" component={MainScreen} />
            <Stack.Screen name="CalmMode" component={CalmModeScreen} />
            <Stack.Screen name="ParentSettings" component={ParentSettingsScreen} />
            <Stack.Screen name="Celebration" component={CelebrationScreen} />
            <Stack.Screen name="Paywall" component={PaywallScreen} options={{ presentation: 'modal' }} />
            <Stack.Screen name="Consent" component={ConsentScreen} />
          </Stack.Navigator>
        </NavigationContainer>
      </ErrorBoundary>
    </SubscriptionContext.Provider>
  );
}
```

---

## study-buddy/src/utils/config/constants.ts
```ts
import { Dimensions } from 'react-native';
import type { AgeGroup, AgeConfig, ParentGate, Subject } from '@types/index';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

// ===================================
// MODULAR CONFIGURATION SYSTEM
// Single source of truth for all app behavior
// ===================================

// === CORE TIMING CONFIGURATION ===
export const TIMING_CONFIG = {
  // Animation durations (milliseconds)
  animations: {
    fadeIn: 500,
    slideUp: 300,
    breathingIn: 4000,
    breathingOut: 4000,
    buttonPress: 100,
    celebrationDisplay: 3000,
  },
  
  // Session timings (milliseconds)
  session: {
    buddyFadeDelay: 60 * 1000, // 1 minute before buddy fades
    checkInDisplay: 5 * 1000, // How long check-in messages show
    modalTimeout: 30 * 1000, // Auto-pause if no interaction
    breathingCycle: 8 * 1000, // Calm mode breathing cycle
  },
  
  // Intervals (seconds - converted to ms in usage)
  intervals: {
    liveActivityUpdate: 30, // Update "X kids studying" counter
    progressSave: 60, // Auto-save progress
  }
};

// === RESPONSIVE UI SCALING ===
export const UI_SCALING_CONFIG = {
  // Screen size breakpoints
  breakpoints: {
    small: 350,   // iPhone SE
    medium: 414,  // Standard phones
    large: 768,   // Tablets
    xlarge: 1024  // Large tablets
  },
  
  // Age-based scaling multipliers
  ageScaling: {
    young: { 
      buddySize: 1.2,     // 20% larger buddy
      fontSize: 1.3,     // 30% larger text
      buttonScale: 1.2,   // 20% larger buttons
      spacing: 1.2,       // 20% more spacing
      iconSize: 1.4       // 40% larger icons
    },
    elementary: { 
      buddySize: 1.0,     // Base size
      fontSize: 1.0,     // Base text
      buttonScale: 1.0,   // Base buttons
      spacing: 1.0,       // Base spacing
      iconSize: 1.0       // Base icons
    },
    tween: { 
      buddySize: 0.85,    // 15% smaller buddy
      fontSize: 0.95,    // 5% smaller text
      buttonScale: 0.95,  // 5% smaller buttons
      spacing: 0.9,       // 10% less spacing
      iconSize: 0.9       // 10% smaller icons
    },
    teen: { 
      buddySize: 0.7,     // 30% smaller buddy
      fontSize: 0.85,    // 15% smaller text
      buttonScale: 0.9,   // 10% smaller buttons
      spacing: 0.8,       // 20% less spacing
      iconSize: 0.8       // 20% smaller icons
    }
  },
  
  // Base sizes (scaled by age and screen)
  baseSizes: {
    buddySize: 180,
    buttonHeight: 60,
    iconSize: 24,
    borderRadius: 15,
    shadowRadius: 8
  }
};

// === MODULAR AGE GROUP DATA ===
// All age-specific behavior controlled from here
const AGE_GROUP_TEMPLATES = {
  young: {
    id: 'young',
    ageRange: [5, 7],
    displayRange: '5-7',
    
    // Session defaults (minutes)
    session: {
      defaultDuration: 10,
      breakDuration: 3,
      checkInFrequency: 2,
      interactionFrequency: 15,
      maxDuration: 20
    },
    
    // Voice configuration
    voice: {
      pitch: 1.3,
      rate: 0.8,
      volume: 1.0
    },
    
    // Visual theme
    theme: {
      primary: '#FFB6C1',
      secondary: '#FFE4E1',
      accent: '#FF69B4',
      background: '#FFF8F9'
    },
    
    // Content personality
    personality: {
      encouragementLevel: 'high',    // high, medium, low
      celebrationStyle: 'enthusiastic', // enthusiastic, balanced, cool, minimal
      languageComplexity: 'simple', // simple, moderate, advanced, mature
      emojiUsage: 'frequent'        // frequent, moderate, minimal, none
    },
    
    // Parent gate (math difficulty)
    parentGate: {
      minNumber: 1,
      maxNumber: 10,
      operation: 'addition'
    }
  },
  
  elementary: {
    id: 'elementary',
    ageRange: [8, 10],
    displayRange: '8-10',
    
    session: {
      defaultDuration: 15,
      breakDuration: 5,
      checkInFrequency: 5,
      interactionFrequency: 20,
      maxDuration: 30
    },
    
    voice: {
      pitch: 1.1,
      rate: 0.9,
      volume: 1.0
    },
    
    theme: {
      primary: '#87CEEB',
      secondary: '#E0F6FF',
      accent: '#4682B4',
      background: '#F0F8FF'
    },
    
    personality: {
      encouragementLevel: 'medium',
      celebrationStyle: 'balanced',
      languageComplexity: 'moderate',
      emojiUsage: 'moderate'
    },
    
    parentGate: {
      minNumber: 10,
      maxNumber: 30,
      operation: 'addition'
    }
  },
  
  tween: {
    id: 'tween',
    ageRange: [11, 13],
    displayRange: '11-13',
    
    session: {
      defaultDuration: 20,
      breakDuration: 5,
      checkInFrequency: 7,
      interactionFrequency: 25,
      maxDuration: 45
    },
    
    voice: {
      pitch: 1.0,
      rate: 0.95,
      volume: 0.9
    },
    
    theme: {
      primary: '#98FB98',
      secondary: '#F0FFF0',
      accent: '#228B22',
      background: '#F8FFF8'
    },
    
    personality: {
      encouragementLevel: 'medium',
      celebrationStyle: 'cool',
      languageComplexity: 'advanced',
      emojiUsage: 'minimal'
    },
    
    parentGate: {
      minNumber: 20,
      maxNumber: 50,
      operation: 'addition'
    }
  },
  
  teen: {
    id: 'teen',
    ageRange: [14, 18],
    displayRange: '14+',
    
    session: {
      defaultDuration: 25,
      breakDuration: 5,
      checkInFrequency: 10,
      interactionFrequency: 30,
      maxDuration: 60
    },
    
    voice: {
      pitch: 0.95,
      rate: 1.0,
      volume: 0.8
    },
    
    theme: {
      primary: '#DDA0DD',
      secondary: '#F8F0FF',
      accent: '#9370DB',
      background: '#FDFBFF'
    },
    
    personality: {
      encouragementLevel: 'low',
      celebrationStyle: 'minimal',
      languageComplexity: 'mature',
      emojiUsage: 'none'
    },
    
    parentGate: {
      minNumber: 50,
      maxNumber: 100,
      operation: 'addition'
    }
  }
};

// === DYNAMIC CONTENT GENERATION ===
// Generate age-appropriate content from personality templates
const CONTENT_TEMPLATES = {
  // UI Labels by complexity and celebration style
  labels: {
    simple_enthusiastic: {
      buddySelectionTitle: 'Pick Your Friend!',
      buddySelectionSubtitle: 'Who will help you today?',
      namePrompt: 'Tell me your name, superstar!',
      readyMessage: 'so excited to be your friend!',
      startButtonText: 'Let\'s Learn! 🌈',
      breakButtonText: 'Break Time! 🎈',
      endButtonText: 'All Done! 🌟',
      streakLabel: 'day streak',
      statsLabel: 'Learning time'
    },
    moderate_balanced: {
      buddySelectionTitle: 'Choose Your Buddy!',
      buddySelectionSubtitle: 'Pick your study partner!',
      namePrompt: 'What should I call you?',
      readyMessage: 'ready to help you focus!',
      startButtonText: 'Start Studying! 📚',
      breakButtonText: 'Break Time! 🌟',
      endButtonText: 'Finished! 🎉',
      streakLabel: 'day streak',
      statsLabel: 'Study time'
    },
    advanced_cool: {
      buddySelectionTitle: 'Pick Your Focus Friend',
      buddySelectionSubtitle: 'Choose your style',
      namePrompt: 'What\'s your name?',
      readyMessage: 'here to help you crush it!',
      startButtonText: 'Let\'s Go 💪',
      breakButtonText: 'Quick Break',
      endButtonText: 'Done ✓',
      streakLabel: 'days',
      statsLabel: 'Focus time'
    },
    mature_minimal: {
      buddySelectionTitle: 'Focus Mode',
      buddySelectionSubtitle: 'Select your vibe',
      namePrompt: 'Name (optional)',
      readyMessage: 'ready.',
      startButtonText: 'Start',
      breakButtonText: 'Break',
      endButtonText: 'End',
      streakLabel: 'days',
      statsLabel: 'Total'
    }
  },
  
  // Messages by encouragement level
  messages: {
    high: [
      'You\'re doing AMAZING! 🌟',
      'Wow! Look at you go! 🚀',
      'Super duper job! 🌈',
      'You\'re the best! 💖',
      'Keep being awesome! ⭐'
    ],
    medium: [
      'Great focus! Keep it up! 🌟',
      'You\'re doing awesome! 💪',
      'Nice work! Stay strong! 🚀',
      'Fantastic job! 🎯',
      'Keep going, you\'ve got this! ⭐'
    ],
    low: [
      'In the zone 🎯',
      'Solid 💯',
      'Keep going 📈',
      'Progress ✓',
      'On track 🎪'
    ]
  },
  
  // Break messages by style
  breaks: {
    enthusiastic: {
      title: 'Wiggle Break! 🎉',
      message: 'Time to jump, dance, or get a snack!',
      resumeText: 'More Learning!'
    },
    balanced: {
      title: 'Break Time!',
      message: 'Great work! Take 5 minutes to stretch or grab water.',
      resumeText: 'Back to Work!'
    },
    cool: {
      title: 'Break Time',
      message: 'Good session. Take 5.',
      resumeText: 'Continue'
    },
    minimal: {
      title: 'Break',
      message: '5 minute break.',
      resumeText: 'Resume'
    }
  }
};

// === SUBJECT CONFIGURATION ===
export const SUBJECT_SYSTEM = {
  // Subject definitions with metadata
  subjects: {
    // Elementary subjects
    math: { 
      id: 'math', label: 'Math', emoji: '🔢', 
      category: 'core', difficulty: 'medium',
      checkIns: ['Check your calculations!', 'Show your work!', 'One problem at a time', 'Double-check that answer', 'Remember your formulas']
    },
    reading: { 
      id: 'reading', label: 'Reading', emoji: '📚', 
      category: 'core', difficulty: 'easy',
      checkIns: ['What\'s happening now?', 'Who\'s the main character?', 'What do you think happens next?', 'Picture the scene', 'Keep going, great reading!']
    },
    writing: { 
      id: 'writing', label: 'Writing', emoji: '✏️', 
      category: 'core', difficulty: 'medium',
      checkIns: ['Check your spelling!', 'Add more details', 'How many sentences so far?', 'Remember punctuation', 'Great writing flow!']
    },
    other: { 
      id: 'other', label: 'Other', emoji: '📝', 
      category: 'flexible', difficulty: 'easy',
      checkIns: ['Keep it up!', 'You\'re doing great!', 'Stay focused!', 'Almost there!', 'Excellent work!']
    },
    
    // Advanced subjects
    science: { 
      id: 'science', label: 'Science', emoji: '🔬', 
      category: 'stem', difficulty: 'medium',
      checkIns: ['Test your hypothesis', 'Check your method', 'What\'s the evidence?', 'Think like a scientist', 'Record your observations']
    },
    chemistry: { 
      id: 'chemistry', label: 'Chemistry', emoji: '⚗️', 
      category: 'stem', difficulty: 'hard',
      checkIns: ['Balance those equations!', 'Check your formulas', 'Remember units!', 'Think about reactions', 'Safety first!']
    },
    biology: { 
      id: 'biology', label: 'Biology', emoji: '🧬', 
      category: 'stem', difficulty: 'medium',
      checkIns: ['Think about the process', 'Draw it out if it helps', 'Check your terms', 'Remember the system', 'Life is amazing!']
    },
    history: { 
      id: 'history', label: 'History', emoji: '🏛️', 
      category: 'social', difficulty: 'medium',
      checkIns: ['Dates and names matter', 'What caused this?', 'Think about the timeline', 'Connect the events', 'History repeats!']
    },
    geography: { 
      id: 'geography', label: 'Geography', emoji: '🌍', 
      category: 'social', difficulty: 'easy',
      checkIns: ['Picture the map', 'Remember locations', 'Think about connections', 'Climate matters', 'Explore the world!']
    }
  },
  
  // Age-appropriate subject groupings
  ageGroups: {
    young: ['math', 'reading', 'writing', 'other'],
    elementary: ['math', 'reading', 'writing', 'other'],
    tween: ['math', 'reading', 'writing', 'science', 'history', 'geography', 'other'],
    teen: ['math', 'reading', 'writing', 'science', 'chemistry', 'biology', 'history', 'geography', 'other']
  }
};

// === GAMIFICATION SYSTEM ===
export const GAMIFICATION_CONFIG = {
  // Surprise events (5% chance per session)
  surprises: {
    frequency: 0.05,
    events: [
      { id: 'power_hour', message: 'Power Hour! Everything counts double!', emoji: '⚡' },
      { id: 'buddy_birthday', message: 'It\'s Buddy\'s Birthday!', emoji: '🎂' },
      { id: 'opposite_day', message: 'Opposite Day! Breaks are longer!', emoji: '🔄' },
      { id: 'challenge_mode', message: 'Challenge Mode! Beat yesterday!', emoji: '🏆' },
      { id: 'guest_buddy', message: 'Guest Buddy visiting!', emoji: '👋' },
      { id: 'speed_round', message: 'Speed Round! Quick focus!', emoji: '💨' },
      { id: 'quiet_mode', message: 'Shh... Library Mode!', emoji: '🤫' },
      { id: 'party_mode', message: 'Party Mode! Extra celebrations!', emoji: '🎉' }
    ]
  },
  
  // Mystery Monday events (every Monday)
  mysteryMonday: [
    'Buddy has a hat today!',
    'Timer counts UP instead of down!',
    'Everything is backwards!',
    'Night mode activated!',
    'Speed mode - shorter sessions!',
    'Buddy is feeling quiet today',
    'Double points day!',
    'Surprise colors everywhere!'
  ],
  
  // Seasonal themes (auto-applied by month)
  seasonal: {
    january: { name: 'New Year', emoji: '🎊', color: '#FFD700' },
    february: { name: 'Hearts', emoji: '💕', color: '#FF69B4' },
    march: { name: 'Spring', emoji: '🌸', color: '#98FB98' },
    april: { name: 'Rain', emoji: '🌧️', color: '#87CEEB' },
    may: { name: 'Flowers', emoji: '🌺', color: '#FF6347' },
    june: { name: 'Summer', emoji: '☀️', color: '#FFD700' },
    july: { name: 'Beach', emoji: '🏖️', color: '#20B2AA' },
    august: { name: 'Back to School', emoji: '🎒', color: '#FF8C00' },
    september: { name: 'Fall', emoji: '🍂', color: '#D2691E' },
    october: { name: 'Halloween', emoji: '🎃', color: '#FF8C00' },
    november: { name: 'Thankful', emoji: '🦃', color: '#8B4513' },
    december: { name: 'Winter', emoji: '❄️', color: '#00CED1' }
  }
};

// ===================================
// COMPUTED CONFIGURATIONS
// Generated dynamically from templates
// ===================================

// Generate parent gate questions
export function generateParentGate(ageTemplate: { parentGate: { minNumber: number; maxNumber: number; operation: string } }): ParentGate {
  const { minNumber, maxNumber, operation } = ageTemplate.parentGate;
  const a = Math.floor(Math.random() * (maxNumber - minNumber)) + minNumber;
  const b = Math.floor(Math.random() * (maxNumber - minNumber)) + minNumber;
  
  switch (operation) {
    case 'addition':
      return {
        question: `What's ${a} + ${b}?`,
        answer: (a + b).toString()
      };
    default:
      return { question: `What's ${a} + ${b}?`, answer: (a + b).toString() };
  }
}

// Generate content from templates
function generateContentForAge(ageTemplate) {
  const { languageComplexity, celebrationStyle, encouragementLevel } = ageTemplate.personality;
  const contentKey = `${languageComplexity}_${celebrationStyle}`;
  
  const labels = CONTENT_TEMPLATES.labels[contentKey] || CONTENT_TEMPLATES.labels.moderate_balanced;
  const messages = CONTENT_TEMPLATES.messages[encouragementLevel] || CONTENT_TEMPLATES.messages.medium;
  const breakInfo = CONTENT_TEMPLATES.breaks[celebrationStyle] || CONTENT_TEMPLATES.breaks.balanced;
  const parentGate = generateParentGate(ageTemplate);
  
  return {
    ...labels,
    checkInMessages: messages,
    breakTitle: breakInfo.title,
    breakMessage: breakInfo.message,
    resumeButtonText: breakInfo.resumeText,
    parentGateQuestion: parentGate.question,
    parentGateAnswer: parentGate.answer,
    
    // Generated session messages
    startMessage: generateStartMessage(ageTemplate.personality),
    welcomeBackMessage: generateWelcomeMessage(ageTemplate.personality),
    completionMessage: generateCompletionMessage(ageTemplate.personality)
  };
}

function generateStartMessage(personality) {
  const templates = {
    simple: 'Yay! Let\'s learn together! You\'re amazing!',
    moderate: 'Let\'s do this! I\'m right here with you.',
    advanced: 'Let\'s get this done.',
    mature: 'Focus mode activated.'
  };
  return templates[personality.languageComplexity] || templates.moderate;
}

function generateWelcomeMessage(personality) {
  const templates = {
    simple: 'Welcome back superstar!',
    moderate: 'Welcome back! Ready to continue?',
    advanced: 'Back at it. Nice.',
    mature: 'Resuming.'
  };
  return templates[personality.languageComplexity] || templates.moderate;
}

function generateCompletionMessage(personality) {
  const templates = {
    simple: 'Amazing job! You\'re a superstar!',
    moderate: 'Excellent work! You did it!',
    advanced: 'Solid work today.',
    mature: 'Session complete.'
  };
  return templates[personality.languageComplexity] || templates.moderate;
}

// ===================================
// FINAL COMPUTED CONFIGURATIONS
// Ready-to-use by components
// ===================================

// Generate complete age configurations
export const AGE_CONFIGS: Record<AgeGroup, AgeConfig> = Object.fromEntries(
  (Object.entries(AGE_GROUP_TEMPLATES) as Array<[AgeGroup, typeof AGE_GROUP_TEMPLATES[keyof typeof AGE_GROUP_TEMPLATES]]>).map(([key, template]) => [
    key,
    {
      // Copy base template
      ...template,
      
      // Add computed content
      ...generateContentForAge(template),
      
      // Convert session minutes to seconds for timers
      sessionLength: template.session.defaultDuration * 60,
      breakDuration: template.session.breakDuration * 60,
      checkInFrequency: template.session.checkInFrequency,
      interactionFrequency: template.session.interactionFrequency,
      
      // Add computed UI properties
      buddySize: UI_SCALING_CONFIG.baseSizes.buddySize * UI_SCALING_CONFIG.ageScaling[key].buddySize,
      fontSize: UI_SCALING_CONFIG.ageScaling[key].fontSize,
      buttonScale: UI_SCALING_CONFIG.ageScaling[key].buttonScale,
      
      // Voice properties (direct copy)
      voicePitch: template.voice.pitch,
      voiceRate: template.voice.rate,
      
      // Theme properties (direct copy) 
      primaryColor: template.theme.primary,
      secondaryColor: template.theme.secondary,
      accentColor: template.theme.accent
    }
  ])
);

// ===================================
// UTILITY FUNCTIONS
// For components to access configurations
// ===================================

// Get configuration for specific age group
export const getAgeConfig = (ageGroup: AgeGroup): AgeConfig => {
  return AGE_CONFIGS[ageGroup] ?? AGE_CONFIGS.elementary;
};

// Get subjects appropriate for age
export const getSubjectsForAge = (ageGroup: AgeGroup): Subject[] => {
  const subjectIds = SUBJECT_SYSTEM.ageGroups[ageGroup] ?? SUBJECT_SYSTEM.ageGroups.elementary;
  return subjectIds.map((id: string) => SUBJECT_SYSTEM.subjects[id]);
};

// Get check-in messages for subject
export const getSubjectCheckIns = (subjectId: string): string[] => {
  return SUBJECT_SYSTEM.subjects[subjectId]?.checkIns || SUBJECT_SYSTEM.subjects.other.checkIns;
};

// Get responsive value based on screen size
export const getResponsiveValue = <T,>(values: { small?: T; medium: T; large?: T; xlarge?: T }): T => {
  if (screenWidth < UI_SCALING_CONFIG.breakpoints.small) return values.small || values.medium;
  if (screenWidth < UI_SCALING_CONFIG.breakpoints.medium) return values.medium;
  if (screenWidth < UI_SCALING_CONFIG.breakpoints.large) return values.large || values.medium;
  return values.xlarge || values.large;
};

// Get scaled size for age group
type ScaleKey = 'buddySize' | 'fontSize' | 'buttonScale' | 'spacing' | 'iconSize';
export const getScaledSize = (
  baseSize: number,
  ageGroup: AgeGroup,
  sizeType: ScaleKey = 'buddySize'
): number => {
  const scaling = UI_SCALING_CONFIG.ageScaling[ageGroup] ?? UI_SCALING_CONFIG.ageScaling.elementary;
  return baseSize * scaling[sizeType];
};

// Get timing value
export const getTiming = <T extends keyof typeof TIMING_CONFIG, K extends keyof (typeof TIMING_CONFIG)[T]>(category: T, key: K): number => {
  const group = TIMING_CONFIG[category] as any;
  const value = group?.[key as string];
  return typeof value === 'number' ? value : 1000;
};

// Get current seasonal theme
export const getCurrentSeasonalTheme = () => {
  const month = new Date().getMonth(); // 0-11
  const monthNames = ['january', 'february', 'march', 'april', 'may', 'june', 
                     'july', 'august', 'september', 'october', 'november', 'december'];
  return GAMIFICATION_CONFIG.seasonal[monthNames[month]];
};

// Get random surprise event
export const getRandomSurpriseEvent = () => {
  const events = GAMIFICATION_CONFIG.surprises.events;
  return events[Math.floor(Math.random() * events.length)];
};

// Check if surprise should trigger
export const shouldTriggerSurprise = () => {
  try {
    const extra: any = (require('expo-constants').default?.manifest?.extra || {});
    const mult = extra?.remote?.surprise?.frequencyMultiplier ?? 1.0;
    const freq = Math.max(0, GAMIFICATION_CONFIG.surprises.frequency * mult);
    return Math.random() < freq;
  } catch {
    return Math.random() < GAMIFICATION_CONFIG.surprises.frequency;
  }
};

// Get Mystery Monday change for current week
export const getMysteryMondayChange = () => {
  const today = new Date();
  if (today.getDay() !== 1) return null; // Not Monday
  
  const weekNumber = Math.floor(today.getDate() / 7);
  const changes = GAMIFICATION_CONFIG.mysteryMonday;
  return changes[weekNumber % changes.length];
};

// ===================================
// BACKWARD COMPATIBILITY EXPORTS
// For existing code that uses old names
// ===================================

// Legacy exports (auto-generated from new system)
export const SUBJECTS_ELEMENTARY = getSubjectsForAge('elementary');
export const SUBJECTS_ADVANCED = getSubjectsForAge('teen');
export const SUBJECT_CHECK_INS = Object.fromEntries(
  Object.entries(SUBJECT_SYSTEM.subjects).map(([id, subject]) => [id, subject.checkIns])
);
export const SURPRISE_EVENTS = GAMIFICATION_CONFIG.surprises.events;
export const MYSTERY_MONDAY_CHANGES = GAMIFICATION_CONFIG.mysteryMonday;
export const SEASONAL_THEMES = GAMIFICATION_CONFIG.seasonal;

// Colors system
export const COLORS = {
  primary: '#4A90E2',
  success: '#27AE60',
  warning: '#F39C12',
  danger: '#E74C3C',
  info: '#3498DB',
  purple: '#9B59B6',
  dark: '#2C3E50',
  gray: '#7F8C8D',
  lightGray: '#ECF0F1',
  background: '#F0F8FF',
};
```

---

## study-buddy/src/screens/OnboardingScreen.tsx
```tsx
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Alert
} from 'react-native';
import { Audio } from 'expo-av';
import * as Speech from 'expo-speech';
import { setStorageItem } from '@utils/core/storage';
import { getBuddiesForAge } from '@assets/animations/buddy-animations';
import { 
  AGE_CONFIGS, 
  getAgeConfig, 
  getResponsiveValue, 
  getScaledSize,
  UI_SCALING_CONFIG,
  TIMING_CONFIG
} from '@utils/config/constants';
import { track } from '@utils/analytics';
import { speakWithBuddy } from '@utils/voice/speakWithBuddy';
import { impact } from '@utils/feedback';
import { uiAlert } from '@ui/alerts';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getBalance, getRewardsCatalog } from '@utils/rewards';
import { t } from '@utils/intl/i18n';

type Props = StackScreenProps<RootStackParamList, 'Onboarding'>;

const { width, height } = Dimensions.get('window');

export default function OnboardingScreen({ navigation }: Props) {
  const [selectedAge, setSelectedAge] = useState<'young' | 'elementary' | 'tween' | 'teen' | null>(null);
  const [selectedBuddy, setSelectedBuddy] = useState<{ id: string; name: string; emoji: string; color: string; personality?: string } | null>(null);
  const [childName, setChildName] = useState<string>('');
  const [recording, setRecording] = useState<import('expo-av').Audio.Recording | null>(null);
  const [step, setStep] = useState<'chooseAge' | 'chooseBuddy' | 'recordName' | 'ready'>('chooseAge');

  const selectAge = (ageGroup) => {
    setSelectedAge(ageGroup);
    setStep('chooseBuddy');
  };

  const selectBuddy = (buddy) => {
    setSelectedBuddy(buddy);
    const config = getAgeConfig(selectedAge);
    
    speakWithBuddy({ buddy, ageGroup: selectedAge, text: `Great choice! I'm ${buddy.name} and I'm excited to study with you!` });
    
    setTimeout(() => setStep('recordName'), TIMING_CONFIG.animations.fadeIn * 4);
  };

  const startRecording = async () => {
    try {
      await Audio.requestPermissionsAsync();
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: true,
        playsInSilentModeIOS: true,
      });

      const { recording } = await Audio.Recording.createAsync(
        Audio.RecordingOptionsPresets.HIGH_QUALITY
      );
      setRecording(recording);
    } catch (err) {
      uiAlert('Oops!', 'Could not start recording. You can set this up later!');
    }
  };

  const stopRecording = async () => {
    if (!recording) return;
    
    setRecording(null);
    await recording.stopAndUnloadAsync();
    const uri = recording.getURI();
    
    await setStorageItem('childNameRecording', uri);
    setStep('ready');
    
    const config = getAgeConfig(selectedAge);
    speakWithBuddy({ buddy: selectedBuddy, ageGroup: selectedAge, text: config.completionMessage });
  };

  const completeOnboarding = async () => {
    await setStorageItem('hasLaunched', 'true');
    await setStorageItem('selectedAge', selectedAge);
    await setStorageItem('selectedBuddy', JSON.stringify(selectedBuddy));
    await setStorageItem('childName', childName || 'Buddy');
    track('onboarding_complete', { ageGroup: selectedAge, buddyId: selectedBuddy?.id });
    navigation.replace('Consent');
  };

  const renderChooseAge = () => {
    const ageGroups = Object.entries(AGE_CONFIGS);
    
    return (
      <View style={styles.container}>
        <Text accessibilityRole="header" style={[styles.title, getResponsiveStyles('title')]}> 
          {t('howOldIsYourChild')}
        </Text>
        <Text style={[styles.subtitle, getResponsiveStyles('subtitle')]}> 
          {t('weWillCustomize')}
        </Text>
        
        <View style={styles.ageContainer}>
          {ageGroups.map(([ageKey, config]) => (
            <TouchableOpacity
              key={ageKey}
              style={[styles.ageCard, getAgeCardStyle(ageKey)]}
              onPress={() => selectAge(ageKey)}
            >
              <Text style={[styles.ageEmoji, getResponsiveStyles('ageEmoji')]}>
                {getAgeEmoji(ageKey)}
              </Text>
              <Text style={[styles.ageTitle, getResponsiveStyles('ageTitle')]}>
                {getAgeTitle(ageKey)}
              </Text>
              <Text style={[styles.ageRange, getResponsiveStyles('ageRange')]}>
                Ages {config.displayRange || config.ageRange}
              </Text>
              <Text style={[styles.ageDescription, getResponsiveStyles('ageDescription')]}>
                {getAgeDescription(ageKey)}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>
    );
  };

  const renderChooseBuddy = () => {
    const buddies = selectedAge ? getBuddiesForAge(selectedAge) : [];
    const config = getAgeConfig(selectedAge);
    
    return (
      <View style={styles.container}>
        <Text style={[styles.title, getResponsiveStyles('title')]}>
          {config.buddySelectionTitle}
        </Text>
        <Text style={[styles.subtitle, getResponsiveStyles('subtitle')]}>
          {config.buddySelectionSubtitle}
        </Text>
        
        <View style={styles.buddyContainer}>
          {buddies.map((buddy) => (
            <TouchableOpacity
              key={buddy.id}
              style={[
                styles.buddyCard, 
                selectedBuddy?.id === buddy.id && styles.selectedBuddy,
                getResponsiveStyles('buddyCard')
              ]}
              onPress={() => selectBuddy(buddy)}
            >
              <View style={[
                styles.buddyAvatar, 
                { backgroundColor: buddy.color },
                getResponsiveStyles('buddyAvatar')
              ]}>
                <Text style={[styles.buddyEmoji, getResponsiveStyles('buddyEmoji')]}>
                  {buddy.emoji}
                </Text>
              </View>
              <Text style={[styles.buddyName, getResponsiveStyles('buddyName')]}>
                {buddy.name}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>
    );
  };

  const renderRecordName = () => {
    const config = getAgeConfig(selectedAge);
    
    return (
      <View style={styles.container}>
        <View style={[
          styles.bigBuddyAvatar, 
          { backgroundColor: selectedBuddy?.color },
          getResponsiveStyles('bigBuddyAvatar')
        ]}>
          <Text style={[styles.bigBuddyEmoji, getResponsiveStyles('bigBuddyEmoji')]}>
            {selectedBuddy?.emoji}
          </Text>
        </View>
        
        <Text accessibilityRole="header" style={[styles.title, getResponsiveStyles('title')]}>{t('whatsYourName')}</Text>
        <Text style={[styles.subtitle, getResponsiveStyles('subtitle')]}>{config.namePrompt}</Text>
        
        <TouchableOpacity
          style={[
            styles.recordButton, 
            recording && styles.recordingActive,
            getResponsiveStyles('recordButton')
          ]}
          testID="record-button"
          onPressIn={startRecording}
          onPressOut={stopRecording}
        >
          <Text style={[styles.recordButtonText, getResponsiveStyles('recordButtonText')]}> 
            {recording ? `🎙️ ${t('recording')}` : `🎤 ${t('holdToRecord')}`}
          </Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.skipButton} onPress={() => setStep('ready')} accessibilityRole="button" accessibilityLabel={t('skipForNow')}>
          <Text style={styles.skipText}>{t('skipForNow')}</Text>
        </TouchableOpacity>
      </View>
    );
  };

  const renderReady = () => {
    const config = getAgeConfig(selectedAge);
    
    return (
      <View style={styles.container}>
        <View style={[
          styles.bigBuddyAvatar, 
          { backgroundColor: selectedBuddy?.color },
          getResponsiveStyles('bigBuddyAvatar')
        ]}>
          <Text style={[styles.bigBuddyEmoji, getResponsiveStyles('bigBuddyEmoji')]}>
            {selectedBuddy?.emoji}
          </Text>
        </View>
        
        <Text accessibilityRole="header" style={[styles.title, getResponsiveStyles('title')]}>{t('weAreReady')}</Text>
        <Text style={[styles.subtitle, getResponsiveStyles('subtitle')]}>
          {selectedBuddy?.name} is {config.readyMessage}
        </Text>
        
        <TouchableOpacity
          style={[styles.startButton, getResponsiveStyles('startButton')]}
          onPress={completeOnboarding}
        >
          <Text style={[styles.startButtonText, getResponsiveStyles('startButtonText')]}>
            {config.startButtonText}
          </Text>
        </TouchableOpacity>
      </View>
    );
  };

  // Helper functions for age-specific content
  const getAgeEmoji = (ageKey) => {
    const emojis = { young: '🧸', elementary: '📚', tween: '🎮', teen: '💪' };
    return emojis[ageKey] || '📚';
  };

  const getAgeTitle = (ageKey) => {
    const titles = { young: 'Little Learner', elementary: 'Elementary', tween: 'Tween', teen: 'Teen' };
    return titles[ageKey] || 'Elementary';
  };

  const getAgeDescription = (ageKey) => {
    const descriptions = { 
      young: 'Big celebrations, short sessions', 
      elementary: 'Balanced support & fun',
      tween: 'Cool & independent',
      teen: 'Minimal & focused'
    };
    return descriptions[ageKey] || 'Balanced support & fun';
  };

  const getAgeCardStyle = (ageKey) => {
    const config = getAgeConfig(ageKey);
    return { borderColor: config.primaryColor, borderWidth: 2 };
  };

  const getResponsiveStyles = (component) => {
    const scaling = selectedAge ? UI_SCALING_CONFIG.ageScaling[selectedAge] : UI_SCALING_CONFIG.ageScaling.elementary;
    
    return getResponsiveValue({
      small: getComponentStyle(component, scaling, 0.9),
      medium: getComponentStyle(component, scaling, 1.0),
      large: getComponentStyle(component, scaling, 1.1),
      xlarge: getComponentStyle(component, scaling, 1.2)
    });
  };

  const getComponentStyle = (component, scaling, screenScale) => {
    const baseStyles = {
      title: { fontSize: 32 * scaling.fontSize * screenScale },
      subtitle: { fontSize: 18 * scaling.fontSize * screenScale },
      ageEmoji: { fontSize: 40 * scaling.iconSize * screenScale },
      ageTitle: { fontSize: 18 * scaling.fontSize * screenScale },
      ageRange: { fontSize: 14 * scaling.fontSize * screenScale },
      ageDescription: { fontSize: 12 * scaling.fontSize * screenScale },
      buddyCard: { padding: 15 * scaling.spacing * screenScale },
      buddyAvatar: { 
        width: 80 * scaling.buddySize * screenScale, 
        height: 80 * scaling.buddySize * screenScale,
        borderRadius: 40 * scaling.buddySize * screenScale 
      },
      buddyEmoji: { fontSize: 40 * scaling.iconSize * screenScale },
      buddyName: { fontSize: 16 * scaling.fontSize * screenScale },
      bigBuddyAvatar: { 
        width: 150 * scaling.buddySize * screenScale, 
        height: 150 * scaling.buddySize * screenScale,
        borderRadius: 75 * scaling.buddySize * screenScale 
      },
      bigBuddyEmoji: { fontSize: 70 * scaling.iconSize * screenScale },
      recordButton: { 
        paddingHorizontal: 40 * scaling.spacing * screenScale,
        paddingVertical: 20 * scaling.spacing * screenScale 
      },
      recordButtonText: { fontSize: 20 * scaling.fontSize * screenScale },
      startButton: { 
        paddingHorizontal: 60 * scaling.spacing * screenScale,
        paddingVertical: 20 * scaling.spacing * screenScale 
      },
      startButtonText: { fontSize: 24 * scaling.fontSize * screenScale }
    };
    
    return baseStyles[component] || {};
  };

  return (
    <SafeAreaView style={styles.safeArea}>
      {step === 'chooseAge' && renderChooseAge()}
      {step === 'chooseBuddy' && renderChooseBuddy()}
      {step === 'recordName' && renderRecordName()}
      {step === 'ready' && renderReady()}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#F0F8FF',
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 10,
    textAlign: 'center',
  },
  subtitle: {
    color: '#7F8C8D',
    marginBottom: 40,
    textAlign: 'center',
  },
  ageContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    width: '100%',
  },
  ageCard: {
    width: '45%',
    margin: '2.5%',
    padding: 20,
    borderRadius: 20,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
    alignItems: 'center',
  },
  ageEmoji: {
    marginBottom: 10,
  },
  ageTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 5,
  },
  ageRange: {
    color: '#7F8C8D',
    marginBottom: 5,
  },
  ageDescription: {
    color: '#95A5A6',
    textAlign: 'center',
  },
  buddyContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
  },
  buddyCard: {
    alignItems: 'center',
    borderRadius: 20,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  selectedBuddy: {
    transform: [{ scale: 1.1 }],
    borderWidth: 3,
    borderColor: '#4A90E2',
  },
  buddyAvatar: {
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  buddyEmoji: {},
  buddyName: {
    fontWeight: '600',
    color: '#2C3E50',
  },
  bigBuddyAvatar: {
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 40,
  },
  bigBuddyEmoji: {},
  recordButton: {
    backgroundColor: '#E74C3C',
    borderRadius: 30,
    marginTop: 20,
  },
  recordingActive: {
    backgroundColor: '#C0392B',
    transform: [{ scale: 1.05 }],
  },
  recordButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  skipButton: {
    marginTop: 20,
    padding: 10,
  },
  skipText: {
    color: '#7F8C8D',
    fontSize: 16,
  },
  startButton: {
    backgroundColor: '#27AE60',
    borderRadius: 30,
    marginTop: 40,
  },
  startButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
});
```

---

## study-buddy/src/screens/ModeSelectionScreen.tsx
```tsx
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Modal
} from 'react-native';
import { getStorageItem } from '@utils/core/storage';
import { 
  getAgeConfig, 
  getSubjectsForAge,
  getResponsiveValue,
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import ScreenBackground from '@components/ScreenBackground';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { t } from '@utils/intl/i18n';

const { width } = Dimensions.get('window');

type Props = StackScreenProps<RootStackParamList, 'ModeSelection'>;

export default function ModeSelectionScreen({ navigation }: Props) {
  const [ageGroup, setAgeGroup] = useState('elementary');
  const [studyingCount, setStudyingCount] = useState(0);
  const [streakCount, setStreakCount] = useState(0);
  const [showSubjectModal, setShowSubjectModal] = useState(false);
  const [tokenBalance, setTokenBalance] = useState(0);
  const [showRewardsModal, setShowRewardsModal] = useState(false);

  useEffect(() => {
    loadUserData();
    setupLiveActivity();
    loadBalance();
  }, []);

  const loadUserData = async () => {
    const age = await getStorageItem('selectedAge');
    if (age) setAgeGroup(age);
    
    // Set initial "live" counts with realistic numbers
    setStudyingCount(Math.floor(Math.random() * 500) + 800);
    setStreakCount(Math.floor(Math.random() * 100) + 100);
  };

  const setupLiveActivity = () => {
    // Simulate live activity updates using configured timing
    const interval = setInterval(() => {
      setStudyingCount(Math.floor(Math.random() * 500) + 800);
      setStreakCount(Math.floor(Math.random() * 100) + 100);
    }, TIMING_CONFIG.intervals.liveActivityUpdate * 1000);
    
    return () => clearInterval(interval);
  };

  const loadBalance = async () => {
    try {
      const bal = await getBalance();
      setTokenBalance(bal);
    } catch {}
  };

  const selectSubjectAndStart = (subject) => {
    setShowSubjectModal(false);
    navigation.navigate('Main', { selectedSubject: subject });
  };

  const config = getAgeConfig(ageGroup);

  // Responsive sizing
  const responsiveStyles = useMemo(() => ({
    title: getResponsiveValue({
      small: { fontSize: getScaledSize(24, ageGroup, 'fontSize') },
      medium: { fontSize: getScaledSize(28, ageGroup, 'fontSize') },
      large: { fontSize: getScaledSize(32, ageGroup, 'fontSize') }
    }),
    modeCard: getResponsiveValue({
      small: { width: '90%', padding: getScaledSize(15, ageGroup, 'spacing') },
      medium: { width: '45%', padding: getScaledSize(20, ageGroup, 'spacing') },
      large: { width: '40%', padding: getScaledSize(25, ageGroup, 'spacing') }
    }),
    modeEmoji: getResponsiveValue({
      small: { fontSize: getScaledSize(40, ageGroup, 'iconSize') },
      medium: { fontSize: getScaledSize(50, ageGroup, 'iconSize') },
      large: { fontSize: getScaledSize(60, ageGroup, 'iconSize') }
    })
  }), [ageGroup]);

  return (
    <ScreenBackground ageGroup={ageGroup}>
      <View style={styles.container}>

        {/* Title */}
        <Text
          accessibilityRole="header"
          style={[styles.title, responsiveStyles.title, { color: config.primaryColor }]}
        >
          {t('howAreYouFeeling')}
        </Text>

        {/* Token Badge */}
        <View style={{ alignSelf: 'flex-end', marginBottom: 8 }}>
          <TouchableOpacity onPress={() => setShowRewardsModal(true)} style={{ backgroundColor: '#FFD700', paddingHorizontal: 10, paddingVertical: 6, borderRadius: 16 }}>
            <Text style={{ color: '#2C3E50', fontWeight: '700' }}>🎟️ {tokenBalance}</Text>
          </TouchableOpacity>
        </View>

        {/* Mode Selection */}
        <View style={styles.modeContainer}>
          <TouchableOpacity
            style={[
              styles.modeCard, 
              responsiveStyles.modeCard,
              styles.studyMode,
              { borderColor: config.accentColor }
            ]}
            onPress={() => setShowSubjectModal(true)}
            accessibilityRole="button"
            accessibilityLabel={t('readyToWork')}
            accessibilityHint={t('startQuickly')}
          >
            <Text style={[styles.modeEmoji, responsiveStyles.modeEmoji]}>📚</Text>
            <Text style={[
              styles.modeTitle, 
              { fontSize: getScaledSize(16, ageGroup, 'fontSize'), color: config.primaryColor }
            ]}>
              {t('readyToWork')}
            </Text>
            <Text style={[
              styles.modeDescription,
              { fontSize: getScaledSize(12, ageGroup, 'fontSize') }
            ]}>
              {getModeDescription(ageGroup, 'study')}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[
              styles.modeCard,
              responsiveStyles.modeCard, 
              styles.calmMode,
              { borderColor: '#2196F3' }
            ]}
            onPress={() => navigation.navigate('CalmMode')}
            accessibilityRole="button"
            accessibilityLabel={t('needToCalmDown')}
          >
            <Text style={[styles.modeEmoji, responsiveStyles.modeEmoji]}>🧘</Text>
            <Text style={[
              styles.modeTitle,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize'), color: '#2196F3' }
            ]}>
              {t('needToCalmDown')}
            </Text>
            <Text style={[
              styles.modeDescription,
              { fontSize: getScaledSize(12, ageGroup, 'fontSize') }
            ]}>
              {getModeDescription(ageGroup, 'calm')}
            </Text>
          </TouchableOpacity>
        </View>

        {/* Quick Stats */}
        <View style={styles.statsPreview}>
          <Text style={[
            styles.statsText,
            { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
          ]}>
            {t('startQuickly')}
          </Text>
          <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'center', marginTop: 10 }}>
            {getQuickStarts(ageGroup).map((qs) => (
              <TouchableOpacity
                key={qs.id}
                style={{
                  backgroundColor: 'white',
                  borderColor: config.accentColor,
                  borderWidth: 2,
                  borderRadius: 16,
                  paddingHorizontal: getScaledSize(14, ageGroup, 'spacing'),
                  paddingVertical: getScaledSize(8, ageGroup, 'spacing'),
                  margin: 6,
                }}
                onPress={() => {
                  const subject = getSubjectsForAge(ageGroup).find(s => s.id === qs.subjectId) || { id: 'other', label: 'Other' };
                  navigation.navigate('Main', { selectedSubject: subject, quickStart: { workMinutes: qs.work, breakMinutes: qs.break } });
                }}
                accessibilityRole="button"
                accessibilityLabel={`${qs.label}`}
              >
                <Text style={{ color: config.primaryColor, fontWeight: '600' }}>{qs.emoji} {qs.label}</Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>
      </View>

      {/* Subject Selection Modal */}
      <Modal
        visible={showSubjectModal}
        transparent={true}
        animationType="slide"
      >
        <View style={styles.modalContainer}>
          <View style={[
            styles.modalContent,
            { padding: getScaledSize(30, ageGroup, 'spacing') }
          ]}>
            <Text
              accessibilityRole="header"
              style={[
              styles.modalTitle,
              { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
            ]}
            >
              {t('whatAreYouWorkingOn')}
            </Text>
            <View style={styles.subjectGrid}>
              {getSubjectsForAge(ageGroup).map((subject) => (
                <TouchableOpacity
                  key={subject.id}
                  style={[
                    styles.subjectButton,
                    { 
                      padding: getScaledSize(20, ageGroup, 'spacing'),
                      borderColor: config.accentColor 
                    }
                  ]}
                  onPress={() => selectSubjectAndStart(subject)}
                >
                  <Text style={[
                    styles.subjectEmoji,
                    { fontSize: getScaledSize(32, ageGroup, 'iconSize') }
                  ]}>
                    {subject.emoji}
                  </Text>
                  <Text style={[
                    styles.subjectLabel,
                    { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
                  ]}>
                    {subject.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
            
            <TouchableOpacity
              style={[styles.closeButton, { backgroundColor: config.primaryColor }]}
              onPress={() => setShowSubjectModal(false)}
              accessibilityRole="button"
              accessibilityLabel="Close"
            >
              <Text style={styles.closeButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Rewards Modal */}
      <Modal visible={showRewardsModal} transparent={true} animationType="slide" onRequestClose={() => setShowRewardsModal(false)}>
        <View style={styles.modalContainer}>
          <View style={[styles.modalContent, { padding: getScaledSize(30, ageGroup, 'spacing') }]}>
            <Text style={[styles.modalTitle, { fontSize: getScaledSize(24, ageGroup, 'fontSize') }]}>Rewards</Text>
            <Text style={{ color: '#2C3E50', marginBottom: 10 }}>Balance: {tokenBalance} tokens</Text>
            {getRewardsCatalog().map((r) => (
              <View key={r.id} style={{ backgroundColor: '#F0F8FF', margin: 8, borderRadius: 12, padding: 12, width: '100%' }}>
                <Text style={{ color: '#2C3E50', fontWeight: '600' }}>{r.name}</Text>
                <Text style={{ color: '#7F8C8D' }}>{r.cost} tokens</Text>
              </View>
            ))}
            <Text style={{ color: '#7F8C8D', marginTop: 6, textAlign: 'center' }}>Redeem from Parent Settings</Text>
            <TouchableOpacity style={[styles.closeButton, { backgroundColor: config.primaryColor }]} onPress={() => setShowRewardsModal(false)}>
              <Text style={styles.closeButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

    </ScreenBackground>
  );
}

// Helper function for mode descriptions
function getModeDescription(ageGroup, mode) {
  const descriptions = {
    study: {
      young: 'Time to learn!',
      elementary: 'Study time',
      tween: 'Focus mode', 
      teen: 'Work mode'
    },
    calm: {
      young: 'Feel better',
      elementary: 'Take a breath',
      tween: 'Reset',
      teen: 'Mindfulness'
    }
  };
  
  return descriptions[mode][ageGroup] || descriptions[mode].elementary;
}

// Quick Start presets by age group
function getQuickStarts(ageGroup) {
  const presets = {
    young: [
      { id: 'qs-math-10-3', subjectId: 'math', work: 10, break: 3, emoji: '🔢', label: 'Math 10 + 3' },
      { id: 'qs-read-10-3', subjectId: 'reading', work: 10, break: 3, emoji: '📚', label: 'Read 10 + 3' }
    ],
    elementary: [
      { id: 'qs-math-15-5', subjectId: 'math', work: 15, break: 5, emoji: '🔢', label: 'Math 15 + 5' },
      { id: 'qs-read-15-5', subjectId: 'reading', work: 15, break: 5, emoji: '📚', label: 'Read 15 + 5' }
    ],
    tween: [
      { id: 'qs-sci-20-5', subjectId: 'science', work: 20, break: 5, emoji: '🔬', label: 'Science 20 + 5' },
      { id: 'qs-math-20-5', subjectId: 'math', work: 20, break: 5, emoji: '🔢', label: 'Math 20 + 5' }
    ],
    teen: [
      { id: 'qs-write-25-5', subjectId: 'writing', work: 25, break: 5, emoji: '✏️', label: 'Write 25 + 5' },
      { id: 'qs-chem-25-5', subjectId: 'chemistry', work: 25, break: 5, emoji: '⚗️', label: 'Chem 25 + 5' }
    ]
  };
  return presets[ageGroup] || presets.elementary;
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
  },
  liveActivity: {
    position: 'absolute',
    top: 50,
    width: '100%',
    alignItems: 'center',
  },
  liveText: {
    color: '#7F8C8D',
    marginBottom: 5,
  },
  title: {
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 40,
  },
  modeContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginBottom: 40,
    flexWrap: 'wrap',
  },
  modeCard: {
    borderRadius: 20,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.12,
    shadowRadius: 20,
    elevation: 6,
    backgroundColor: 'white',
    marginBottom: 20,
  },
  studyMode: {
    borderWidth: 2,
  },
  calmMode: {
    borderWidth: 2,
  },
  modeEmoji: {
    marginBottom: 15,
  },
  modeTitle: {
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 8,
  },
  modeDescription: {
    color: '#7F8C8D',
    textAlign: 'center',
  },
  statsPreview: {
    position: 'absolute',
    bottom: 50,
    width: '100%',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  statsText: {
    color: '#95A5A6',
    textAlign: 'center',
    fontStyle: 'italic',
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 20,
    width: '90%',
    maxWidth: 400,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 10,
    elevation: 10,
  },
  modalTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 30,
    textAlign: 'center',
  },
  subjectGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    width: '100%',
  },
  subjectButton: {
    backgroundColor: '#F0F8FF',
    margin: 8,
    borderRadius: 15,
    alignItems: 'center',
    minWidth: 100,
    borderWidth: 2,
  },
  subjectEmoji: {
    marginBottom: 8,
  },
  subjectLabel: {
    fontWeight: '600',
    color: '#2C3E50',
  },
  closeButton: {
    paddingHorizontal: 30,
    paddingVertical: 15,
    borderRadius: 20,
    marginTop: 20,
  },
  closeButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
```

---

## study-buddy/src/screens/MainScreen.tsx
```tsx
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Alert,
  AppState,
  Modal
} from 'react-native';
import * as Speech from 'expo-speech';
import * as Haptics from 'expo-haptics';
import * as LocalAuthentication from 'expo-local-authentication';
import { Camera } from 'expo-camera';
import * as Notifications from 'expo-notifications';
import { getStorageItem, setStorageItem } from '@utils/core/storage';
import { smartSpeak, stopSpeech } from '@utils/voice/speech';
import { speakWithBuddy } from '@utils/voice/speakWithBuddy';
import { impact, success as hapticSuccess } from '@utils/feedback';
import { uiAlert } from '@ui/alerts';
import BuddyCharacter from '@components/BuddyCharacter';
import StudyTimer from '@components/StudyTimer';
import CheckInMessage from '@components/CheckInMessage';
import BigButton from '@components/BigButton';
import { 
  getAgeConfig,
  getSubjectsForAge,
  getSubjectCheckIns,
  shouldTriggerSurprise,
  getRandomSurpriseEvent,
  getMysteryMondayChange,
  getCurrentSeasonalTheme,
  getScaledSize,
  TIMING_CONFIG,
  generateParentGate
} from '@utils/config/constants';
import { generatePeerLine } from '@utils/content/peerLines';
import { resolveVoiceForBuddy } from '@utils/voice/voice';
import ScreenBackground from '@components/ScreenBackground';
import { track } from '@utils/analytics';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getAdaptiveCheckInMinutes, recordInteraction } from '@utils/adaptive';
import { addTokens } from '@utils/rewards';
import { scheduler } from '@utils/scheduler';
import { getStringKey, setStringKey } from '@utils/core/storageKeys';
import { captureError } from '@utils/errors';

const { width, height } = Dimensions.get('window');

type Props = StackScreenProps<RootStackParamList, 'Main'>;

export default function MainScreen({ navigation, route }: Props) {
  const [buddy, setBuddy] = useState<{ id?: string; name?: string; emoji?: string; color?: string; personality?: string } | null>(null);
  const [ageGroup, setAgeGroup] = useState<'young' | 'elementary' | 'tween' | 'teen'>('elementary');
  const [isStudying, setIsStudying] = useState<boolean>(false);
  const [sessionTime, setSessionTime] = useState<number>(0);
  const [totalFocusTime, setTotalFocusTime] = useState<number>(0);
  const [checkInMessage, setCheckInMessage] = useState<string>('');
  const [showCheckIn, setShowCheckIn] = useState<boolean>(false);
  const [currentStreak, setCurrentStreak] = useState<number>(0);
  const [buddyFaded, setBuddyFaded] = useState<boolean>(false);
  const [workPhoto, setWorkPhoto] = useState<string | null>(null);
  const [showProofMode, setShowProofMode] = useState<boolean>(false);
  const [showInteractionModal, setShowInteractionModal] = useState<boolean>(false);
  const [currentQuestion, setCurrentQuestion] = useState<{ id: string; text: string; options: Array<{ label: string; value: string }> } | null>(null);
  const [sessionLog, setSessionLog] = useState<Array<{ time: number; question: string; response: string; timestamp: string }>>([]);
  const [currentSubject, setCurrentSubject] = useState<{ id: string; label: string } | null>(null);
  const [currentSurprise, setCurrentSurprise] = useState<{ id?: string; message: string; emoji: string } | null>(null);
  const [showParentGate, setShowParentGate] = useState<boolean>(false);
  const [parentAnswerInput, setParentAnswerInput] = useState<string>('');
  const [parentGateQA, setParentGateQA] = useState<{ question: string; answer: string }>({ question: '', answer: '' });
  const [wrongAttempts, setWrongAttempts] = useState<number>(0);
  const [gateLockedUntil, setGateLockedUntil] = useState<number>(0);
  const [longPressReady, setLongPressReady] = useState<boolean>(false);
  const quickStart = route.params?.quickStart || null;
  
  const timerInterval = useRef<number | null>(null);
  const checkInInterval = useRef<number | null>(null);
  const interactionInterval = useRef<number | null>(null);
  const fadeTimeout = useRef<number | null>(null);
  const startTimeRef = useRef<number | null>(null);
  const sessionSaltRef = useRef<string>('');
  const appState = useRef(AppState.currentState);
  const cameraRef = useRef<any>(null);
  const scheduledNotifications = useRef<string[]>([]);

  useEffect(() => {
    loadUserData();
    loadSessionData();
    
    // Get selected subject from navigation if available
    if (route.params?.selectedSubject) {
      setCurrentSubject(route.params.selectedSubject);
      startStudyingWithSubject(route.params.selectedSubject);
    }
    
    const subscription = AppState.addEventListener('change', handleAppStateChange);
    return () => {
      clearAllIntervals();
      subscription?.remove();
    };
  }, []);

  const clearAllIntervals = () => {
    if (timerInterval.current) scheduler.clearInterval(timerInterval.current as any);
    if (checkInInterval.current) scheduler.clearInterval(checkInInterval.current as any);
    if (interactionInterval.current) scheduler.clearInterval(interactionInterval.current as any);
    if (fadeTimeout.current) scheduler.clearTimeout(fadeTimeout.current as any);
    timerInterval.current = null;
    checkInInterval.current = null;
    interactionInterval.current = null;
    fadeTimeout.current = null;
  };

  const handleAppStateChange = (nextAppState) => {
    if (appState.current.match(/inactive|background/) && nextAppState === 'active') {
      if (isStudying) {
        showEncouragement();
        cancelScheduledCheckIns();
      }
      checkNotificationAction();
    }
    if (nextAppState.match(/inactive|background/) && isStudying) {
      scheduleBackgroundCheckIns();
    }
    appState.current = nextAppState;
  };

  const checkNotificationAction = async () => {
    const action = await getStringKey('lastNotifAction' as any);
    if (!action) return;
    await setStringKey('lastNotifAction' as any, '');
    if (action === 'RESUME') {
      if (!isStudying) {
        const fallbackSubject = currentSubject || getSubjectsForAge(ageGroup)[0] || { id: 'other', label: 'Other' };
        startStudyingWithSubject(fallbackSubject);
      }
    } else if (action === 'BREAK') {
      takeBreak();
    } else if (action === 'DONE') {
      endSession();
    }
  };

  const loadUserData = async () => {
    const buddyData = await getStorageItem('selectedBuddy');
    const age = await getStorageItem('selectedAge');
    if (buddyData) setBuddy(JSON.parse(buddyData));
    if (age) setAgeGroup(age);
  };

  const loadSessionData = async () => {
    const streak = await getStringKey('currentStreak' as any);
    const totalTime = await getStringKey('totalFocusTime' as any);
    if (streak) setCurrentStreak(parseInt(streak));
    if (totalTime) setTotalFocusTime(parseInt(totalTime));
  };

  const startStudyingWithSubject = (subject: { id: string; label: string }) => {
    setCurrentSubject(subject);
    setIsStudying(true);
    setSessionTime(0);
    setBuddyFaded(false);
    setSessionLog([]);
    startTimeRef.current = Date.now();
    sessionSaltRef.current = Math.random().toString(36).slice(2, 10);
    
    const baseConfig = getAgeConfig(ageGroup);
    const sessionLength = quickStart?.workMinutes ? quickStart.workMinutes * 60 : baseConfig.sessionLength;
    const breakDuration = quickStart?.breakMinutes ? quickStart.breakMinutes * 60 : baseConfig.breakDuration;
    
    // Check for special events
    checkForSpecialEvents();
    
    // Setup all timers using configured values
    setupSessionTimers({ ...baseConfig, sessionLength, breakDuration });
    
    // Initial encouragement
    smartSpeak(`Let's work on ${subject.label}! ${config.startMessage}`, {
      screenType: 'main',
      language: 'en'
    });
    
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    track('session_start', { subjectId: subject.id, ageGroup });
  };

  const setupSessionTimers = (config: { sessionLength: number; breakDuration: number; checkInFrequency: number; interactionFrequency: number }) => {
    // Main timer - compute elapsed to reduce drift
    timerInterval.current = scheduler.setInterval(() => {
      if (startTimeRef.current) {
        const elapsed = Math.floor((Date.now() - startTimeRef.current) / 1000);
        setSessionTime(elapsed);
      }
    }, 1000);
    
    // Voice check-ins using adaptive frequency per subject
    const adaptiveMinutesPromise = getAdaptiveCheckInMinutes(ageGroup, (currentSubject?.id || 'other'), config.checkInFrequency);
    let checkInTime = config.checkInFrequency * 60 * 1000;
    adaptiveMinutesPromise.then((mins) => {
      checkInTime = mins * 60 * 1000;
      if (checkInInterval.current) {
        scheduler.clearInterval(checkInInterval.current as any);
        checkInInterval.current = scheduler.setInterval(() => {
          if (shouldTriggerSurprise()) {
            showSurpriseEvent();
          } else {
            showCheckInMessage();
          }
        }, checkInTime);
      }
    }).catch(() => {});
    // initial interval until adaptive promise resolves
    checkInInterval.current = scheduler.setInterval(() => {
      if (shouldTriggerSurprise()) {
        showSurpriseEvent();
      } else {
        showCheckInMessage();
      }
    }, checkInTime);
    
    // Two-way interaction using config frequency
    const interactionTime = config.interactionFrequency * 60 * 1000;
    interactionInterval.current = scheduler.setInterval(() => {
      showInteractionPrompt();
    }, interactionTime);
    
    // Buddy fade using configured delay
    fadeTimeout.current = scheduler.setTimeout(() => {
      setBuddyFaded(true);
    }, TIMING_CONFIG.session.buddyFadeDelay);
  };

  const scheduleBackgroundCheckIns = async () => {
    try {
      const config = getAgeConfig(ageGroup);
      const intervalMs = config.checkInFrequency * 60 * 1000;
      // Schedule next 3 check-ins using peer-style generator
      const toSchedule = [1, 2, 3].map(i => ({
        content: {
          title: 'Study Buddy',
          body: generatePeerLine({
            ageGroup,
            buddyPersonality: buddy?.personality,
            subjectId: currentSubject?.id || 'other',
            seconds: sessionTime + Math.floor((intervalMs * i) / 1000),
            sessionLength: getAgeConfig(ageGroup).sessionLength,
            context: 'backgroundReturn',
            sessionId: `${startTimeRef.current || 'default'}:${sessionSaltRef.current || 'salt'}`,
          }).replace(/[^\w\s]/g, ''),
          categoryIdentifier: 'checkin-actions',
        },
        trigger: { seconds: Math.max(5, Math.floor((intervalMs * i) / 1000)) },
      }));
      const ids = [];
      for (const n of toSchedule) {
        const id = await Notifications.scheduleNotificationAsync({ content: n.content, trigger: n.trigger });
        ids.push(id);
      }
      scheduledNotifications.current = ids;
    } catch (e) {
      captureError(e, { screen: 'Main', op: 'scheduleBackgroundCheckIns' });
    }
  };

  const cancelScheduledCheckIns = async () => {
    try {
      for (const id of scheduledNotifications.current) {
        await Notifications.cancelScheduledNotificationAsync(id);
      }
      scheduledNotifications.current = [];
    } catch (e) {
      captureError(e, { screen: 'Main', op: 'cancelScheduledCheckIns' });
    }
  };

  const checkForSpecialEvents = () => {
    // Mystery Monday check
    const mysteryChange = getMysteryMondayChange();
    if (mysteryChange) {
      Alert.alert('Mystery Monday! 🎭', mysteryChange);
      setCurrentSurprise({ emoji: '🎭', message: mysteryChange });
    }
    
    // Seasonal theme check
    const seasonalTheme = getCurrentSeasonalTheme();
    if (seasonalTheme) {
      console.log(`Seasonal theme: ${seasonalTheme.name} ${seasonalTheme.emoji}`);
    }
  };

  const showSurpriseEvent = () => {
    const surprise = getRandomSurpriseEvent();
    setCurrentSurprise(surprise);
    
    uiAlert(
      `${surprise.emoji} Surprise!`,
      surprise.message,
      [{ text: 'Awesome!', style: 'default' }]
    );
    
    const config = getAgeConfig(ageGroup);
    speakWithBuddy({ buddy, ageGroup, text: surprise.message, options: { screenType: 'main', forceSpeak: true } });
    hapticSuccess();
  };

  const showCheckInMessage = async () => {
    const config = getAgeConfig(ageGroup);
    const line = generatePeerLine({
      ageGroup,
      buddyPersonality: buddy?.personality,
      subjectId: currentSubject?.id || 'other',
      seconds: sessionTime,
      sessionLength: config.sessionLength,
      context: 'tick',
      sessionId: `${startTimeRef.current || 'default'}:${sessionSaltRef.current || 'salt'}`,
    });
    setCheckInMessage(line);
    setShowCheckIn(true);
    setBuddyFaded(false);
    setTimeout(() => setBuddyFaded(true), TIMING_CONFIG.session.checkInDisplay);
    const voice = await resolveVoiceForBuddy({ ageGroup, buddy });
    await smartSpeak(line.replace(/[^\w\s]/gi, ''), {
      screenType: 'main',
      language: voice.language,
      rate: voice.rate,
      pitch: voice.pitch,
      voice: voice.voice,
    });
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setTimeout(() => setShowCheckIn(false), TIMING_CONFIG.session.checkInDisplay);
  };

  const showInteractionPrompt = () => {
    const questions = getInteractionQuestions();
    const randomQuestion = questions[Math.floor(Math.random() * questions.length)];
    setCurrentQuestion(randomQuestion);
    setShowInteractionModal(true);
    
    // Auto-pause if no response using configured timeout
    setTimeout(() => {
      if (showInteractionModal) {
        pauseSession();
        uiAlert('Timer Paused', 'Tap to continue when ready!');
      }
    }, TIMING_CONFIG.session.modalTimeout);
    
    const config = getAgeConfig(ageGroup);
    speakWithBuddy({ buddy, ageGroup, text: randomQuestion.text });
  };

  const getInteractionQuestions = () => {
    // Dynamic questions based on current subject
    const baseQuestions = [
      {
        id: 'subject',
        text: 'What are you working on?',
        options: getSubjectsForAge(ageGroup).slice(0, 4).map(subject => ({
          label: `${subject.emoji} ${subject.label}`,
          value: subject.id
        }))
      },
      {
        id: 'progress',
        text: 'How much have you finished?',
        options: [
          { label: 'All done! ✅', value: 'complete' },
          { label: 'Most 🔵', value: 'most' },
          { label: 'Half 🟡', value: 'half' },
          { label: 'Just started 🔴', value: 'started' }
        ]
      },
      {
        id: 'difficulty',
        text: "How's it going?",
        options: [
          { label: 'Easy! 😊', value: 'easy' },
          { label: 'OK 😐', value: 'ok' },
          { label: 'Hard 😟', value: 'hard' },
          { label: 'Need help 🆘', value: 'help' }
        ]
      }
    ];
    
    return baseQuestions;
  };

  const handleInteractionResponse = (response) => {
    const logEntry = {
      time: sessionTime,
      question: currentQuestion.id,
      response: response.value,
      timestamp: new Date().toISOString()
    };
    
    setSessionLog([...sessionLog, logEntry]);
    setShowInteractionModal(false);
    // Feed adaptive model
    try { recordInteraction(currentSubject?.id || 'other', response.value); } catch {}
    
    // Handle special responses
    if (response.value === 'help') {
      handleHelpRequest();
    } else {
      provideFeedback(response.value);
    }
  };

  const handleHelpRequest = () => {
    Alert.alert(
      'Need Help?',
      'Should I let your parent know?',
      [
        { text: 'No, I\'ll keep trying', style: 'cancel' },
        { text: 'Yes please', onPress: () => {
          Alert.alert('Help is on the way!', 'Keep trying, someone will check on you soon.');
        }}
      ]
    );
  };

  const provideFeedback = (responseValue) => {
    const encouragements = {
      easy: "Great! Keep crushing it!",
      ok: "Nice steady progress!",
      hard: "You're doing great even though it's tough!",
      complete: "Amazing! You finished!",
      most: "Almost there, fantastic!",
      half: "Halfway is great progress!",
      started: "Good start, keep going!"
    };
    
    if (encouragements[responseValue]) {
      const config = getAgeConfig(ageGroup);
      speakWithBuddy({ buddy, ageGroup, text: encouragements[responseValue] });
    }
  };

  const pauseSession = () => {
    clearAllIntervals();
    setIsStudying(false);
  };

  const takeBreak = () => {
    const config = getAgeConfig(ageGroup);
    
    Alert.alert(
      config.breakTitle,
      config.breakMessage,
      [
        {
          text: "Start Break",
          onPress: () => {
            pauseSession();
            saveSessionData();
            
            // Resume after configured break duration
            setTimeout(() => {
              Alert.alert(
                "Break's Over!",
                "Ready to get back to work?",
                [
                  { text: "5 More Minutes", style: "cancel" },
                  { text: config.resumeButtonText, onPress: () => startStudyingWithSubject(currentSubject) }
                ]
              );
            }, config.breakDuration * 1000); // Already in seconds from config
          }
        },
        {
          text: "Keep Working",
          style: "cancel"
        }
      ]
    );
  };

  const takeWorkPhoto = async () => {
    const { status } = await Camera.requestCameraPermissionsAsync();
    if (status === 'granted') {
      setShowProofMode(true);
    } else {
      Alert.alert('Camera Permission', 'We need camera access for one photo of your work (optional)');
    }
  };

  const capturePhoto = async () => {
    if (cameraRef.current) {
      try {
        const photo = await cameraRef.current.takePictureAsync();
        setWorkPhoto(photo.uri);
        setShowProofMode(false);
        await setStringKey('lastWorkPhoto' as any, photo.uri);
        Alert.alert('Great Work!', 'Your completed homework has been saved!');
      } catch (e) {
        captureError(e, { screen: 'Main', op: 'capturePhoto' });
        Alert.alert('Oops', 'Could not capture photo.');
      }
    }
  };

  const endSession = () => {
    const config = getAgeConfig(ageGroup);
    
    // Offer photo for older kids
    if (['tween', 'teen'].includes(ageGroup)) {
      Alert.alert(
        'Show Your Work!',
        'Take a photo of your completed homework?',
        [
          { text: 'Skip', onPress: () => completeSession() },
          { text: 'Take Photo', onPress: () => {
            takeWorkPhoto();
            completeSession();
          }}
        ]
      );
    } else {
      completeSession();
    }
  };

  const completeSession = () => {
    pauseSession();
    saveSessionData();
    
    // Award tokens based on effort (scaled by minutes and subject difficulty)
    const minutes = Math.floor(sessionTime / 60);
    const base = minutes >= 25 ? 5 : minutes >= 15 ? 3 : minutes >= 5 ? 1 : 0;
    addTokens(base).catch(() => {});

    navigation.navigate('Celebration', {
      sessionTime: sessionTime,
      totalTime: totalFocusTime + sessionTime,
      streak: currentStreak + 1,
      ageGroup: ageGroup,
      workPhoto: workPhoto,
      sessionLog: sessionLog,
      tokenAward: base
    });
    track('session_end', { duration: sessionTime, ageGroup, subjectId: currentSubject?.id });
  };

  const saveSessionData = async () => {
    const newTotalTime = totalFocusTime + sessionTime;
    const newStreak = currentStreak + 1;
    
    // Save all session data
    const savePromises = [
      setStringKey('totalFocusTime' as any, newTotalTime.toString()),
      setStringKey('currentStreak' as any, newStreak.toString()),
      setStringKey('lastSessionDate' as any, new Date().toISOString()),
      setStringKey('lastSessionLog' as any, JSON.stringify(sessionLog))
    ];
    
    try { await Promise.all(savePromises); } catch (e) { captureError(e, { screen: 'Main', op: 'saveSessionData' }); }
    
    setTotalFocusTime(newTotalTime);
    setCurrentStreak(newStreak);
  };

  const showEncouragement = () => {
    const config = getAgeConfig(ageGroup);
    speakWithBuddy({ buddy, ageGroup, text: config.welcomeBackMessage });
  };

  const openParentSettings = () => {
    // Check if gate is locked
    const now = Date.now();
    if (now < gateLockedUntil) {
      const remainingSeconds = Math.ceil((gateLockedUntil - now) / 1000);
      Alert.alert('Please Wait', `Parent gate is locked for ${remainingSeconds} more seconds`);
      return;
    }
    
    // Try biometric first if available
    LocalAuthentication.hasHardwareAsync().then(async (hasHardware) => {
      if (hasHardware) {
        const enrolled = await LocalAuthentication.isEnrolledAsync();
        if (enrolled) {
          const res = await LocalAuthentication.authenticateAsync({ promptMessage: 'Parent Access' });
          if (res.success) {
            navigation.navigate('ParentSettings', { sessionLog });
            return;
          }
        }
      }
      // Fallback: PIN if set, otherwise math gate
      const pin = await getStorageItem('parentPin');
      if (pin) {
        setParentGateQA({ question: 'Enter 4-digit PIN', answer: pin });
        setParentAnswerInput('');
        setLongPressReady(false);
        setShowParentGate(true);
      } else {
        const newGate = generateParentGate(getAgeConfig(ageGroup));
        setParentGateQA(newGate);
        setParentAnswerInput('');
        setLongPressReady(false);
        setShowParentGate(true);
      }
    });
  };

  // Camera mode render
  if (showProofMode) {
    return (
      <Camera style={styles.camera} ref={cameraRef}>
        <View style={styles.cameraContainer}>
          <Text style={[
            styles.cameraText,
            { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
          ]}>
            Show your completed work!
          </Text>
          <TouchableOpacity 
            style={[
              styles.captureButton,
              { 
                width: getScaledSize(70, ageGroup, 'buttonScale'),
                height: getScaledSize(70, ageGroup, 'buttonScale'),
                borderRadius: getScaledSize(35, ageGroup, 'buttonScale')
              }
            ]} 
            onPress={capturePhoto}
          >
            <Text style={[
              styles.captureButtonText,
              { fontSize: getScaledSize(40, ageGroup, 'iconSize') }
            ]}>
              📸
            </Text>
          </TouchableOpacity>
        </View>
      </Camera>
    );
  }

  const config = getAgeConfig(ageGroup);

  return (
    <SafeAreaView style={[styles.safeArea]}>
      <ScreenBackground ageGroup={ageGroup}>
      <View style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity onPress={openParentSettings} style={styles.settingsButton} accessibilityRole="button" accessibilityLabel="Parent settings">
            <Text style={[
              styles.settingsIcon,
              { fontSize: getScaledSize(24, ageGroup, 'iconSize') }
            ]}>
              ⚙️
            </Text>
          </TouchableOpacity>
          <View style={[
            styles.streakContainer,
            { backgroundColor: (config.theme?.accent || '#FFF3CD') + '40' }
          ]}>
            <Text style={[
              styles.streakText,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              🔥 {currentStreak} {config.streakLabel}
            </Text>
          </View>
        </View>

        <BuddyCharacter 
          buddy={buddy} 
          isStudying={isStudying}
          isFaded={buddyFaded}
          ageGroup={ageGroup}
          style={styles.buddyContainer}
        />

        {showCheckIn && (
          <CheckInMessage message={checkInMessage} ageGroup={ageGroup} />
        )}

        {isStudying && (
          <StudyTimer seconds={sessionTime} ageGroup={ageGroup} />
        )}

        <View style={[
          styles.buttonContainer,
          { paddingVertical: getScaledSize(30, ageGroup, 'spacing') }
        ]}>
          {!isStudying ? (
            <BigButton 
              title={config.startButtonText}
              onPress={() => navigation.navigate('ModeSelection')}
              color={config.primaryColor}
              ageGroup={ageGroup}
            />
          ) : (
            <>
              <BigButton 
                title={config.breakButtonText}
                onPress={takeBreak}
                color="#F39C12"
                ageGroup={ageGroup}
              />
              <BigButton 
                title={config.endButtonText}
                onPress={endSession}
                color="#E74C3C"
                ageGroup={ageGroup}
                style={{ marginTop: getScaledSize(20, ageGroup, 'spacing') }}
              />
            </>
          )}
        </View>

        <View style={styles.statsContainer}>
          <Text style={[
            styles.statsText,
            { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
          ]}>
            {config.statsLabel}: {Math.floor(totalFocusTime / 60)} minutes
          </Text>
        </View>
      </View>

      {/* Two-Way Interaction Modal */}
      <Modal
        visible={showInteractionModal}
        transparent={true}
        animationType="slide"
      >
        <View style={styles.modalContainer}>
          <View style={[
            styles.modalContent,
            { padding: getScaledSize(30, ageGroup, 'spacing') }
          ]}>
            <Text style={[
              styles.modalTitle,
              { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
            ]}>
              {currentQuestion?.text}
            </Text>
            <View style={styles.optionsContainer}>
              {currentQuestion?.options.map((option) => (
                <TouchableOpacity
                  key={option.value}
                  style={[
                    styles.optionButton,
                    { 
                      paddingVertical: getScaledSize(15, ageGroup, 'spacing'),
                      paddingHorizontal: getScaledSize(25, ageGroup, 'spacing'),
                      borderColor: config.accentColor 
                    }
                  ]}
                  onPress={() => handleInteractionResponse(option)}
                >
                  <Text style={[
                    styles.optionText,
                    { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
                  ]}>
                    {option.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>
        </View>
      </Modal>

      {/* Surprise Event Display */}
      {currentSurprise && (
        <View style={[
          styles.surpriseBanner,
          { 
            padding: getScaledSize(15, ageGroup, 'spacing'),
            top: getScaledSize(100, ageGroup, 'spacing') 
          }
        ]}>
          <Text style={[
            styles.surpriseText,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            {currentSurprise.emoji} {currentSurprise.message}
          </Text>
        </View>
      )}

      {/* Parent Gate Modal */}
      <Modal
        visible={showParentGate}
        transparent={true}
        animationType="fade"
      >
        <View style={styles.modalContainer}>
          <View style={[styles.modalContent, { padding: getScaledSize(30, ageGroup, 'spacing') }]}>
            <Text style={[styles.modalTitle, { fontSize: getScaledSize(20, ageGroup, 'fontSize') }]}>Parent Access</Text>
            
            {/* Long Press Instruction */}
            {!longPressReady && (
              <TouchableOpacity
                onLongPress={() => {
                  setLongPressReady(true);
                  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                }}
                delayLongPress={1500}
                style={{
                  backgroundColor: '#E8F4FF',
                  padding: 15,
                  borderRadius: 10,
                  marginBottom: 15
                }}
              >
                <Text style={{ textAlign: 'center', color: '#4A90E2' }}>
                  Hold this box for 2 seconds to continue
                </Text>
              </TouchableOpacity>
            )}
            
            {/* Question and Input */}
            {longPressReady && (
              <>
                <Text style={{ marginBottom: 10 }}>{parentGateQA.question}</Text>
                <TextInput
                  keyboardType="number-pad"
                  value={parentAnswerInput}
                  onChangeText={setParentAnswerInput}
                  style={{
                    borderWidth: 1,
                    borderColor: '#ccc',
                    borderRadius: 8,
                    padding: 10,
                    width: '80%',
                    alignSelf: 'center',
                    textAlign: 'center'
                  }}
                />
                <View style={{ flexDirection: 'row', marginTop: 15, justifyContent: 'center' }}>
                  <TouchableOpacity
                    style={[styles.optionButton, { paddingHorizontal: 20, paddingVertical: 10, marginRight: 10 }]}
                    onPress={() => {
                      setShowParentGate(false);
                      setWrongAttempts(0);
                    }}
                  >
                    <Text>Cancel</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.optionButton, { paddingHorizontal: 20, paddingVertical: 10 }]}
                    onPress={async () => {
                      // If expecting PIN, compare hashed values
                      if (parentGateQA.question === 'Enter 4-digit PIN') {
                        try {
                          const Crypto = await import('expo-crypto');
                          const entered = parentAnswerInput.trim();
                          if (!/^\d{4}$/.test(entered)) {
                            Alert.alert('Try again', 'PIN must be 4 digits.');
                            return;
                          }
                          const hash = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, entered);
                          if (hash === parentGateQA.answer) {
                            setShowParentGate(false);
                            setWrongAttempts(0);
                            navigation.navigate('ParentSettings', { sessionLog });
                          } else {
                            const attempts = wrongAttempts + 1;
                            setWrongAttempts(attempts);
                            if (attempts >= 3) {
                              setGateLockedUntil(Date.now() + 30000);
                              setShowParentGate(false);
                              setWrongAttempts(0);
                              Alert.alert('Gate Locked', 'Too many wrong attempts. Please wait 30 seconds.');
                            } else {
                              Alert.alert('Try again', `Incorrect PIN. ${3 - attempts} attempts remaining.`);
                              setParentAnswerInput('');
                            }
                          }
                        } catch {
                          Alert.alert('Error', 'Unexpected error.');
                        }
                        return;
                      }

                      if (parentAnswerInput.trim() === parentGateQA.answer) {
                        setShowParentGate(false);
                        setWrongAttempts(0);
                        navigation.navigate('ParentSettings', { sessionLog });
                      } else {
                        const attempts = wrongAttempts + 1;
                        setWrongAttempts(attempts);
                        
                        if (attempts >= 3) {
                          // Lock gate for 30 seconds after 3 wrong attempts
                          setGateLockedUntil(Date.now() + 30000);
                          setShowParentGate(false);
                          setWrongAttempts(0);
                          Alert.alert('Gate Locked', 'Too many wrong attempts. Please wait 30 seconds.');
                        } else {
                          Alert.alert('Try again', `Incorrect answer. ${3 - attempts} attempts remaining.`);
                          setParentAnswerInput('');
                        }
                      }
                    }}
                  >
                    <Text>Submit</Text>
                  </TouchableOpacity>
                </View>
              </>
            )}
          </View>
        </View>
      </Modal>
      </ScreenBackground>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 20,
  },
  settingsButton: {
    padding: 10,
  },
  settingsIcon: {},
  streakContainer: {
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 20,
  },
  streakText: {
    fontWeight: 'bold',
    color: '#856404',
  },
  buddyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  buttonContainer: {},
  statsContainer: {
    alignItems: 'center',
    paddingVertical: 20,
  },
  statsText: {
    color: '#7F8C8D',
  },
  camera: {
    flex: 1,
  },
  cameraContainer: {
    flex: 1,
    backgroundColor: 'transparent',
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingBottom: 50,
  },
  cameraText: {
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 30,
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: -1, height: 1 },
    textShadowRadius: 10,
  },
  captureButton: {
    backgroundColor: 'white',
    justifyContent: 'center',
    alignItems: 'center',
  },
  captureButtonText: {},
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 20,
    width: '90%',
    maxWidth: 400,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 10,
    elevation: 10,
  },
  modalTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 30,
    textAlign: 'center',
  },
  optionsContainer: {
    width: '100%',
  },
  optionButton: {
    backgroundColor: '#F0F8FF',
    borderRadius: 15,
    marginBottom: 12,
    borderWidth: 2,
  },
  optionText: {
    fontWeight: '600',
    color: '#2C3E50',
    textAlign: 'center',
  },
  surpriseBanner: {
    position: 'absolute',
    left: 20,
    right: 20,
    backgroundColor: '#FFD700',
    borderRadius: 20,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 10,
    elevation: 10,
  },
  surpriseText: {
    fontWeight: 'bold',
    color: '#2C3E50',
  },
});
```

---

## study-buddy/src/screens/CalmModeScreen.tsx
```tsx
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Alert,
  Animated
} from 'react-native';
import * as Speech from 'expo-speech';
import * as Haptics from 'expo-haptics';
import { getStorageItem, setStorageItem } from '@utils/core/storage';
import BuddyCharacter from '@components/BuddyCharacter';
import BigButton from '@components/BigButton';
import { 
  getAgeConfig, 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import ScreenBackground from '@components/ScreenBackground';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { speakWithBuddy } from '@utils/voice/speakWithBuddy';
import { success as hapticSuccess } from '@utils/feedback';
import { uiAlert } from '@ui/alerts';
import { t } from '@utils/intl/i18n';

const { width, height } = Dimensions.get('window');

type Props = StackScreenProps<RootStackParamList, 'CalmMode'>;

export default function CalmModeScreen({ navigation }: Props) {
  const [buddy, setBuddy] = useState(null);
  const [ageGroup, setAgeGroup] = useState('elementary');
  const [isCalming, setIsCalming] = useState(false);
  const [sessionTime, setSessionTime] = useState(0);
  const [breathCount, setBreathCount] = useState(0);
  const [calmStreak, setCalmStreak] = useState(0);
  
  const breathingAnim = useRef(new Animated.Value(1)).current;
  const [isInhale, setIsInhale] = useState(true);
  const timerInterval = useRef(null);
  const breathingInterval = useRef(null);

  useEffect(() => {
    loadUserData();
    loadCalmData();
    
    return () => {
      if (timerInterval.current) clearInterval(timerInterval.current);
      if (breathingInterval.current) clearInterval(breathingInterval.current);
    };
  }, []);

  const loadUserData = async () => {
    const buddyData = await getStorageItem('selectedBuddy');
    const age = await getStorageItem('selectedAge');
    if (buddyData) setBuddy(JSON.parse(buddyData));
    if (age) setAgeGroup(age);
  };

  const loadCalmData = async () => {
    const streak = await getStorageItem('calmStreak');
    if (streak) setCalmStreak(parseInt(streak));
  };

  const startCalming = () => {
    setIsCalming(true);
    setSessionTime(0);
    setBreathCount(0);
    
    const config = getAgeConfig(ageGroup);
    
    // Start timer - minimum 5 minutes
    timerInterval.current = setInterval(() => {
      setSessionTime(prev => {
        if (prev >= 300) { // 5 minutes minimum
          offerToFinish();
        }
        return prev + 1;
      });
    }, 1000);
    
    // Start breathing exercise with configured timing
    startBreathingExercise();
    
    // Initial calming message based on age
    const calmMessage = getCalmingMessage(config);
    speakWithBuddy({ buddy, ageGroup, text: calmMessage, options: { screenType: 'calm' } });
    hapticSuccess();
  };

  const getCalmingMessage = (config) => {
    const messages = {
      young: "Let's take some big breaths together. You're safe.",
      elementary: "Time to calm down. Breathe with me.",
      tween: "Let's reset. Deep breaths.",
      teen: "Breathing exercise. Follow the circle."
    };
    return messages[ageGroup] || messages.elementary;
  };

  const startBreathingExercise = () => {
    breathingInterval.current = setInterval(() => {
      // Breathe in and out cycle using configured timing
      Animated.sequence([
        Animated.timing(breathingAnim, {
          toValue: 1.5,
          duration: TIMING_CONFIG.animations.breathingIn,
          useNativeDriver: true,
        }),
        Animated.timing(breathingAnim, {
          toValue: 1,
          duration: TIMING_CONFIG.animations.breathingOut,
          useNativeDriver: true,
        }),
      ]).start(() => {
        setIsInhale(prev => !prev);
      });
      
      setBreathCount(prev => prev + 1);
      
      // Voice guidance every 3 breaths
      if ((breathCount + 1) % 3 === 0) {
        const prompts = getBreathingPrompts(ageGroup);
        const config = getAgeConfig(ageGroup);
        speakWithBuddy({ buddy, ageGroup, text: prompts[(breathCount + 1) % prompts.length], options: { screenType: 'calm' } });
      }
    }, TIMING_CONFIG.session.breathingCycle);
  };

  const getBreathingPrompts = (ageGroup) => {
    const prompts = {
      young: ["Big breath in... and out...", "You're doing great", "Nice and slow", "Feel better"],
      elementary: ["In... and out...", "You're doing great", "Nice and slow", "Feel calmer"],
      tween: ["Breathe in... breathe out...", "Good", "Stay calm", "Reset"],
      teen: ["In... out...", "Focus", "Steady", "Center"]
    };
    return prompts[ageGroup] || prompts.elementary;
  };

  const offerToFinish = () => {
    uiAlert(
      "Feeling Better?",
      "You've been calming for 5 minutes. Ready to stop?",
      [
        { text: "Keep Going", style: "cancel" },
        { text: "I'm Ready", onPress: finishCalming }
      ]
    );
  };

  const finishCalming = () => {
    setIsCalming(false);
    clearInterval(timerInterval.current);
    clearInterval(breathingInterval.current);
    
    saveCalmData();
    
    const finishMessage = getFinishMessage(ageGroup);
    uiAlert(
      "Great Job! 🌟",
      finishMessage,
      [
        { text: "Not Yet", onPress: () => navigation.navigate('ModeSelection') },
        { 
          text: "Tell Parent", 
          onPress: () => {
            uiAlert("Message Sent!", "Someone will check on you soon.");
            navigation.navigate('ModeSelection');
          }
        }
      ]
    );
  };

  const getFinishMessage = (ageGroup) => {
    const messages = {
      young: "You did amazing at calming down! Want to tell someone you're ready?",
      elementary: "You did great at calming down. Want to tell someone you're ready?",
      tween: "Good work calming down. Want to let someone know you're ready?",
      teen: "Well done. Ready to tell someone you're good?"
    };
    return messages[ageGroup] || messages.elementary;
  };

  const saveCalmData = async () => {
    const newStreak = calmStreak + 1;
    const calmLog = {
      duration: sessionTime,
      breathCount: breathCount,
      timestamp: new Date().toISOString()
    };
    
    await Promise.all([
      setStorageItem('calmStreak', newStreak.toString()),
      setStorageItem('lastCalmSession', new Date().toISOString()),
      setStorageItem('lastCalmLog', JSON.stringify(calmLog))
    ]);
  };

  const config = getAgeConfig(ageGroup);

  return (
    <SafeAreaView style={[styles.safeArea]}>
      <ScreenBackground ageGroup={ageGroup}>
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()} style={styles.backButton}>
            <Text style={[
              styles.backText,
              { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
            ]}>
              ←
            </Text>
          </TouchableOpacity>
          <View style={[
            styles.streakContainer,
            { backgroundColor: config.accentColor + '20' }
          ]}>
            <Text style={[
              styles.streakText,
              { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
            ]}>
              🧘 {calmStreak} calm sessions
            </Text>
          </View>
        </View>

        {/* Breathing Circle */}
        {isCalming && (
          <Animated.View 
            style={[
              styles.breathingCircle,
              {
                width: getScaledSize(200, ageGroup, 'buddySize'),
                height: getScaledSize(200, ageGroup, 'buddySize'),
                borderRadius: getScaledSize(100, ageGroup, 'buddySize'),
                transform: [{ scale: breathingAnim }]
              }
            ]}
          >
            <Text style={[
              styles.breathText,
              { fontSize: getScaledSize(20, ageGroup, 'fontSize') }
            ]}>
              {isInhale ? 'Breathe In' : 'Breathe Out'}
            </Text>
          </Animated.View>
        )}

        {/* Buddy (smaller and calmer) */}
        {!isCalming && buddy && (
          <View style={styles.buddyContainer}>
            <BuddyCharacter 
              buddy={buddy} 
              isStudying={false}
              isFaded={false}
              ageGroup={ageGroup}
              style={{ transform: [{ scale: 0.7 }] }}
            />
          </View>
        )}

        {/* Timer */}
        {isCalming && (
          <View style={styles.timerContainer}>
            <Text accessibilityRole="header" style=[
              styles.timerText,
              { fontSize: getScaledSize(36, ageGroup, 'fontSize') }
            ]}>
              {Math.floor(sessionTime / 60)}:{(sessionTime % 60).toString().padStart(2, '0')}
            </Text>
            <Text style={[
              styles.breathCountText,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              {breathCount} breaths
            </Text>
          </View>
        )}

        {/* Action Buttons */}
        <View style={[
          styles.buttonContainer,
          { paddingVertical: getScaledSize(30, ageGroup, 'spacing') }
        ]}>
          {!isCalming ? (
            <BigButton 
              title="Start Calming 🌊"
              onPress={startCalming}
              color="#2196F3"
              ageGroup={ageGroup}
            />
          ) : (
            <BigButton 
              title="I'm Ready to Talk"
              onPress={finishCalming}
              color="#4CAF50"
              ageGroup={ageGroup}
            />
          )}
        </View>

        {/* Calm Tips */}
        {!isCalming && (
          <View style={styles.tipsContainer}>
            <Text style={[
              styles.tipText,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              {getCalmTip(ageGroup)}
            </Text>
          </View>
        )}
      </View>
      </ScreenBackground>
    </SafeAreaView>
  );
}

// Helper function for age-appropriate calm tips
function getCalmTip(ageGroup) {
  const tips = {
    young: '💙 It\'s okay to feel big feelings',
    elementary: '💙 Everyone needs to calm down sometimes',
    tween: '💙 Take a moment to reset',
    teen: '💙 Mindfulness helps focus'
  };
  return tips[ageGroup] || tips.elementary;
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 20,
  },
  backButton: {
    padding: 10,
  },
  backText: {
    color: '#2196F3',
  },
  streakContainer: {
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 20,
  },
  streakText: {
    fontWeight: 'bold',
    color: '#1565C0',
  },
  breathingCircle: {
    backgroundColor: '#64B5F6',
    justifyContent: 'center',
    alignItems: 'center',
    alignSelf: 'center',
    marginVertical: 50,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 10,
    elevation: 8,
  },
  breathText: {
    fontWeight: 'bold',
    color: 'white',
  },
  buddyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  timerContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  timerText: {
    fontWeight: 'bold',
    color: '#1565C0',
  },
  breathCountText: {
    color: '#7F8C8D',
    marginTop: 5,
  },
  buttonContainer: {},
  tipsContainer: {
    position: 'absolute',
    bottom: 50,
    left: 20,
    right: 20,
    alignItems: 'center',
  },
  tipText: {
    color: '#5E92B8',
    textAlign: 'center',
    fontStyle: 'italic',
  },
});
```

---

## study-buddy/src/screens/ParentSettingsScreen.tsx
```tsx
import React, { useState, useEffect, useContext } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
  Switch,
  Alert,
  TextInput
} from 'react-native';
import Slider from '@react-native-community/slider';
import { Audio } from 'expo-av';
import { getStorageItem, setStorageItem } from '@utils/core/storage';
import { 
  getAgeConfig, 
  getScaledSize,
  UI_SCALING_CONFIG
} from '@utils/config/constants';
import { t, getCurrentLanguage, setLanguage, getAvailableLanguages } from '@utils/intl/i18n';
import { SubscriptionContext } from '../../App';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getStringKey, setStringKey, removeKey } from '@utils/core/storageKeys';
import * as Crypto from 'expo-crypto';
import { computeWeeklyInsights } from '@utils/insights';
import { getBalance, getRewardsCatalog, redeemTokens, logRedemption } from '@utils/rewards';

type Props = StackScreenProps<RootStackParamList, 'ParentSettings'>;

export default function ParentSettingsScreen({ navigation, route }: Props) {
  const [ageGroup, setAgeGroup] = useState('elementary');
  const [workDuration, setWorkDuration] = useState(25);
  const [breakDuration, setBreakDuration] = useState(5);
  const [checkInFrequency, setCheckInFrequency] = useState(5);
  const [interactionFrequency, setInteractionFrequency] = useState(20);
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [vibrationEnabled, setVibrationEnabled] = useState(true);
  const [twoWayInteraction, setTwoWayInteraction] = useState(true);
  const [encouragementMessages, setEncouragementMessages] = useState([]);
  const [recording, setRecording] = useState(null);
  const [lastSessionLog, setLastSessionLog] = useState([]);
  const [appLanguage, setAppLanguage] = useState(getCurrentLanguage());
  const [speechSettings, setSpeechSettings] = useState({
    mainScreenEnabled: true,
    calmModeEnabled: true,
    celebrationEnabled: true,
    rate: 1.0,
    pitch: 1.0,
  });
  const [photoSettings, setPhotoSettings] = useState({
    autoDeleteDays: 7,
    privacyOverlay: false,
  });
  const [parentPin, setParentPin] = useState('');
  const [parentPinConfirm, setParentPinConfirm] = useState('');
  const [pinSet, setPinSet] = useState(false);
  const [insights, setInsights] = useState<{ totalMinutes: number; avgSessionMinutes: number; sessions: number; topHelps: Array<{ id: string; count: number }> } | null>(null);
  const [tokenBalance, setTokenBalance] = useState(0);
  const { isPremium } = useContext(SubscriptionContext);

  useEffect(() => {
    loadUserAge();
    loadSettings();
    loadSessionLog();
    loadInsightsAndRewards();
  }, []);
  const loadInsightsAndRewards = async () => {
    try {
      const data = await computeWeeklyInsights();
      setInsights(data);
    } catch {}
    try {
      const bal = await getBalance();
      setTokenBalance(bal);
    } catch {}
  };

  const loadUserAge = async () => {
    const age = await getStorageItem('selectedAge');
    if (age) setAgeGroup(age);
  };

  const loadSettings = async () => {
    // Load settings with age-appropriate defaults
    const config = getAgeConfig(ageGroup);
    
    const settingsMap = [
      ['workDuration', setWorkDuration, config.session?.defaultDuration || 25],
      ['breakDuration', setBreakDuration, config.session?.breakDuration / 60 || 5],
      ['checkInFrequency', setCheckInFrequency, config.checkInFrequency || 5],
      ['interactionFrequency', setInteractionFrequency, config.interactionFrequency || 20],
      ['soundEnabled', setSoundEnabled, true, 'boolean'],
      ['vibrationEnabled', setVibrationEnabled, true, 'boolean'],
      ['twoWayInteraction', setTwoWayInteraction, true, 'boolean']
    ];

    for (const [key, setter, defaultValue, type = 'number'] of settingsMap) {
      const value = await getStorageItem(key);
      if (value !== null) {
        if (type === 'boolean') {
          setter(value === 'true');
        } else {
          setter(parseInt(value));
        }
      } else {
        setter(defaultValue);
      }
    }
    
    // Load speech settings
    const speech = await getStorageItem('speechSettings');
    if (speech) {
      setSpeechSettings(JSON.parse(speech));
    }
    
    // Load photo settings
    const photo = await getStorageItem('photoSettings');
    if (photo) {
      setPhotoSettings(JSON.parse(photo));
    }

    // Load parent PIN
    const existingPin = await getStringKey('parentPin' as any);
    if (existingPin) setPinSet(true);
  };

  const loadSessionLog = async () => {
    const log = await getStorageItem('lastSessionLog');
    if (log) {
      setLastSessionLog(JSON.parse(log));
    }
    if (route.params?.sessionLog) {
      setLastSessionLog(route.params.sessionLog);
    }
  };

  const saveSettings = async () => {
    const settings = {
      workDuration: workDuration.toString(),
      breakDuration: breakDuration.toString(),
      checkInFrequency: checkInFrequency.toString(),
      interactionFrequency: interactionFrequency.toString(),
      soundEnabled: soundEnabled.toString(),
      vibrationEnabled: vibrationEnabled.toString(),
      twoWayInteraction: twoWayInteraction.toString()
    };
    
    const savePromises = Object.entries(settings).map(([key, value]) => 
      setStorageItem(key, value)
    );
    
    // Save speech settings separately as JSON
    savePromises.push(setStorageItem('speechSettings', JSON.stringify(speechSettings)));
    
    // Save photo settings
    savePromises.push(setStorageItem('photoSettings', JSON.stringify(photoSettings)));
    
    await Promise.all(savePromises);

    // Save parent PIN if provided and matches confirmation (4 digits)
    if (parentPin || parentPinConfirm) {
      if (parentPin === parentPinConfirm && /^\d{4}$/.test(parentPin)) {
        const hash = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, parentPin);
        await setStringKey('parentPin' as any, hash);
        await setStringKey('parentPinSetAt' as any, Date.now().toString());
        setPinSet(true);
      } else {
        Alert.alert('PIN mismatch', 'Please enter matching 4-digit PINs.');
        return;
      }
    }
    
    Alert.alert('Success!', 'Settings saved successfully!', [
      { text: 'OK', onPress: () => navigation.goBack() }
    ]);
  };

  const startRecordingMessage = async () => {
    try {
      await Audio.requestPermissionsAsync();
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: true,
        playsInSilentModeIOS: true,
      });

      const { recording } = await Audio.Recording.createAsync(
        Audio.RecordingOptionsPresets.HIGH_QUALITY
      );
      setRecording(recording);
      
      Alert.alert('Recording', 'Say your encouraging message now!');
    } catch (err) {
      Alert.alert('Error', 'Failed to start recording');
    }
  };

  const stopRecordingMessage = async () => {
    if (!recording) return;
    
    setRecording(null);
    await recording.stopAndUnloadAsync();
    const uri = recording.getURI();
    
    const messages = [...encouragementMessages, uri];
    setEncouragementMessages(messages);
    await setStorageItem('encouragementMessages', JSON.stringify(messages));
    
    Alert.alert('Success!', 'Your message has been saved!');
  };

  const resetProgress = () => {
    Alert.alert(
      'Reset Progress',
      'This will reset all progress and streaks. Are you sure?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Reset',
          style: 'destructive',
          onPress: async () => {
            await Promise.all([
              setStorageItem('currentStreak', '0'),
              setStorageItem('totalFocusTime', '0'),
              setStorageItem('calmStreak', '0')
            ]);
            Alert.alert('Reset Complete', 'All progress has been reset.');
          }
        }
      ]
    );
  };

  const formatSessionLog = () => {
    if (!lastSessionLog || lastSessionLog.length === 0) {
      return 'No interaction data from last session';
    }

    const responses = {
      math: '📊 Math', reading: '📚 Reading', writing: '✏️ Writing', other: '📝 Other',
      easy: '😊 Easy', ok: '😐 OK', hard: '😟 Hard', help: '🆘 Need help',
      complete: '✅ Complete', most: '🔵 Most done', half: '🟡 Half done', started: '🔴 Just started'
    };

    return lastSessionLog.map((entry, index) => {
      const time = Math.floor(entry.time / 60);
      return `${time} min: ${responses[entry.response] || entry.response}`;
    }).join('\n');
  };

  const config = getAgeConfig(ageGroup);
  
  // Get age-appropriate slider ranges
  const getSliderConfig = (setting) => {
    const ranges = {
      workDuration: {
        young: { min: 5, max: 20, step: 5 },
        elementary: { min: 10, max: 30, step: 5 },
        tween: { min: 15, max: 45, step: 5 },
        teen: { min: 20, max: 60, step: 5 }
      },
      breakDuration: { min: 3, max: 15, step: 1 },
      checkInFrequency: { min: 2, max: 15, step: 1 },
      interactionFrequency: { min: 10, max: 45, step: 5 }
    };
    
    return ranges[setting][ageGroup] || ranges[setting] || { min: 1, max: 10, step: 1 };
  };

  return (
    <SafeAreaView style={[styles.safeArea]}>
      <ScreenBackground ageGroup={ageGroup}>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()} accessibilityRole="button" accessibilityLabel="Back">
            <Text style={[
              styles.backButton,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              ← Back
            </Text>
          </TouchableOpacity>
          <Text style={[
            styles.title,
            { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
          ]}>
            Parent Settings
          </Text>
        </View>

        {/* Session Report */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Last Session Report
          </Text>
          <Text style={[
            styles.sessionLog,
            { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
          ]}>
            {formatSessionLog()}
          </Text>
        </View>

        {/* Timer Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Timer Settings
          </Text>
          
          {[
            { key: 'workDuration', label: 'Work Duration', value: workDuration, setter: setWorkDuration, unit: 'minutes' },
            { key: 'breakDuration', label: 'Break Duration', value: breakDuration, setter: setBreakDuration, unit: 'minutes' },
            { key: 'checkInFrequency', label: 'Voice Check-in Every', value: checkInFrequency, setter: setCheckInFrequency, unit: 'minutes' }
          ].map(({ key, label, value, setter, unit }) => {
            const sliderConfig = getSliderConfig(key);
            return (
              <View key={key} style={styles.setting}>
                <Text style={[
                  styles.settingLabel,
                  { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
                ]}>
                  {label}: {value} {unit}
                </Text>
                <Slider
                  style={[
                    styles.slider,
                    { height: getScaledSize(40, ageGroup, 'spacing') }
                  ]}
                  minimumValue={sliderConfig.min}
                  maximumValue={sliderConfig.max}
                  step={sliderConfig.step}
                  value={value}
                  onValueChange={setter}
                  minimumTrackTintColor={config.accentColor}
                  maximumTrackTintColor="#D0D0D0"
                />
              </View>
            );
          })}
        </View>

        {/* Weekly Insights */}
        <View style={[styles.section, { padding: getScaledSize(20, ageGroup, 'spacing') }]}>
          <Text style={[styles.sectionTitle, { fontSize: getScaledSize(18, ageGroup, 'fontSize') }]}>This Week</Text>
          <Text style={{ color: '#2C3E50' }}>{insights ? `${insights.sessions} sessions • ${insights.totalMinutes} min total • avg ${insights.avgSessionMinutes} min` : 'No data yet'}</Text>
          {insights && insights.topHelps?.length ? (
            <View style={{ marginTop: 8 }}>
              {insights.topHelps.map(h => (
                <Text key={h.id} style={{ color: '#7F8C8D' }}>• {h.id} ×{h.count}</Text>
              ))}
            </View>
          ) : null}
        </View>

        {/* Interaction Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Check-In Settings
          </Text>
          
          <View style={styles.switchSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Two-Way Interaction
            </Text>
            <Switch
              value={twoWayInteraction}
              onValueChange={setTwoWayInteraction}
              trackColor={{ false: '#D0D0D0', true: config.accentColor }}
            />
          </View>

          {twoWayInteraction && (
            <View style={styles.setting}>
              <Text style={[
                styles.settingLabel,
                { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
              ]}>
                Ask Questions Every: {interactionFrequency} minutes
              </Text>
              <Slider
                style={[
                  styles.slider,
                  { height: getScaledSize(40, ageGroup, 'spacing') }
                ]}
                minimumValue={getSliderConfig('interactionFrequency').min}
                maximumValue={getSliderConfig('interactionFrequency').max}
                step={getSliderConfig('interactionFrequency').step}
                value={interactionFrequency}
                onValueChange={setInteractionFrequency}
                minimumTrackTintColor={config.accentColor}
                maximumTrackTintColor="#D0D0D0"
              />
            </View>
          )}
        </View>

        {/* Notification Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Notifications
          </Text>
          
          {[
            { key: 'soundEnabled', label: 'Sound Effects', value: soundEnabled, setter: setSoundEnabled },
            { key: 'vibrationEnabled', label: 'Vibration', value: vibrationEnabled, setter: setVibrationEnabled }
          ].map(({ key, label, value, setter }) => (
            <View key={key} style={styles.switchSetting}>
              <Text style={[
                styles.settingLabel,
                { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
              ]}>
                {label}
              </Text>
              <Switch
                value={value}
                onValueChange={setter}
                trackColor={{ false: '#D0D0D0', true: config.accentColor }}
              />
            </View>
          ))}
        </View>

        {/* Language Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Language / Idioma / Sprache
          </Text>
          
          <View style={{ flexDirection: 'row', justifyContent: 'space-around', marginTop: 10 }}>
            {getAvailableLanguages().map((lang) => (
              <TouchableOpacity
                key={lang.code}
                style={[
                  styles.languageButton,
                  appLanguage === lang.code && styles.languageButtonActive,
                  { padding: getScaledSize(15, ageGroup, 'spacing') }
                ]}
                onPress={async () => {
                  await setLanguage(lang.code);
                  setAppLanguage(lang.code);
                  Alert.alert('✓', t('saveSettings'));
                }}
              >
                <Text style={styles.languageFlag}>{lang.flag}</Text>
                <Text style={[
                  styles.languageName,
                  appLanguage === lang.code && styles.languageNameActive
                ]}>
                  {lang.name}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        {/* Speech Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Speech Settings
          </Text>

          {/* Per-Mode Speech Toggles */}
          {[
            { key: 'mainScreenEnabled', label: 'Speech during studying' },
            { key: 'calmModeEnabled', label: 'Speech in calm mode' },
            { key: 'celebrationEnabled', label: 'Speech for celebrations' }
          ].map(({ key, label }) => (
            <View key={key} style={styles.switchSetting}>
              <Text style={[
                styles.settingLabel,
                { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
              ]}>
                {label}
              </Text>
              <Switch
                value={speechSettings[key]}
                onValueChange={(value) => setSpeechSettings({...speechSettings, [key]: value})}
                trackColor={{ false: '#D0D0D0', true: config.accentColor }}
              />
            </View>
          ))}

          {/* Speech Rate */}
          <View style={styles.sliderSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Speech Speed: {speechSettings.rate.toFixed(1)}x
            </Text>
            <Slider
              style={{ height: 40, marginTop: 10 }}
              minimumValue={0.5}
              maximumValue={2.0}
              step={0.1}
              value={speechSettings.rate}
              onValueChange={(value) => setSpeechSettings({...speechSettings, rate: value})}
              minimumTrackTintColor={config.primaryColor}
              maximumTrackTintColor="#D0D0D0"
            />
          </View>

          {/* Speech Pitch */}
          <View style={styles.sliderSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Voice Pitch: {speechSettings.pitch.toFixed(1)}
            </Text>
            <Slider
              style={{ height: 40, marginTop: 10 }}
              minimumValue={0.5}
              maximumValue={2.0}
              step={0.1}
              value={speechSettings.pitch}
              onValueChange={(value) => setSpeechSettings({...speechSettings, pitch: value})}
              minimumTrackTintColor={config.primaryColor}
              maximumTrackTintColor="#D0D0D0"
            />
          </View>
        </View>

        {/* Parent PIN */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Parent PIN (optional)
          </Text>
          <Text style={{ color: '#7F8C8D', marginBottom: 10 }}>{pinSet ? 'A PIN is currently set.' : 'Set a 4-digit PIN for parent access.'} Biometrics will be used when available.</Text>
          <View style={{ width: '100%', marginBottom: 10 }}>
            <TextInput
              value={parentPin}
              onChangeText={(v) => setParentPin(v.replace(/[^0-9]/g, '').slice(0, 4))}
              placeholder={pinSet ? 'Enter new PIN (optional)' : 'Enter 4-digit PIN'}
              keyboardType="number-pad"
              secureTextEntry
              style={{ borderWidth: 1, borderColor: '#ccc', borderRadius: 8, padding: 12 }}
              maxLength={4}
            />
          </View>
          <View style={{ width: '100%' }}>
            <TextInput
              value={parentPinConfirm}
              onChangeText={(v) => setParentPinConfirm(v.replace(/[^0-9]/g, '').slice(0, 4))}
              placeholder={pinSet ? 'Confirm new PIN' : 'Confirm 4-digit PIN'}
              keyboardType="number-pad"
              secureTextEntry
              style={{ borderWidth: 1, borderColor: '#ccc', borderRadius: 8, padding: 12 }}
              maxLength={4}
            />
          </View>
          {pinSet && (
            <TouchableOpacity
              style={{ marginTop: 10, alignSelf: 'flex-start' }}
              onPress={async () => { await removeKey('parentPin' as any); await removeKey('parentPinSetAt' as any); setPinSet(false); setParentPin(''); setParentPinConfirm(''); }}
            >
              <Text style={{ color: '#E74C3C' }}>Clear existing PIN</Text>
            </TouchableOpacity>
          )}
        </View>

        {/* Photo Privacy Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Photo Privacy
          </Text>

          {/* Auto-Delete Setting */}
          <View style={styles.sliderSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Auto-delete photos after: {photoSettings.autoDeleteDays} days
            </Text>
            <Slider
              style={{ height: 40, marginTop: 10 }}
              minimumValue={1}
              maximumValue={30}
              step={1}
              value={photoSettings.autoDeleteDays}
              onValueChange={(value) => setPhotoSettings({...photoSettings, autoDeleteDays: value})}
              minimumTrackTintColor={config.primaryColor}
              maximumTrackTintColor="#D0D0D0"
            />
            <Text style={{ fontSize: 12, color: '#7F8C8D', marginTop: 5 }}>
              Photos are stored locally only and never synced to cloud
            </Text>
          </View>

          {/* Privacy Overlay Toggle */}
          <View style={styles.switchSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Privacy blur overlay
            </Text>
            <Switch
              value={photoSettings.privacyOverlay}
              onValueChange={(value) => setPhotoSettings({...photoSettings, privacyOverlay: value})}
              trackColor={{ false: '#D0D0D0', true: config.accentColor }}
            />
          </View>
        </View>

        {/* Custom Messages */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Custom Encouragement
          </Text>
          
          <TouchableOpacity
            style={[
              styles.recordButton,
              recording && styles.recordingActive,
              { 
                padding: getScaledSize(15, ageGroup, 'spacing'),
                backgroundColor: recording ? '#C0392B' : '#E74C3C'
              }
            ]}
            testID="record-encouragement"
            onPress={recording ? stopRecordingMessage : startRecordingMessage}
          >
            <Text style={[
              styles.recordButtonText,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              {recording ? '⏹️ Stop Recording' : '🎤 Record Message'}
            </Text>
          </TouchableOpacity>
          
          <Text style={[
            styles.hint,
            { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
          ]}>
            Record encouraging messages in your voice for check-ins!
          </Text>
        </View>

        {/* Rewards */}
        <View style={[styles.section, { padding: getScaledSize(20, ageGroup, 'spacing') }]}>
          <Text style={[styles.sectionTitle, { fontSize: getScaledSize(18, ageGroup, 'fontSize') }]}>Rewards</Text>
          <Text style={{ color: '#2C3E50', marginBottom: 8 }}>Balance: {tokenBalance} tokens</Text>
          {getRewardsCatalog().map(r => (
            <TouchableOpacity key={r.id} style={{ backgroundColor: '#F0F8FF', borderRadius: 10, padding: 12, marginBottom: 8 }}
              onPress={async () => {
                const ok = await redeemTokens(r.cost);
                if (ok) {
                  await logRedemption(r);
                  const bal = await getBalance();
                  setTokenBalance(bal);
                  Alert.alert('Redeemed', `${r.name}`);
                } else {
                  Alert.alert('Not enough tokens', `Need ${r.cost} tokens`);
                }
              }}>
              <Text style={{ color: '#2C3E50' }}>{r.name} — {r.cost} tokens</Text>
            </TouchableOpacity>
          ))}
        </View>

        {/* Actions */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          {!isPremium && (
            <TouchableOpacity 
              style={[
                styles.upgradeButton,
                { 
                  backgroundColor: '#FFD700',
                  padding: getScaledSize(15, ageGroup, 'spacing'),
                  marginBottom: 10,
                  borderRadius: 10,
                  alignItems: 'center'
                }
              ]} 
              onPress={() => navigation.navigate('Paywall', { ageGroup })}
            >
              <Text style={[
                styles.upgradeButtonText,
                { fontSize: getScaledSize(18, ageGroup, 'fontSize'), fontWeight: 'bold' }
              ]}>
                🌟 Upgrade to Premium
              </Text>
            </TouchableOpacity>
          )}
          
          <TouchableOpacity 
            style={[
              styles.saveButton,
              { 
                padding: getScaledSize(15, ageGroup, 'spacing'),
                backgroundColor: config.primaryColor 
              }
            ]} 
            onPress={saveSettings}
          >
            <Text style={[
              styles.saveButtonText,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              Save Settings
            </Text>
          </TouchableOpacity>

          <TouchableOpacity 
            style={[
              styles.resetButton,
              { padding: getScaledSize(15, ageGroup, 'spacing') }
            ]} 
            onPress={resetProgress}
          >
            <Text style={[
              styles.resetButtonText,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Reset All Progress
            </Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
      </ScreenBackground>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
  },
  header: {
    paddingVertical: 20,
    alignItems: 'center',
  },
  backButton: {
    position: 'absolute',
    left: 0,
    color: '#4A90E2',
  },
  title: {
    fontWeight: 'bold',
    color: '#2C3E50',
  },
  section: {
    backgroundColor: 'white',
    borderRadius: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  sectionTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 20,
  },
  sessionLog: {
    color: '#2C3E50',
    lineHeight: 22,
    fontFamily: 'monospace',
  },
  setting: {
    marginBottom: 20,
  },
  settingLabel: {
    color: '#2C3E50',
    marginBottom: 10,
  },
  slider: {
    width: '100%',
  },
  switchSetting: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  recordButton: {
    borderRadius: 10,
    alignItems: 'center',
  },
  recordingActive: {
    backgroundColor: '#C0392B',
  },
  recordButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  hint: {
    color: '#7F8C8D',
    marginTop: 10,
    textAlign: 'center',
  },
  saveButton: {
    borderRadius: 10,
    alignItems: 'center',
    marginBottom: 15,
  },
  saveButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  resetButton: {
    backgroundColor: '#E74C3C',
    borderRadius: 10,
    alignItems: 'center',
  },
  resetButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  languageButton: {
    alignItems: 'center',
    backgroundColor: '#F0F8FF',
    borderRadius: 10,
    borderWidth: 2,
    borderColor: 'transparent',
  },
  languageButtonActive: {
    borderColor: '#4A90E2',
    backgroundColor: '#E8F4FF',
  },
  languageFlag: {
    fontSize: 32,
    marginBottom: 5,
  },
  languageName: {
    fontSize: 14,
    color: '#7F8C8D',
  },
  languageNameActive: {
    color: '#4A90E2',
    fontWeight: 'bold',
  },
  upgradeButton: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  upgradeButtonText: {
    color: '#2C3E50',
  },
});
```

---

## study-buddy/src/screens/CelebrationScreen.tsx
```tsx
import React, { useEffect, useRef, useState, useContext } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Share,
  Modal
} from 'react-native';
import LottieView from 'lottie-react-native';
import * as Speech from 'expo-speech';
import * as Haptics from 'expo-haptics';
import { setStorageItem, getStorageItem } from '@utils/core/storage';
import { 
  getAgeConfig, 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import ScreenBackground from '@components/ScreenBackground';
import { SubscriptionContext } from '../../App';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getAppConfig } from '@config/appConfig';
import { uiAlert } from '@ui/alerts';
import { speakWithBuddy } from '@utils/voice/speakWithBuddy';
import { success as hapticSuccess } from '@utils/feedback';
import { getBalance } from '@utils/rewards';
import { getAnimation } from '@assets/registry';

const { width, height } = Dimensions.get('window');

type Props = StackScreenProps<RootStackParamList, 'Celebration'>;

export default function CelebrationScreen({ navigation, route }: Props) {
  const { sessionTime, totalTime, streak, ageGroup, workPhoto, sessionLog, tokenAward } = route.params;
  const animationRef = useRef(null);
  const [showFeedback, setShowFeedback] = useState(false);
  const [whatWorked, setWhatWorked] = useState([]);
  const { isPremium } = useContext(SubscriptionContext);
  const [showAward, setShowAward] = useState(!!tokenAward && tokenAward > 0);

  useEffect(() => {
    celebrate();
    checkForPaywall();
    // Show feedback modal after configured delay
    setTimeout(() => setShowFeedback(true), TIMING_CONFIG.animations.celebrationDisplay);
    // Refresh balance for UI (optional future use)
    getBalance().catch(() => {});
  }, []);

  const checkForPaywall = async () => {
    if (!isPremium) {
      const sessionsCount = await getStorageItem('sessionsCount');
      const count = sessionsCount ? parseInt(sessionsCount) + 1 : 1;
      await setStorageItem('sessionsCount', count.toString());
      
      // Remote-configurable threshold
      const cfg = getAppConfig();
      const threshold = cfg.remote?.paywall?.sessionsTillPaywall ?? 3;
      if (count === threshold) {
        setTimeout(() => {
          navigation.navigate('Paywall', { ageGroup });
        }, 3000); // Show after celebration
      }
    }
  };

  const celebrate = () => {
    const config = getAgeConfig(ageGroup);
    const celebrationMessage = getCelebrationMessage(ageGroup, sessionTime);
    
    // Play celebration sound
    speakWithBuddy({ buddy: undefined, ageGroup, text: celebrationMessage, options: { screenType: 'celebration' } });
    
    // Haptic feedback
    hapticSuccess();
    
    // Play animation
    if (animationRef.current) {
      animationRef.current.play();
    }
  };

  const getCelebrationMessage = (ageGroup, sessionTime) => {
    const timeQuality = getTimeQuality(sessionTime);
    
    const messages = {
      young: {
        excellent: "WOW! You're AMAZING! Super duper job!",
        good: "Yay! You did it! I'm so proud!",
        okay: "Great job! You're learning so well!"
      },
      elementary: {
        excellent: "Amazing job! You did it! I'm so proud of you!",
        good: "Excellent work! You stayed focused so well!",
        okay: "Great job! You're building strong study habits!"
      },
      tween: {
        excellent: "Incredible focus! You crushed it!",
        good: "Solid work! Nice focus.",
        okay: "Good session. Keep it up."
      },
      teen: {
        excellent: "Outstanding work. Impressive focus.",
        good: "Good session. Well done.",
        okay: "Decent work. Progress made."
      }
    };
    
    return messages[ageGroup]?.[timeQuality] || messages.elementary.okay;
  };

  const getTimeQuality = (sessionTime) => {
    if (sessionTime >= 1800) return 'excellent'; // 30+ minutes
    if (sessionTime >= 900) return 'good';      // 15+ minutes
    return 'okay';                              // Under 15 minutes
  };

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const shareSuccess = async () => {
    const config = getAgeConfig(ageGroup);
    const shareMessage = getShareMessage(ageGroup, sessionTime, streak);
    
    try {
      await Share.share({ message: shareMessage });
    } catch (error) {
      console.log(error);
    }
  };

  const getShareMessage = (ageGroup, sessionTime, streak) => {
    const minutes = Math.floor(sessionTime / 60);
    const baseMessage = `🎉 My child just completed ${minutes} minutes of focused study time with Study Buddy! ${streak} day streak! 🔥`;
    
    const ageSpecificAdditions = {
      young: ' They\'re such a superstar! ⭐',
      elementary: ' So proud of their focus! 📚',
      tween: ' Building great study habits! 💪',
      teen: ' Excellent self-discipline! 🎯'
    };
    
    return baseMessage + (ageSpecificAdditions[ageGroup] || '');
  };

  const getAchievementBadge = (sessionTime, ageGroup) => {
    // Age-appropriate achievement thresholds
    const thresholds = {
      young: { gold: 600, silver: 300, bronze: 180 },      // 10, 5, 3 minutes
      elementary: { gold: 1200, silver: 600, bronze: 300 }, // 20, 10, 5 minutes  
      tween: { gold: 1500, silver: 900, bronze: 600 },     // 25, 15, 10 minutes
      teen: { gold: 1800, silver: 1200, bronze: 900 }      // 30, 20, 15 minutes
    };
    
    const t = thresholds[ageGroup] || thresholds.elementary;
    
    if (sessionTime >= t.gold) return '🏆';
    if (sessionTime >= t.silver) return '🥇';
    if (sessionTime >= t.bronze) return '🥈';
    return '🥉';
  };

  const getEncouragementMessage = (sessionTime, ageGroup) => {
    const timeQuality = getTimeQuality(sessionTime);
    
    const messages = {
      young: {
        excellent: "Incredible focus! You're a study champion!",
        good: "Amazing work! You stayed focused so well!",
        okay: "Great job! Every minute counts!"
      },
      elementary: {
        excellent: "Incredible focus! You're a study champion!",
        good: "Amazing work! You stayed focused so well!",
        okay: "Great job! You're building strong study habits!"
      },
      tween: {
        excellent: "Outstanding focus! You're on fire!",
        good: "Great work! Your focus is getting stronger!",
        okay: "Good start! Building those focus muscles!"
      },
      teen: {
        excellent: "Exceptional focus. You're developing real discipline.",
        good: "Solid session. Your concentration is improving.",
        okay: "Good work. Consistency is key."
      }
    };
    
    return messages[ageGroup]?.[timeQuality] || messages.elementary.okay;
  };

  const handleWhatWorked = async (item) => {
    const newWhatWorked = whatWorked.includes(item) 
      ? whatWorked.filter(i => i !== item)
      : [...whatWorked, item];
    
    setWhatWorked(newWhatWorked);
  };

  const saveFeedback = async () => {
    const feedbackData = {
      whatWorked: whatWorked,
      sessionTime: sessionTime,
      ageGroup: ageGroup,
      timestamp: new Date().toISOString()
    };
    
    const existingFeedback = await getStorageItem('feedbackHistory');
    const history = existingFeedback ? JSON.parse(existingFeedback) : [];
    history.push(feedbackData);
    
    // Keep only last 30 sessions for performance
    if (history.length > 30) {
      history.shift();
    }
    
    await setStorageItem('feedbackHistory', JSON.stringify(history));
    setShowFeedback(false);
    
    navigation.navigate('ModeSelection');
  };

  const config = getAgeConfig(ageGroup);

  return (
    <SafeAreaView style={[styles.safeArea]}>
      <ScreenBackground ageGroup={ageGroup}>
      <View style={styles.container}>
        {/* Celebration Animation */}
        <View style={[
          styles.animationContainer,
          { height: getScaledSize(200, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.trophy,
            { fontSize: getScaledSize(100, ageGroup, 'iconSize') }
          ]}>
            {getAchievementBadge(sessionTime, ageGroup)}
          </Text>
          <LottieView
            ref={animationRef}
            source={getAnimation('confetti')}
            autoPlay
            loop={false}
            style={styles.lottie}
          />
          {showAward && (
            <View style={{ position: 'absolute', bottom: -10, backgroundColor: '#FFD700', paddingHorizontal: 16, paddingVertical: 8, borderRadius: 20 }}>
              <Text style={{ color: '#2C3E50', fontWeight: 'bold' }}>+{tokenAward} tokens 🎟️</Text>
            </View>
          )}
        </View>

        {/* Stats */}
        <View style={styles.statsContainer}>
          <Text style={[
            styles.title,
            { 
              fontSize: getScaledSize(32, ageGroup, 'fontSize'),
              color: config.primaryColor 
            }
          ]}>
            Amazing Job! 🎉
          </Text>
          <Text style={[
            styles.message,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            {getEncouragementMessage(sessionTime, ageGroup)}
          </Text>
          
          {/* Dynamic stat boxes */}
          {[
            { label: "Today's Focus Time", value: formatTime(sessionTime) },
            { label: "Current Streak", value: `🔥 ${streak} days` },
            { label: "Total Focus Time", value: `${Math.floor(totalTime / 60)} minutes` }
          ].map((stat, index) => (
            <View key={index} style={[
              styles.statBox,
              { 
                paddingHorizontal: getScaledSize(30, ageGroup, 'spacing'),
                paddingVertical: getScaledSize(15, ageGroup, 'spacing'),
                minWidth: width * 0.7 
              }
            ]}>
              <Text style={[
                styles.statLabel,
                { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
              ]}>
                {stat.label}
              </Text>
              <Text style={[
                styles.statValue,
                { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
              ]}>
                {stat.value}
              </Text>
            </View>
          ))}
        </View>

        {/* Actions */}
        <View style={[
          styles.buttonContainer,
          { paddingHorizontal: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <TouchableOpacity 
            style={[
              styles.shareButton,
              { 
                padding: getScaledSize(15, ageGroup, 'spacing'),
                marginBottom: getScaledSize(15, ageGroup, 'spacing')
              }
            ]} 
            onPress={shareSuccess}
            accessibilityRole="button"
            accessibilityLabel={t('shareSuccess')}
          >
            <Text style={[
              styles.shareButtonText,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              {t('shareSuccess')} 📤
            </Text>
          </TouchableOpacity>

          <TouchableOpacity 
            style={[
              styles.doneButton,
              { 
                padding: getScaledSize(15, ageGroup, 'spacing'),
                backgroundColor: config.primaryColor 
              }
            ]} 
            onPress={() => setShowFeedback(true)}
            accessibilityRole="button"
            accessibilityLabel={t('continue')}
          >
            <Text style={[
              styles.doneButtonText,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              {t('continue')}
            </Text>
          </TouchableOpacity>
        </View>
      </View>

      {/* What Worked Feedback Modal */}
      <Modal
        visible={showFeedback}
        transparent={true}
        animationType="slide"
      >
        <View style={styles.modalContainer}>
          <View style={[
            styles.modalContent,
            { padding: getScaledSize(30, ageGroup, 'spacing') }
          ]}>
            <Text style={[
              styles.modalTitle,
              { fontSize: getScaledSize(20, ageGroup, 'fontSize') }
            ]}>
              What helped you today?
            </Text>
            <Text style={[
              styles.modalSubtitle,
              { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
            ]}>
              Pick all that helped!
            </Text>
            
            <View style={styles.feedbackContainer}>
              {[
                { id: 'buddy', emoji: '🤖', label: 'Buddy' },
                { id: 'timer', emoji: '⏰', label: 'Timer' },
                { id: 'checkins', emoji: '💬', label: 'Check-ins' },
                { id: 'breaks', emoji: '🌟', label: 'Breaks' }
              ].map((item) => (
                <TouchableOpacity
                  key={item.id}
                  style={[
                    styles.feedbackButton,
                    whatWorked.includes(item.id) && [
                      styles.feedbackSelected,
                      { borderColor: config.accentColor }
                    ],
                    { 
                      padding: getScaledSize(15, ageGroup, 'spacing'),
                      minWidth: getScaledSize(80, ageGroup, 'spacing')
                    }
                  ]}
                  onPress={() => handleWhatWorked(item.id)}
                >
                  <Text style={[
                    styles.feedbackEmoji,
                    { fontSize: getScaledSize(30, ageGroup, 'iconSize') }
                  ]}>
                    {item.emoji}
                  </Text>
                  <Text style={[
                    styles.feedbackText,
                    { fontSize: getScaledSize(12, ageGroup, 'fontSize') }
                  ]}>
                    {item.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>

            <Text style={[
              styles.modalTitle,
              { fontSize: getScaledSize(20, ageGroup, 'fontSize') }
            ]}>
              How do you feel?
            </Text>
            
            <View style={styles.feelingContainer}>
              {[
                { id: 'great', emoji: '😊', label: 'Great!' },
                { id: 'good', emoji: '🙂', label: 'Good' },
                { id: 'ok', emoji: '😐', label: 'OK' },
                { id: 'tired', emoji: '😴', label: 'Tired' }
              ].map((feeling) => (
                <TouchableOpacity
                  key={feeling.id}
                  style={[
                    styles.feelingButton,
                    { padding: getScaledSize(10, ageGroup, 'spacing') }
                  ]}
                  onPress={saveFeedback}
                >
                  <Text style={[
                    styles.feelingEmoji,
                    { fontSize: getScaledSize(35, ageGroup, 'iconSize') }
                  ]}>
                    {feeling.emoji}
                  </Text>
                  <Text style={[
                    styles.feelingText,
                    { fontSize: getScaledSize(12, ageGroup, 'fontSize') }
                  ]}>
                    {feeling.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>

            <TouchableOpacity
              style={[
                styles.skipButton,
                { padding: getScaledSize(10, ageGroup, 'spacing') }
              ]}
              onPress={() => {
                setShowFeedback(false);
                navigation.navigate('ModeSelection');
              }}
            >
              <Text style={[
                styles.skipText,
                { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
              ]}>
                Skip
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
      </ScreenBackground>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  animationContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  trophy: {
    position: 'absolute',
    zIndex: 1,
  },
  lottie: {
    width: width,
    height: 200,
    position: 'absolute',
  },
  statsContainer: {
    alignItems: 'center',
    marginVertical: 30,
  },
  title: {
    fontWeight: 'bold',
    marginBottom: 10,
  },
  message: {
    color: '#7F8C8D',
    textAlign: 'center',
    marginBottom: 30,
  },
  statBox: {
    backgroundColor: 'white',
    borderRadius: 15,
    marginBottom: 15,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  statLabel: {
    color: '#7F8C8D',
    marginBottom: 5,
  },
  statValue: {
    fontWeight: 'bold',
    color: '#2C3E50',
  },
  buttonContainer: {
    width: '100%',
  },
  shareButton: {
    backgroundColor: '#3498DB',
    borderRadius: 10,
    alignItems: 'center',
  },
  shareButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  doneButton: {
    borderRadius: 10,
    alignItems: 'center',
  },
  doneButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 20,
    width: '90%',
    maxWidth: 400,
    alignItems: 'center',
  },
  modalTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 10,
    marginTop: 20,
  },
  modalSubtitle: {
    color: '#7F8C8D',
    marginBottom: 20,
  },
  feedbackContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    marginBottom: 20,
  },
  feedbackButton: {
    backgroundColor: '#F0F8FF',
    borderRadius: 15,
    margin: 5,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'transparent',
  },
  feedbackSelected: {
    backgroundColor: '#E3F2FD',
  },
  feedbackEmoji: {
    marginBottom: 5,
  },
  feedbackText: {
    color: '#2C3E50',
  },
  feelingContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
    marginVertical: 20,
  },
  feelingButton: {
    alignItems: 'center',
  },
  feelingEmoji: {
    marginBottom: 5,
  },
  feelingText: {
    color: '#2C3E50',
  },
  skipButton: {
    marginTop: 10,
  },
  skipText: {
    color: '#7F8C8D',
  },
});
```

---

## study-buddy/src/components/BuddyCharacter.tsx
```tsx
import React, { useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Animated, StyleProp, ViewStyle } from 'react-native';
import LottieView from 'lottie-react-native';
import { 
  getAgeConfig, 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import type { AgeGroup, Buddy } from '@types/index';

type BuddyCharacterProps = {
  buddy: Buddy | null;
  isStudying: boolean;
  isFaded: boolean;
  ageGroup?: AgeGroup;
  style?: StyleProp<ViewStyle>;
  customSize?: number | null;
};

export default function BuddyCharacter({ 
  buddy, 
  isStudying, 
  isFaded, 
  ageGroup = 'elementary', 
  style,
  customSize = null 
}: BuddyCharacterProps): JSX.Element | null {
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(1)).current;

  const config = getAgeConfig(ageGroup);
  
  // Calculate buddy size using modular system
  const buddySize = customSize || getScaledSize(config.buddySize || 180, ageGroup, 'buddySize');

  // Fade effect to prevent staring - using configured timing
  useEffect(() => {
    const targetOpacity = isStudying && isFaded ? 0.3 : 1;
    const duration = isStudying && isFaded ? TIMING_CONFIG.animations.fadeIn * 4 : TIMING_CONFIG.animations.fadeIn;
    
    Animated.timing(fadeAnim, {
      toValue: targetOpacity,
      duration,
      useNativeDriver: true,
    }).start();
  }, [isFaded, isStudying]);

  useEffect(() => {
    if (isStudying) {
      startStudyingAnimation();
    } else {
      startIdleAnimation();
    }
    
    return () => {
      scaleAnim.stopAnimation();
      rotateAnim.stopAnimation();
    };
  }, [isStudying]);

  const startStudyingAnimation = () => {
    // Gentle breathing animation using configured timing
    Animated.loop(
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 1.05,
          duration: TIMING_CONFIG.animations.breathingIn / 2, // Faster for study mode
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: TIMING_CONFIG.animations.breathingOut / 2,
          useNativeDriver: true,
        }),
      ])
    ).start();
  };

  const startIdleAnimation = () => {
    // Gentle idle sway animation
    Animated.loop(
      Animated.sequence([
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 3000,
          useNativeDriver: true,
        }),
        Animated.timing(rotateAnim, {
          toValue: -1,
          duration: 3000,
          useNativeDriver: true,
        }),
      ])
    ).start();
  };

  const spin = rotateAnim.interpolate({
    inputRange: [-1, 1],
    outputRange: ['-10deg', '10deg'],
  });

  if (!buddy) return null;

  const studyingIndicatorText = getStudyingIndicatorText(ageGroup);
  const fadedMessageText = getFadedMessageText(ageGroup);

  return (
    <Animated.View 
      style={[
        styles.container, 
        style,
        {
          opacity: fadeAnim,
          transform: [
            { scale: scaleAnim },
            { rotate: isStudying ? '0deg' : spin }
          ]
        }
      ]}
    >
      <View style={[styles.halo, { width: buddySize * 1.2, height: buddySize * 1.2, borderRadius: (buddySize * 1.2) / 2, backgroundColor: (buddy?.color || '#4A90E2') + '26' }]} />
      <View style={[
        styles.buddyCircle, 
        { 
          backgroundColor: buddy.color,
          width: buddySize,
          height: buddySize,
          borderRadius: buddySize / 2,
        }
      ]}>
        <Text style={[
          styles.buddyEmoji, 
          { fontSize: buddySize * 0.44 }
        ]}>
          {buddy.emoji}
        </Text>
      </View>
      
      {isStudying && !isFaded && (
        <View style={[
          styles.studyingIndicator,
          { 
            paddingHorizontal: getScaledSize(20, ageGroup, 'spacing'),
            paddingVertical: getScaledSize(8, ageGroup, 'spacing')
          }
        ]}>
          <Text style={[
            styles.studyingText,
            { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
          ]}>
            {studyingIndicatorText}
          </Text>
        </View>
      )}
      
      {isFaded && (
        <Text style={[
          styles.fadedMessage,
          { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
        ]}>
          {fadedMessageText}
        </Text>
      )}
    </Animated.View>
  );
}

// Helper functions for age-appropriate content
function getStudyingIndicatorText(ageGroup: AgeGroup): string {
  const indicators = {
    young: '📚 Learning...',
    elementary: '📚 Studying...',
    tween: '💻 Working...',
    teen: '📱 Focus'
  };
  return indicators[ageGroup] || indicators.elementary;
}

function getFadedMessageText(ageGroup: AgeGroup): string {
  const messages = {
    young: '👀 Look at your work!',
    elementary: '👀 Eyes on your work!',
    tween: '👀 Stay focused',
    teen: '👀 Focus'
  };
  return messages[ageGroup] || messages.elementary;
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
  },
  halo: {
    position: 'absolute',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.12,
    shadowRadius: 20,
    elevation: 6,
  },
  buddyCircle: {
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.14,
    shadowRadius: 20,
    elevation: 8,
  },
  buddyEmoji: {
    // Size set dynamically
  },
  studyingIndicator: {
    position: 'absolute',
    bottom: -30,
    backgroundColor: 'white',
    borderRadius: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.12,
    shadowRadius: 12,
    elevation: 4,
  },
  studyingText: {
    fontWeight: '600',
    color: '#2C3E50',
  },
  fadedMessage: {
    position: 'absolute',
    bottom: -30,
    color: '#7F8C8D',
    fontStyle: 'italic',
  },
});
```

---

## study-buddy/src/components/StudyTimer.tsx
```tsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { 
  getAgeConfig, 
  getScaledSize 
} from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

type StudyTimerProps = { seconds: number; ageGroup?: AgeGroup };

export default function StudyTimer({ seconds, ageGroup = 'elementary' }: StudyTimerProps): JSX.Element {
  const config = getAgeConfig(ageGroup);

  const formatTime = (totalSeconds: number) => {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const secs = totalSeconds % 60;

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  };

  const getTimerColor = (seconds: number, ageGroup: AgeGroup) => {
    // Age-appropriate color progression
    const colorProgression = {
      young: {
        early: '#27AE60',    // Green - exciting start
        middle: '#F39C12',   // Orange - keep going  
        late: '#E74C3C',     // Red - almost done!
        extended: '#9B59B6'  // Purple - wow!
      },
      elementary: {
        early: '#27AE60',    // Green
        middle: '#F39C12',   // Orange
        late: '#3498DB',     // Blue
        extended: '#9B59B6'  // Purple
      },
      tween: {
        early: '#3498DB',    // Blue - calm start
        middle: '#27AE60',   // Green - in the zone
        late: '#F39C12',     // Orange - pushing through
        extended: '#9B59B6'  // Purple - impressive
      },
      teen: {
        early: '#95A5A6',    // Gray - minimal
        middle: '#3498DB',   // Blue - focused
        late: '#27AE60',     // Green - strong
        extended: '#9B59B6'  // Purple - exceptional
      }
    };
    
    const colors = colorProgression[ageGroup] || colorProgression.elementary;
    
    if (seconds < 300) return colors.early;      // First 5 minutes
    if (seconds < 900) return colors.middle;     // 5-15 minutes  
    if (seconds < 1800) return colors.late;      // 15-30 minutes
    return colors.extended;                      // 30+ minutes
  };

  const getMilestoneMessage = (seconds, ageGroup) => {
    if (seconds % 300 !== 0) return null; // Only show every 5 minutes
    
    const minutes = Math.floor(seconds / 60);
    const milestones = {
      young: `🎉 ${minutes} minutes! You're amazing!`,
      elementary: `🎉 ${minutes} minutes! Great job!`,
      tween: `🔥 ${minutes} minutes! Crushing it!`,
      teen: `💯 ${minutes} minutes. Solid.`
    };
    
    return milestones[ageGroup] || milestones.elementary;
  };

  const timerColor = getTimerColor(seconds, ageGroup);
  const milestoneText = getMilestoneMessage(seconds, ageGroup);

  return (
    <View style={[
      styles.container, 
      { 
        backgroundColor: timerColor,
        paddingHorizontal: getScaledSize(40, ageGroup, 'spacing'),
        paddingVertical: getScaledSize(20, ageGroup, 'spacing'),
        borderRadius: getScaledSize(25, ageGroup, 'spacing')
      }
    ]}>
      <Text style={[
        styles.label,
        { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
      ]}>
        Focus Time
      </Text>
      <Text style={[
        styles.time,
        { fontSize: getScaledSize(48, ageGroup, 'fontSize') }
      ]}>
        {formatTime(seconds)}
      </Text>
      {milestoneText && (
        <Text style={[
          styles.milestone,
          { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
        ]}>
          {milestoneText}
        </Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    marginVertical: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 10,
    elevation: 8,
  },
  label: {
    color: 'white',
    opacity: 0.9,
    marginBottom: 5,
  },
  time: {
    fontWeight: 'bold',
    color: 'white',
  },
  milestone: {
    color: 'white',
    marginTop: 5,
  },
});
```

---

## study-buddy/src/components/CheckInMessage.tsx
```tsx
import React, { useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Animated } from 'react-native';
import { 
  getAgeConfig, 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

type CheckInMessageProps = { message: string; ageGroup?: AgeGroup };

export default function CheckInMessage({ message, ageGroup = 'elementary' }: CheckInMessageProps): JSX.Element {
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(-50)).current;

  const config = getAgeConfig(ageGroup);

  useEffect(() => {
    // Fade in and slide down using configured timing
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: TIMING_CONFIG.animations.fadeIn,
        useNativeDriver: true,
      }),
      Animated.spring(slideAnim, {
        toValue: 0,
        tension: 50,
        friction: 8,
        useNativeDriver: true,
      }),
    ]).start();

    // Fade out after configured display time
    setTimeout(() => {
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: TIMING_CONFIG.animations.fadeIn,
        useNativeDriver: true,
      }).start();
    }, TIMING_CONFIG.session.checkInDisplay);
  }, [message]);

  return (
    <Animated.View 
      style={[
        styles.container,
        {
          opacity: fadeAnim,
          transform: [{ translateY: slideAnim }],
          backgroundColor: (config.accentColor || '#4A90E2') + 'CC',
          paddingHorizontal: getScaledSize(20, ageGroup, 'spacing'),
          paddingVertical: getScaledSize(12, ageGroup, 'spacing'),
          borderRadius: getScaledSize(30, ageGroup, 'spacing'),
          top: getScaledSize(90, ageGroup, 'spacing')
        },
      ]}
    >
      <Text style={[
        styles.message,
        { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
      ]}>
        {message}
      </Text>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    left: 20,
    right: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.14,
    shadowRadius: 20,
    elevation: 6,
    zIndex: 1000,
  },
  message: {
    fontWeight: '600',
    color: 'white',
    textAlign: 'center',
  },
});
```

---

## study-buddy/src/components/BigButton.tsx
```tsx
import React, { useRef } from 'react';
import { TouchableOpacity, Text, StyleSheet, Animated, StyleProp, ViewStyle } from 'react-native';
import * as Haptics from 'expo-haptics';
import { 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

type BigButtonProps = { title: string; onPress: () => void; color?: string; style?: StyleProp<ViewStyle>; ageGroup?: AgeGroup };

export default function BigButton({ 
  title, 
  onPress, 
  color = '#4A90E2', 
  style,
  ageGroup = 'elementary'
}: BigButtonProps): JSX.Element {
  const scaleAnim = useRef(new Animated.Value(1)).current;

  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: 0.95,
      tension: 100,
      friction: 10,
      useNativeDriver: true,
    }).start();
  };

  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      tension: 50,
      friction: 5,
      useNativeDriver: true,
    }).start();
  };

  const handlePress = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    onPress();
  };

  return (
    <Animated.View style={[{ transform: [{ scale: scaleAnim }] }, style]}>
      <TouchableOpacity
        style={[
          styles.button, 
          { 
            backgroundColor: color,
            paddingHorizontal: getScaledSize(40, ageGroup, 'spacing'),
            paddingVertical: getScaledSize(20, ageGroup, 'spacing'),
            borderRadius: getScaledSize(40, ageGroup, 'spacing')
          }
        ]}
        onPress={handlePress}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        activeOpacity={0.8}
        accessibilityRole="button"
        accessibilityLabel={title}
        accessibilityHint="Activates this action"
      >
        <Text style={[
          styles.buttonText,
          { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
        ]}>
          {title}
        </Text>
      </TouchableOpacity>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  button: {
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.12,
    shadowRadius: 20,
    elevation: 6,
  },
  buttonText: {
    fontWeight: '700',
    color: 'white',
  },
});
```

---

## study-buddy/src/utils/intl/i18n.ts
```ts
// Minimal i18n implementation for Study Buddy
// Supports: English, German, Spanish

import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Localization from 'expo-localization';

const translations = {
  en: {
    // Mode Selection
    howAreYouFeeling: 'How are you feeling?',
    readyToWork: 'Ready to Work!',
    needToCalmDown: 'Need to Calm Down',
    startQuickly: 'Start quickly or pick a mode below.',
    
    // Onboarding
    howOldIsYourChild: 'How old is your study superstar?',
    weWillCustomize: "We'll customize everything for their age!",
    pickYourFriend: 'Pick Your Friend!',
    whoWillHelp: 'Who will help you today?',
    whatsYourName: "What's Your Name?",
    holdToRecord: 'Hold to Record',
    recording: 'Recording...',
    skipForNow: 'Skip for now',
    weAreReady: "We're Ready!",
    
    // Main Screen
    letsWorkOn: "Let's work on",
    focusTime: 'Focus Time',
    dayStreak: 'day streak',
    studyTime: 'Study time',
    startStudying: 'Start Studying!',
    breakTime: 'Break Time!',
    finished: 'Finished!',
    
    // Subjects
    math: 'Math',
    reading: 'Reading',
    writing: 'Writing',
    science: 'Science',
    chemistry: 'Chemistry',
    biology: 'Biology',
    history: 'History',
    geography: 'Geography',
    other: 'Other',
    
    // Check-ins
    whatAreYouWorkingOn: 'What are you working on?',
    howsItGoing: "How's it going?",
    howMuchDone: 'How much done?',
    easy: 'Easy!',
    ok: 'OK',
    hard: 'Hard',
    needHelp: 'Need help',
    allDone: 'All done',
    most: 'Most',
    half: 'Half',
    justStarted: 'Just started',
    
    // Celebration
    amazingJob: 'Amazing Job!',
    sessionComplete: 'Session Complete',
    todaysFocusTime: "Today's Focus Time",
    currentStreak: 'Current Streak',
    totalFocusTime: 'Total Focus Time',
    shareSuccess: 'Share Success!',
    continue: 'Continue',
    
    // Parent Settings
    parentSettings: 'Parent Settings',
    parentAccess: 'Parent Access',
    saveSettings: 'Save Settings',
    timerSettings: 'Timer Settings',
    workDuration: 'Work Duration',
    breakDuration: 'Break Duration',
    minutes: 'minutes',
    
    // Calm Mode
    startCalming: 'Start Calming',
    breatheIn: 'Breathe In',
    breatheOut: 'Breathe Out',
    breathsCount: 'breaths',
    imReadyToTalk: "I'm ready to talk",
    
    // Quick Start Labels
    quickMath: 'Math',
    quickRead: 'Read',
    quickScience: 'Science',
    quickWrite: 'Write',
    quickChem: 'Chem'
  },
  
  de: {
    // Mode Selection
    howAreYouFeeling: 'Wie fühlst du dich?',
    readyToWork: 'Bereit zu arbeiten!',
    needToCalmDown: 'Muss mich beruhigen',
    startQuickly: 'Schnell starten oder Modus wählen.',
    
    // Onboarding
    howOldIsYourChild: 'Wie alt ist dein Lern-Superstar?',
    weWillCustomize: 'Wir passen alles an das Alter an!',
    pickYourFriend: 'Wähle deinen Freund!',
    whoWillHelp: 'Wer hilft dir heute?',
    whatsYourName: 'Wie heißt du?',
    holdToRecord: 'Halten zum Aufnehmen',
    recording: 'Aufnahme...',
    skipForNow: 'Überspringen',
    weAreReady: 'Wir sind bereit!',
    
    // Main Screen
    letsWorkOn: 'Lass uns arbeiten an',
    focusTime: 'Fokuszeit',
    dayStreak: 'Tage in Folge',
    studyTime: 'Lernzeit',
    startStudying: 'Lernen starten!',
    breakTime: 'Pausenzeit!',
    finished: 'Fertig!',
    
    // Subjects
    math: 'Mathe',
    reading: 'Lesen',
    writing: 'Schreiben',
    science: 'Wissenschaft',
    chemistry: 'Chemie',
    biology: 'Biologie',
    history: 'Geschichte',
    geography: 'Geographie',
    other: 'Andere',
    
    // Check-ins
    whatAreYouWorkingOn: 'Woran arbeitest du?',
    howsItGoing: 'Wie läuft es?',
    howMuchDone: 'Wie viel geschafft?',
    easy: 'Einfach!',
    ok: 'OK',
    hard: 'Schwer',
    needHelp: 'Brauche Hilfe',
    allDone: 'Alles fertig',
    most: 'Das meiste',
    half: 'Hälfte',
    justStarted: 'Gerade angefangen',
    
    // Celebration
    amazingJob: 'Großartige Arbeit!',
    sessionComplete: 'Sitzung abgeschlossen',
    todaysFocusTime: 'Heutige Fokuszeit',
    currentStreak: 'Aktuelle Serie',
    totalFocusTime: 'Gesamte Fokuszeit',
    shareSuccess: 'Erfolg teilen!',
    continue: 'Weiter',
    
    // Parent Settings
    parentSettings: 'Elterneinstellungen',
    parentAccess: 'Elternzugang',
    saveSettings: 'Einstellungen speichern',
    timerSettings: 'Timer-Einstellungen',
    workDuration: 'Arbeitsdauer',
    breakDuration: 'Pausendauer',
    minutes: 'Minuten',
    
    // Calm Mode
    startCalming: 'Beruhigung starten',
    breatheIn: 'Einatmen',
    breatheOut: 'Ausatmen',
    breathsCount: 'Atemzüge',
    imReadyToTalk: 'Ich bin bereit zu reden',
    
    // Quick Start Labels
    quickMath: 'Mathe',
    quickRead: 'Lesen',
    quickScience: 'Wissen',
    quickWrite: 'Schreiben',
    quickChem: 'Chemie',
    // Notifications & system
    notificationsPermissionTitle: 'Benachrichtigungen',
    notificationsPermissionBody: 'Wir verwenden gelegentliche Check-ins, um Ihr Kind zu unterstützen. Sie können dies jederzeit ändern.',
    notNow: 'Nicht jetzt',
    resume: 'Fortsetzen',
    break5: '+5 Min Pause',
    imDone: 'Ich bin fertig',
    checkinTitle: 'Study Buddy'
  },
  
  es: {
    // Mode Selection
    howAreYouFeeling: '¿Cómo te sientes?',
    readyToWork: '¡Listo para trabajar!',
    needToCalmDown: 'Necesito calmarme',
    startQuickly: 'Comienza rápido o elige un modo.',
    
    // Onboarding
    howOldIsYourChild: '¿Qué edad tiene tu superestrella?',
    weWillCustomize: '¡Personalizaremos todo para su edad!',
    pickYourFriend: '¡Elige tu amigo!',
    whoWillHelp: '¿Quién te ayudará hoy?',
    whatsYourName: '¿Cómo te llamas?',
    holdToRecord: 'Mantén para grabar',
    recording: 'Grabando...',
    skipForNow: 'Omitir por ahora',
    weAreReady: '¡Estamos listos!',
    
    // Main Screen
    letsWorkOn: 'Trabajemos en',
    focusTime: 'Tiempo de enfoque',
    dayStreak: 'días seguidos',
    studyTime: 'Tiempo de estudio',
    startStudying: '¡Empezar a estudiar!',
    breakTime: '¡Tiempo de descanso!',
    finished: '¡Terminado!',
    
    // Subjects
    math: 'Matemáticas',
    reading: 'Lectura',
    writing: 'Escritura',
    science: 'Ciencias',
    chemistry: 'Química',
    biology: 'Biología',
    history: 'Historia',
    geography: 'Geografía',
    other: 'Otro',
    
    // Check-ins
    whatAreYouWorkingOn: '¿En qué estás trabajando?',
    howsItGoing: '¿Cómo va?',
    howMuchDone: '¿Cuánto has hecho?',
    easy: '¡Fácil!',
    ok: 'OK',
    hard: 'Difícil',
    needHelp: 'Necesito ayuda',
    allDone: 'Todo listo',
    most: 'La mayoría',
    half: 'La mitad',
    justStarted: 'Recién empezado',
    
    // Celebration
    amazingJob: '¡Trabajo increíble!',
    sessionComplete: 'Sesión completada',
    todaysFocusTime: 'Tiempo de enfoque de hoy',
    currentStreak: 'Racha actual',
    totalFocusTime: 'Tiempo total de enfoque',
    shareSuccess: '¡Compartir éxito!',
    continue: 'Continuar',
    
    // Parent Settings
    parentSettings: 'Ajustes para padres',
    parentAccess: 'Acceso para padres',
    saveSettings: 'Guardar ajustes',
    timerSettings: 'Ajustes del temporizador',
    workDuration: 'Duración del trabajo',
    breakDuration: 'Duración del descanso',
    minutes: 'minutos',
    
    // Calm Mode
    startCalming: 'Empezar a calmarse',
    breatheIn: 'Inhala',
    breatheOut: 'Exhala',
    breathsCount: 'respiraciones',
    imReadyToTalk: 'Estoy listo para hablar',
    
    // Quick Start Labels
    quickMath: 'Mate',
    quickRead: 'Leer',
    quickScience: 'Ciencias',
    quickWrite: 'Escribir',
    quickChem: 'Química',
    // Notifications & system
    notificationsPermissionTitle: 'Notificaciones',
    notificationsPermissionBody: 'Usamos check-ins ocasionales para mantener a su hijo en camino. Puede cambiar esto en cualquier momento.',
    notNow: 'Ahora no',
    resume: 'Reanudar',
    break5: '+5 min de descanso',
    imDone: 'Terminé',
    checkinTitle: 'Study Buddy'
  }
};

// Current language state
let currentLanguage = 'en';

// Initialize from device settings
export const initializeLanguage = async (): Promise<void> => {
  try {
    // Try to get saved language preference
    const savedLang = await AsyncStorage.getItem('@StudyBuddy:language');
    if (savedLang && translations[savedLang]) {
      currentLanguage = savedLang;
      return;
    }
    
    // Otherwise use device language
    const deviceLang = Localization.locale.split('-')[0]; // 'en-US' -> 'en'
    if (translations[deviceLang]) {
      currentLanguage = deviceLang;
    }
  } catch (e) {
    // Default to English
  }
};

// Get current language
export const getCurrentLanguage = (): string => currentLanguage;

// Set language
export const setLanguage = async (lang: string): Promise<void> => {
  if (translations[lang]) {
    currentLanguage = lang;
    await AsyncStorage.setItem('@StudyBuddy:language', lang);
  }
};

// Get translated string
export const t = (key: string): string => {
  return translations[currentLanguage]?.[key] || translations.en[key] || key;
};

// Get all available languages
export const getAvailableLanguages = (): Array<{ code: string; name: string; flag: string }> => [
  { code: 'en', name: 'English', flag: '🇺🇸' },
  { code: 'de', name: 'Deutsch', flag: '🇩🇪' },
  { code: 'es', name: 'Español', flag: '🇪🇸' }
];

// Format with parameters
export const tf = (key: string, params: Record<string, string | number> = {}): string => {
  let text = t(key);
  Object.keys(params).forEach(param => {
    text = text.replace(`{${param}}`, params[param]);
  });
  return text;
};
// Locale/timezone helpers and formatters
export const getLocale = (): string => {
  try {
    const deviceLocale = (Localization.locale || 'en-US');
    if (deviceLocale.toLowerCase().startsWith(currentLanguage.toLowerCase())) return deviceLocale;
  } catch {}
  return currentLanguage === 'en' ? 'en-US' : currentLanguage;
};

export const getTimeZone = (): string => {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
  } catch {
    return 'UTC';
  }
};

export const formatDate = (d: Date, opts?: Intl.DateTimeFormatOptions): string =>
  new Intl.DateTimeFormat(getLocale(), opts).format(d);

export const formatTime = (d: Date, opts?: Intl.DateTimeFormatOptions): string =>
  new Intl.DateTimeFormat(getLocale(), { hour: 'numeric', minute: '2-digit', ...opts }).format(d);

export const formatNumber = (n: number, opts?: Intl.NumberFormatOptions): string =>
  new Intl.NumberFormat(getLocale(), opts).format(n);
```

---

## study-buddy/src/utils/voice/speech.ts
```ts
import * as Speech from 'expo-speech';
import { getStorageItem } from '@utils/core/storage';

// Rate limiting
let lastSpeechTime = 0;
const MIN_SPEECH_INTERVAL = 1000; // Minimum 1 second between speeches

// Cached settings
let cachedSettings = {
  mainScreenEnabled: true,
  calmModeEnabled: true,
  celebrationEnabled: true,
  rate: 1.0,
  pitch: 1.0,
};

// Load speech settings from storage
export const loadSpeechSettings = async (): Promise<typeof cachedSettings> => {
  try {
    const settings = await getStorageItem('speechSettings');
    if (settings) {
      cachedSettings = JSON.parse(settings);
    }
  } catch (e) {
    console.log('Error loading speech settings:', e);
  }
  return cachedSettings;
};

// Smart speak function with rate limiting and settings respect
export const smartSpeak = async (
  text: string,
  options: {
    screenType?: 'main' | 'calm' | 'celebration';
    forceSpeak?: boolean;
    language?: string;
  } & Partial<Speech.SpeechOptions> = {}
): Promise<void> => {
  const {
    screenType = 'main', // 'main', 'calm', 'celebration'
    forceSpeak = false,  // Override rate limiting for critical messages
    language = 'en',
    ...speechOptions
  } = options;

  // Load latest settings
  await loadSpeechSettings();

  // Check if speech is enabled for this screen
  const screenEnabledMap: Record<'main'|'calm'|'celebration', boolean> = {
    main: cachedSettings.mainScreenEnabled,
    calm: cachedSettings.calmModeEnabled,
    celebration: cachedSettings.celebrationEnabled,
  };
  const enabled = screenEnabledMap[screenType];
  if (!enabled && !forceSpeak) {
    return;
  }

  // Rate limiting
  const now = Date.now();
  if (!forceSpeak && now - lastSpeechTime < MIN_SPEECH_INTERVAL) {
    return;
  }

  // Stop any ongoing speech
  await Speech.stop();

  // Update last speech time
  lastSpeechTime = now;

  // Speak with settings
  // Simple queue: if speaking, wait until finished or timeout
  const speaking = await Speech.isSpeakingAsync();
  if (speaking && !forceSpeak) {
    await new Promise((resolve) => setTimeout(resolve, 250));
  }
  await Speech.speak(text, {
    language,
    rate: cachedSettings.rate,
    pitch: cachedSettings.pitch,
    ...speechOptions
  });
};

// Stop all speech
export const stopSpeech = async (): Promise<void> => {
  await Speech.stop();
};

// Check if speaking
export const isSpeaking = async (): Promise<boolean> => {
  return await Speech.isSpeakingAsync();
};
```

---

## study-buddy/src/utils/media/photoManager.ts
```ts
import * as FileSystem from 'expo-file-system';
import { getStorageItem, setStorageItem } from '@utils/core/storage';

const PHOTO_DIR = (FileSystem.cacheDirectory || FileSystem.documentDirectory) + 'StudyBuddyPhotos/';
const PHOTO_INDEX_KEY = 'photoIndex';

// Ensure photo directory exists
export const ensurePhotoDirectory = async (): Promise<void> => {
  const dirInfo = await FileSystem.getInfoAsync(PHOTO_DIR);
  if (!dirInfo.exists) {
    await FileSystem.makeDirectoryAsync(PHOTO_DIR, { intermediates: true });
  }
};

// Save photo with metadata
export const savePhoto = async (photoUri: string): Promise<string> => {
  await ensurePhotoDirectory();
  
  const timestamp = Date.now();
  const fileName = `homework_${timestamp}.jpg`;
  const destUri = PHOTO_DIR + fileName;
  
  await FileSystem.copyAsync({
    from: photoUri,
    to: destUri
  });
  
  // Update photo index
  const indexStr = await getStorageItem(PHOTO_INDEX_KEY);
  const index = indexStr ? JSON.parse(indexStr) : [];
  index.push({ fileName, timestamp, uri: destUri });
  await setStorageItem(PHOTO_INDEX_KEY, JSON.stringify(index));
  
  return destUri;
};

// Clean old photos based on settings
export const cleanOldPhotos = async (): Promise<void> => {
  try {
    const settingsStr = await getStorageItem('photoSettings');
    const settings = settingsStr ? JSON.parse(settingsStr) : { autoDeleteDays: 7 };
    
    const indexStr = await getStorageItem(PHOTO_INDEX_KEY);
    if (!indexStr) return;
    
    const index = JSON.parse(indexStr);
    const now = Date.now();
    const maxAge = settings.autoDeleteDays * 24 * 60 * 60 * 1000;
    
    const updatedIndex: Array<{ fileName: string; timestamp: number; uri: string }> = [];
    
    for (const photo of index) {
      if (now - photo.timestamp > maxAge) {
        // Delete old photo
        try {
          await FileSystem.deleteAsync(photo.uri, { idempotent: true });
        } catch (e) {
          console.log('Error deleting photo:', e);
        }
      } else {
        updatedIndex.push(photo);
      }
    }
    
    await setStorageItem(PHOTO_INDEX_KEY, JSON.stringify(updatedIndex));
  } catch (e) {
    console.log('Error cleaning photos:', e);
  }
};

// Get all photos
export const getAllPhotos = async (): Promise<Array<{ fileName: string; timestamp: number; uri: string }>> => {
  const indexStr = await getStorageItem(PHOTO_INDEX_KEY);
  return indexStr ? JSON.parse(indexStr) : [];
};
```

---

## study-buddy/src/screens/PaywallScreen.tsx
```tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
  ActivityIndicator,
  Alert,
  Platform,
  Linking
} from 'react-native';
import Constants from 'expo-constants';
import { getAppConfig } from '@config/appConfig';
import { getAgeConfig, getScaledSize } from '@utils/config/constants';
import { t } from '@utils/intl/i18n';
import { track } from '@utils/analytics';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getCurrentOfferings, purchasePackage as buyPkg, restore as restorePurchasesAPI } from '@utils/purchases';

type Props = StackScreenProps<RootStackParamList, 'Paywall'>;

export default function PaywallScreen({ navigation, route }: Props) {
  const [offerings, setOfferings] = useState(null);
  const [loading, setLoading] = useState(true);
  const [purchasing, setPurchasing] = useState(false);
  const [variant, setVariant] = useState<'A' | 'B'>('A');
  const ageGroup = route.params?.ageGroup || 'elementary';
  const config = getAgeConfig(ageGroup);
  const extra = getAppConfig();

  useEffect(() => {
    // Decide variant using weighted selection; persist for session via simple RNG
    const variants = extra.remote?.paywall?.variants || { A: 1 };
    const r = Math.random();
    const total = Object.values(variants).reduce((a, b) => a + b, 0) || 1;
    let acc = 0;
    let chosen: 'A' | 'B' = 'A';
    (Object.entries(variants) as Array<[string, number]>).forEach(([k, w]) => {
      if (acc / total <= r && r < (acc + w) / total) {
        chosen = (k === 'B' ? 'B' : 'A');
      }
      acc += w;
    });
    setVariant(chosen);
    loadOfferings();
  }, []);

  const loadOfferings = async () => {
    try {
      const offerings = await getCurrentOfferings();
      if (offerings.current !== null) {
        setOfferings(offerings.current);
      } else {
        setOfferings(null);
      }
      setLoading(false);
    } catch (e) {
      console.log('Error loading offerings:', e);
      setLoading(false);
    }
  };

  const purchasePackage = async (packageItem) => {
    setPurchasing(true);
    try {
      const { isPremium } = await buyPkg(packageItem);
      if (isPremium) {
        Alert.alert('Success!', 'Welcome to Study Buddy Premium!', [
          { text: 'OK', onPress: () => navigation.goBack() }
        ]);
      }
    } catch (e) {
      // Errors tracked in purchases wrapper
      Alert.alert('Error', 'Purchase failed. Please try again.');
    }
    setPurchasing(false);
  };

  const restorePurchases = async () => {
    setPurchasing(true);
    try {
      const { isPremium } = await restorePurchasesAPI();
      if (isPremium) {
        track('restore_success');
        Alert.alert('Restored', 'Your premium access has been restored.', [
          { text: 'OK', onPress: () => navigation.goBack() }
        ]);
      } else {
        track('restore_no_active');
        Alert.alert('No Active Subscriptions', 'We could not find an active premium subscription on this account.');
      }
    } catch (e) {
      track('restore_failed', { error: String(e) });
      Alert.alert('Error', 'Could not restore purchases. Please try again later.');
    }
    setPurchasing(false);
  };

  const openManageSubscriptions = async () => {
    const urls = extra?.manageSubscriptions || {};
    const url = Platform.OS === 'ios' ? urls.ios : urls.android;
    if (url) {
      try { await Linking.openURL(url); } catch {}
    }
  };

  const retryLoad = () => {
    setLoading(true);
    loadOfferings();
  };

  if (loading) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: config.secondaryColor }]}>
        <ActivityIndicator size="large" color={config.primaryColor} />
      </SafeAreaView>
    );
  }

  const noOffering = !offerings || !offerings.availablePackages?.length;

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: config.secondaryColor }]}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        {/* Header */}
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.closeButton}
          accessibilityRole="button"
          accessibilityLabel="Close"
        >
          <Text style={styles.closeText}>✕</Text>
        </TouchableOpacity>

        {/* Title */}
        <Text style={[styles.title, { color: config.primaryColor }]}>Study Buddy Premium</Text>
        {variant === 'B' && (
          <Text style={[styles.subtitle, { color: '#2C3E50', marginTop: 6 }]}>Unlock calmer study time and fewer battles at home.</Text>
        )}

        {noOffering ? (
          <View style={styles.benefitsContainer}>
            <Text style={[styles.benefitTitle, { marginBottom: 8 }]}>No plans available</Text>
            <Text style={{ color: '#2C3E50', textAlign: 'center' }}>
              We couldn't load subscription options. Please try again later or restore purchases.
            </Text>
            <TouchableOpacity
              style={styles.restoreButton}
              onPress={retryLoad}
              disabled={purchasing}
              accessibilityRole="button"
              accessibilityLabel="Retry"
            >
              <Text style={styles.restoreText}>Retry</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <>
            {/* Benefits */}
            <View style={styles.benefitsContainer}>
              <Text style={styles.benefitTitle}>Unlock Everything:</Text>
              {(variant === 'A'
                ? [
                    '✓ Unlimited study sessions',
                    '✓ All buddy characters',
                    '✓ Custom encouragement messages',
                    '✓ Detailed progress reports',
                    '✓ Photo history gallery',
                    '✓ Ad-free forever'
                  ]
                : [
                    '✓ Calmer homework time, fewer negotiations',
                    '✓ Buddy voices that match your child's age',
                    '✓ Custom parent encouragement clips',
                    '✓ Weekly focus insights for parents',
                    '✓ Private on-device photo gallery',
                    '✓ No ads — ever'
                  ]).map((benefit, index) => (
                <Text key={index} style={styles.benefitItem}>{benefit}</Text>
              ))}
            </View>

            {/* Packages */}
            {offerings && offerings.availablePackages.map((pkg) => (
              <TouchableOpacity
                key={pkg.identifier}
                style={[styles.packageButton, { backgroundColor: config.primaryColor }]}
                onPress={() => purchasePackage(pkg)}
                disabled={purchasing}
                accessibilityRole="button"
                accessibilityLabel={`Purchase ${pkg.product.title}`}
              >
                <Text style={styles.packageTitle}>{pkg.product.title}</Text>
                <Text style={styles.packagePrice}>
                  {pkg.product.priceString}
                  {pkg.packageType === 'MONTHLY' && '/month'}
                  {pkg.packageType === 'ANNUAL' && '/year'}
                </Text>
                {pkg.packageType === 'ANNUAL' && (
                  <Text style={styles.savingsText}>Save 33%!</Text>
                )}
              </TouchableOpacity>
            ))}
          </>
        )}

        {/* Restore & Manage */}
        <TouchableOpacity
          style={styles.restoreButton}
          onPress={restorePurchases}
          disabled={purchasing}
          accessibilityRole="button"
          accessibilityLabel="Restore purchases"
        >
          <Text style={styles.restoreText}>Restore Purchases</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.restoreButton}
          onPress={openManageSubscriptions}
          disabled={purchasing}
          accessibilityRole="button"
          accessibilityLabel="Manage subscription"
        >
          <Text style={styles.restoreText}>Manage Subscription</Text>
        </TouchableOpacity>

        {/* Terms */}
        <Text style={styles.terms}>
          Subscriptions auto-renew. Manage or cancel anytime in App Store or Google Play settings.
        </Text>
      </ScrollView>
    </SafeAreaView>
  );
}
```

---

## study-buddy/src/utils/voice/speech.test.ts
```ts
import * as Speech from 'expo-speech';
import { smartSpeak } from './speech';

describe('smartSpeak', () => {
  it('rate-limits rapid calls when not forced', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockResolvedValue(undefined as any);
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => {} as any);
    const isSpeakingSpy = jest.spyOn(Speech, 'isSpeakingAsync' as any).mockResolvedValue(false as any);

    await smartSpeak('one');
    await smartSpeak('two'); // within MIN_SPEECH_INTERVAL, should be dropped

    expect(speakSpy).toHaveBeenCalledTimes(1);

    stopSpy.mockRestore();
    speakSpy.mockRestore();
    isSpeakingSpy.mockRestore();
  });

  it('forceSpeak bypasses rate limiting', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockResolvedValue(undefined as any);
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => {} as any);
    const isSpeakingSpy = jest.spyOn(Speech, 'isSpeakingAsync' as any).mockResolvedValue(false as any);

    await smartSpeak('one');
    await smartSpeak('two', { forceSpeak: true });

    expect(speakSpy).toHaveBeenCalledTimes(2);

    stopSpy.mockRestore();
    speakSpy.mockRestore();
    isSpeakingSpy.mockRestore();
  });
});
```

---

## study-buddy/src/utils/core/storage.ts
```ts
import AsyncStorage from '@react-native-async-storage/async-storage';

const STORAGE_PREFIX = '@StudyBuddy:';

export const setStorageItem = async (key: string, value: string): Promise<boolean> => {
  try {
    await AsyncStorage.setItem(STORAGE_PREFIX + key, value);
    return true;
  } catch (error) {
    console.error('Error saving to storage:', error);
    return false;
  }
};

export const getStorageItem = async (key: string): Promise<string | null> => {
  try {
    const value = await AsyncStorage.getItem(STORAGE_PREFIX + key);
    return value;
  } catch (error) {
    console.error('Error reading from storage:', error);
    return null;
  }
};

export const removeStorageItem = async (key: string): Promise<boolean> => {
  try {
    await AsyncStorage.removeItem(STORAGE_PREFIX + key);
    return true;
  } catch (error) {
    console.error('Error removing from storage:', error);
    return false;
  }
};

export const clearAllStorage = async (): Promise<boolean> => {
  try {
    const keys = await AsyncStorage.getAllKeys();
    const studyBuddyKeys = keys.filter(key => key.startsWith(STORAGE_PREFIX));
    await AsyncStorage.multiRemove(studyBuddyKeys);
    return true;
  } catch (error) {
    console.error('Error clearing storage:', error);
    return false;
  }
};
```

---

## study-buddy/src/utils/media/audio.ts
```ts
import { Audio } from 'expo-av';
import * as Speech from 'expo-speech';

export const playSound = async (soundFile: any): Promise<void> => {
  try {
    const { sound } = await Audio.Sound.createAsync(soundFile);
    await sound.playAsync();
    
    // Unload sound after playing
    sound.setOnPlaybackStatusUpdate((status) => {
      if (status.didJustFinish) {
        sound.unloadAsync();
      }
    });
  } catch (error) {
    console.error('Error playing sound:', error);
  }
};

export const speak = (text: string, options: Partial<Speech.SpeechOptions> = {}): void => {
  const defaultOptions = {
    language: 'en',
    pitch: 1.1,
    rate: 0.9,
    ...options
  };
  
  Speech.speak(text, defaultOptions as any);
};

export const stopSpeaking = (): void => {
  Speech.stop();
};

export const configureSpeech = async (): Promise<any> => {
  // Check if speech is available
  const available = await Speech.getAvailableVoicesAsync();
  return available;
};
```

---

## study-buddy/src/assets/animations/buddy-animations.ts
```ts
// ===================================
// MODULAR BUDDY SYSTEM
// Data-driven buddy configurations
// ===================================

// Buddy personality templates
const BUDDY_PERSONALITIES = {
  energetic: {
    sounds: ['boing', 'yay', 'woohoo'],
    animationStyle: 'bouncy',
    description: 'super excited and encouraging'
  },
  magical: {
    sounds: ['sparkle', 'magic', 'chime'],
    animationStyle: 'mystical',
    description: 'magical and supportive'
  },
  friendly: {
    sounds: ['roar', 'stomp', 'growl'],
    animationStyle: 'strong',
    description: 'friendly and brave'
  },
  playful: {
    sounds: ['purr', 'meow', 'chirp'],
    animationStyle: 'gentle',
    description: 'playful and encouraging'
  },
  loyal: {
    sounds: ['woof', 'bark', 'pant'],
    animationStyle: 'steady',
    description: 'loyal and supportive'
  },
  smart: {
    sounds: ['beep', 'boop', 'whir'],
    animationStyle: 'precise',
    description: 'smart and helpful'
  },
  cool: {
    sounds: ['roar', 'fire', 'whoosh'],
    animationStyle: 'powerful',
    description: 'cool and powerful'
  },
  focused: {
    sounds: ['howl', 'growl', 'breath'],
    animationStyle: 'calm',
    description: 'focused and strong'
  },
  mysterious: {
    sounds: ['beep', 'whoosh', 'hum'],
    animationStyle: 'ethereal',
    description: 'chill and mysterious'
  },
  minimal: {
    sounds: ['pulse', 'hum', 'tone'],
    animationStyle: 'subtle',
    description: 'minimal and focused'
  },
  zen: {
    sounds: ['rustle', 'grow', 'flow'],
    animationStyle: 'organic',
    description: 'calm and growing'
  },
  mystical: {
    sounds: ['chime', 'glow', 'resonate'],
    animationStyle: 'floating',
    description: 'mystical and serene'
  }
};

type AgeGroup = 'young' | 'elementary' | 'tween' | 'teen';

type BuddyCatalogItem = {
  id: string;
  name: string;
  emoji: string;
  baseColor: string;
  personality: keyof typeof BUDDY_PERSONALITIES;
  allowedAges: AgeGroup[];
};

const BUDDY_CATALOG: BuddyCatalogItem[] = [
  { id: 'bunny', name: 'Bouncy', emoji: '🐰', baseColor: '#FFB6C1', personality: 'energetic', allowedAges: ['young','elementary'] },
  { id: 'unicorn', name: 'Sparkles', emoji: '🦄', baseColor: '#E6E6FA', personality: 'magical', allowedAges: ['young'] },
  { id: 'dino', name: 'Rex', emoji: '🦕', baseColor: '#98FB98', personality: 'friendly', allowedAges: ['young','elementary'] },
  { id: 'cat', name: 'Whiskers', emoji: '🐱', baseColor: '#FFD93D', personality: 'playful', allowedAges: ['elementary'] },
  { id: 'dog', name: 'Buddy', emoji: '🐶', baseColor: '#8B4513', personality: 'loyal', allowedAges: ['elementary'] },
  { id: 'robot', name: 'Beep', emoji: '🤖', baseColor: '#C0C0C0', personality: 'smart', allowedAges: ['elementary','tween','teen'] },
  { id: 'dragon', name: 'Blaze', emoji: '🐉', baseColor: '#FF6B6B', personality: 'cool', allowedAges: ['tween'] },
  { id: 'wolf', name: 'Shadow', emoji: '🐺', baseColor: '#4A5568', personality: 'focused', allowedAges: ['tween'] },
  { id: 'alien', name: 'Cosmic', emoji: '👽', baseColor: '#00D9FF', personality: 'mysterious', allowedAges: ['tween'] },
  { id: 'geometric', name: 'Hex', emoji: '⬡', baseColor: '#7C3AED', personality: 'minimal', allowedAges: ['teen'] },
  { id: 'plant', name: 'Zen', emoji: '🌱', baseColor: '#10B981', personality: 'zen', allowedAges: ['teen'] },
  { id: 'orb', name: 'Focus', emoji: '🔮', baseColor: '#EC4899', personality: 'mystical', allowedAges: ['teen'] },
];

function decorateBuddy(template: BuddyCatalogItem) {
  const personality = BUDDY_PERSONALITIES[template.personality];
  return {
    ...template,
    color: template.baseColor,
    sounds: personality.sounds,
    animationStyle: personality.animationStyle,
    description: personality.description
  };
}

export const getBuddiesForAge = (ageGroup: AgeGroup) => {
  return BUDDY_CATALOG.filter(b => b.allowedAges.includes(ageGroup)).map(decorateBuddy);
};

export const getBuddyForAge = (ageGroup: AgeGroup, buddyId: string) => {
  const list = getBuddiesForAge(ageGroup);
  return list.find(b => b.id === buddyId) || list[0];
};

// Animation file references (for Lottie)
export const ANIMATIONS = {
  studying: 'studying.json',
  celebrating: 'celebrating.json',
  idle: 'idle.json',
  encouraging: 'encouraging.json',
  confetti: 'confetti.json'
};

// Remove duplicate legacy exports referencing undefined BUDDIES_BY_AGE.
```

---

## study-buddy/src/utils/content/peerLines.ts
```ts
import { SUBJECT_SYSTEM, AGE_CONFIGS } from '@utils/config/constants';
import type { GeneratePeerLineInput } from '@types/index';

// Deterministic-ish helper to keep session-consistent variation
function seededRand(seed) {
  let x = 0;
  try { x = Array.from(String(seed)).reduce((a, c) => a + c.charCodeAt(0), 0); } catch {}
  const t = Math.sin(x) * 10000;
  return t - Math.floor(t);
}

const SUBJECT_HINTS = {
  math: ['Check your steps', 'One problem at a time', 'Show your work'],
  reading: ['Summarize the paragraph', 'Who is the main character?', 'Predict what happens next'],
  writing: ['Add one detail', 'Check punctuation', 'Reread your sentence'],
  science: ['State your hypothesis', 'Measure carefully', 'Record observations'],
  chemistry: ['Balance the equation', 'Units matter', 'Mind safety rules'],
  biology: ['Name the parts', 'Think about the process', 'Use correct terms'],
  history: ['Think causes and effects', 'Check the timeline', 'Who did what?'],
  geography: ['Picture the map', 'Relate places', 'Climate matters'],
  other: ['Stay with it', 'You got this', 'Small steps add up']
};

export function generatePeerLine({
  ageGroup = 'elementary',
  buddyPersonality,
  subjectId = 'other',
  seconds = 0,
  sessionLength = 1200,
  context = 'tick',
  sessionId = 'default',
}: GeneratePeerLineInput): string {
  const ageConfig = AGE_CONFIGS[ageGroup] || AGE_CONFIGS.elementary;
  const subject = SUBJECT_SYSTEM.subjects[subjectId] || SUBJECT_SYSTEM.subjects.other;
  const ratio = Math.max(0, Math.min(1, seconds / Math.max(1, sessionLength)));
  const r = seededRand(`${sessionId}:${seconds}:${subjectId}`);
  // Jitter phase thresholds slightly per session to avoid identical bucketing
  const jitter = (seededRand(`${sessionId}:jitter`) - 0.5) * 0.1; // ±0.05
  const earlyCut = Math.max(0.2, Math.min(0.4, 0.33 + jitter));
  const lateCut = Math.max(0.6, Math.min(0.8, 0.66 + jitter));

  // Early / mid / late templates tuned by age tone
  const tone = ageConfig.personality?.encouragementLevel || 'medium';
  const simple = tone === 'high' || ageGroup === 'young';

  const early = simple
    ? [
        `${subject.emoji} Great start!`,
        `Nice focus on ${subject.label}!`,
        `Let's go! ${subject.label} time!`
      ]
    : [
        `${subject.emoji} Settling in. Keep a steady pace.`,
        `Strong start on ${subject.label}. Stay consistent.`,
        `Dial in. Small steps on ${subject.label}.`
      ];

  const mid = simple
    ? [
        `Halfway vibes! ${subject.emoji}`,
        `Good rhythm. Keep going!`,
        `Nice work—stay with ${subject.label}!`
      ]
    : [
        `You're in the zone. Maintain pace.`,
        `Progress is stacking. Stay on task.`,
        `Solid momentum on ${subject.label}.`
      ];

  const late = simple
    ? [
        `Almost there!`,
        `Push to the finish!`,
        `Final stretch on ${subject.label}!`
      ]
    : [
        `Close it out with quality.`,
        `Finish strong—focus on the next small chunk.`,
        `Wrap-up time: check your last step.`
      ];

  const hints = SUBJECT_HINTS[subject.id] || SUBJECT_HINTS.other;

  // Shuffle-bag per session and phase, with recency avoidance
  type Phase = 'early' | 'mid' | 'late';
  const phase: Phase = ratio > lateCut ? 'late' : ratio > earlyCut ? 'mid' : 'early';

  // Session-scoped cache
  const globalAny: any = (globalThis as any);
  globalAny.__peerLineCache = globalAny.__peerLineCache || {};
  const cacheKey = `${sessionId}:${subject.id}:${phase}`;
  const recencyKey = `${sessionId}:${subject.id}:recency:${phase}`;
  const basePool = phase === 'early' ? early : phase === 'mid' ? mid : late;

  // Initialize shuffled pool when missing or exhausted
  if (!Array.isArray(globalAny.__peerLineCache[cacheKey]) || globalAny.__peerLineCache[cacheKey].length === 0) {
    const shuffled = [...basePool]
      .map((line) => ({ line, k: seededRand(`${cacheKey}:${line}`) }))
      .sort((a, b) => a.k - b.k)
      .map((x) => x.line);
    globalAny.__peerLineCache[cacheKey] = shuffled;
  }
  // Maintain small LRU per phase to avoid near-term repeats
  globalAny.__peerLineCache[recencyKey] = globalAny.__peerLineCache[recencyKey] || [];
  const lru: string[] = globalAny.__peerLineCache[recencyKey];
  const lruMax = 3;

  // Pop next candidate not in LRU; if all are in LRU, pop first
  let candidate = globalAny.__peerLineCache[cacheKey].shift();
  let attempts = basePool.length;
  while (attempts-- > 0 && candidate && lru.includes(candidate) && globalAny.__peerLineCache[cacheKey].length > 0) {
    globalAny.__peerLineCache[cacheKey].push(candidate);
    candidate = globalAny.__peerLineCache[cacheKey].shift();
  }
  const pick = (candidate || basePool[Math.floor(r * basePool.length)]) as string;

  // Mix in subject hint about 40% of the time
  // Update LRU
  if (!lru.includes(pick)) {
    lru.push(pick);
    if (lru.length > lruMax) lru.shift();
  }
  const hintRand = seededRand(`${sessionId}:${seconds}:${subjectId}:hint`);
  const maybeHint = hintRand > 0.6 ? ` • ${hints[Math.floor(hintRand * hints.length)]}` : '';

  // Context tweaks
  if (context === 'backgroundReturn') {
    return `${subject.emoji} Ready to jump back in?${maybeHint}`;
  }
  return `${pick}${maybeHint}`;
}
```

---

## study-buddy/src/utils/content/peerLines.test.ts
```ts
import { generatePeerLine } from './peerLines';

describe('generatePeerLine', () => {
  const base = {
    ageGroup: 'tween' as const,
    subjectId: 'biology',
    sessionId: 'test-session',
    sessionLength: 1200,
  };

  it('picks early-phase lines at start of session', () => {
    const line = generatePeerLine({ ...base, seconds: 60, context: 'tick' });
    expect(line).toMatch(/Great start|Settling in|Strong start|Let's go/i);
  });

  it('picks late-phase lines near end of session', () => {
    const line = generatePeerLine({ ...base, seconds: 1100, context: 'tick' });
    expect(line).toMatch(/Almost there|Push to the finish|Wrap-up|Finish strong|Final stretch|Close it out/i);
  });

  it('adds biology hint sometimes', () => {
    const withHint = generatePeerLine({ ...base, seconds: 300, context: 'tick' });
    // Not deterministic, but ensure function returns a non-empty string
    expect(typeof withHint).toBe('string');
    expect(withHint.length).toBeGreaterThan(0);
  });

  it('avoids immediate repeats within phase (recency LRU)', () => {
    const samples: string[] = [];
    // Very early seconds to stay in early phase regardless of jitter
    for (let s = 5; s <= 45; s += 5) {
      samples.push(generatePeerLine({ ...base, seconds: s, context: 'tick' }));
    }
    // No adjacent duplicates
    for (let i = 1; i < samples.length; i++) {
      expect(samples[i]).not.toEqual(samples[i - 1]);
    }
    // Diversity > 1
    expect(new Set(samples).size).toBeGreaterThan(1);
  });

  it('produces ~40% hints over a window (non-strict)', () => {
    let hintCount = 0;
    const total = 50;
    for (let i = 0; i < total; i++) {
      const line = generatePeerLine({ ...base, seconds: 200 + i * 3, context: 'tick' });
      if (line.includes(' • ')) hintCount++;
    }
    // Expect between 20% and 70% due to randomness bounds
    const rate = hintCount / total;
    expect(rate).toBeGreaterThan(0.2);
    expect(rate).toBeLessThan(0.7);
  });
});
```

---

## study-buddy/src/utils/voice/voice.test.ts
```ts
import { resolveVoiceForBuddy } from './voice';
import * as Speech from 'expo-speech';

describe('resolveVoiceForBuddy', () => {
  it('returns sane defaults when voices API fails', async () => {
    const spy = jest.spyOn(Speech, 'getAvailableVoicesAsync' as any).mockRejectedValueOnce(new Error('fail'));
    const v = await resolveVoiceForBuddy({ ageGroup: 'tween' });
    expect(v.language).toMatch(/^en/);
    expect(typeof v.rate).toBe('number');
    expect(typeof v.pitch).toBe('number');
    spy.mockRestore();
  });

  it('selects an English voice when available', async () => {
    const voices = [
      { identifier: 'es-ES-1', language: 'es-ES' },
      { identifier: 'en-US-1', language: 'en-US' },
    ];
    const spy = jest.spyOn(Speech, 'getAvailableVoicesAsync' as any).mockResolvedValueOnce(voices as any);
    const v = await resolveVoiceForBuddy({ ageGroup: 'teen' });
    expect(v.voice).toBe('en-US-1');
    spy.mockRestore();
  });
});
```

---

## study-buddy/src/utils/voice/voice.ts
```ts
import * as Speech from 'expo-speech';
import { getCurrentLanguage, getLocale } from '@utils/intl/i18n';

// Resolve a voice configuration based on age group and buddy
// Returns: { language, rate, pitch, voice }
export async function resolveVoiceForBuddy({ ageGroup = 'elementary', buddy }: { ageGroup?: 'young' | 'elementary' | 'tween' | 'teen'; buddy?: { personality?: string } }): Promise<{ language: string; rate: number; pitch: number; voice?: string }> {
  // Reasonable defaults per age
  const base = {
    young: { language: 'en-US', rate: 0.9, pitch: 1.2 },
    elementary: { language: 'en-US', rate: 1.0, pitch: 1.1 },
    tween: { language: 'en-US', rate: 1.0, pitch: 1.0 },
    teen: { language: 'en-US', rate: 1.05, pitch: 0.95 },
  }[ageGroup] || { language: 'en-US', rate: 1.0, pitch: 1.0 };

  try {
    const voices = await Speech.getAvailableVoicesAsync();
    const userLang = getCurrentLanguage();
    const preferred = voices?.find(v => v.language?.toLowerCase().startsWith(userLang.toLowerCase()));
    const fallback = voices?.find(v => v.language?.startsWith('en'));
    return { ...base, language: preferred?.language || getLocale(), voice: (preferred || fallback)?.identifier };
  } catch {
    return { ...base, language: getLocale(), voice: undefined };
  }
}
```

---

## study-buddy/src/utils/voice/voice.lang.test.ts
```ts
import * as Speech from 'expo-speech';
import { resolveVoiceForBuddy } from './voice';
import * as I18n from '@utils/intl/i18n';

describe('resolveVoiceForBuddy language preference', () => {
  it('prefers user-selected non-English language when available', async () => {
    jest.spyOn(I18n, 'getCurrentLanguage').mockReturnValue('es');
    const voices = [
      { identifier: 'es-ES-1', language: 'es-ES' },
      { identifier: 'en-US-1', language: 'en-US' },
    ];
    const spy = jest.spyOn(Speech, 'getAvailableVoicesAsync' as any).mockResolvedValueOnce(voices as any);
    const v = await resolveVoiceForBuddy({ ageGroup: 'tween' });
    expect(v.language).toMatch(/^es/);
    expect(v.voice).toBe('es-ES-1');
    spy.mockRestore();
  });
});
```

---

## study-buddy/src/components/ScreenBackground.tsx
```tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { getAgeConfig } from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

type ScreenBackgroundProps = { ageGroup?: AgeGroup; children: React.ReactNode };

export default function ScreenBackground({ ageGroup = 'elementary', children }: ScreenBackgroundProps): JSX.Element {
  const config = getAgeConfig(ageGroup);
  const background = config.secondaryColor || '#F0F8FF';
  const accent = config.accentColor || '#4A90E2';
  const primary = config.primaryColor || '#4A90E2';

  return (
    <View style={[styles.container, { backgroundColor: background }]}>
      {/* Soft blobs for warmth */}
      <View style={[styles.blob, { backgroundColor: primary + '22', top: -80, right: -60, width: 220, height: 220 }]} />
      <View style={[styles.blob, { backgroundColor: accent + '1F', bottom: -60, left: -40, width: 260, height: 260 }]} />
      <View style={[styles.blob, { backgroundColor: '#FFFFFF55', top: 140, left: '20%', width: 140, height: 140 }]} />

      {/* Content */}
      <View style={styles.content}>{children}</View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  blob: {
    position: 'absolute',
    borderRadius: 9999,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.12,
    shadowRadius: 20,
    elevation: 6,
  },
});
```

---

## study-buddy/src/screens/ConsentScreen.tsx
```tsx
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, SafeAreaView, Linking } from 'react-native';
import { getScaledSize } from '@utils/config/constants';
import { track } from '@utils/analytics';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { t } from '@utils/intl/i18n';

type Props = StackScreenProps<RootStackParamList, 'Consent'>;

export default function ConsentScreen({ navigation, route }: Props) {
  const ageGroup = route.params?.ageGroup || 'elementary';
  const open = (url) => Linking.openURL(url).catch(() => {});
  return (
    <SafeAreaView style={styles.safeArea}>
      <View style={styles.container}>
        <Text accessibilityRole="header" style={styles.title}>Parental Consent</Text>
        <Text style={styles.body}>
          We collect minimal usage data (sessions, basic events) to improve the app. Photos remain on-device. No ads.
        </Text>
        <Text style={styles.link} onPress={() => open('https://example.com/privacy')}>Privacy Policy</Text>
        <Text style={styles.link} onPress={() => open('https://example.com/terms')}>Terms of Service</Text>
        <TouchableOpacity
          style={styles.button}
          onPress={() => { track('consent_accepted'); navigation.replace('ModeSelection'); }}
          accessibilityRole="button"
          accessibilityLabel="I Agree"
        >
          <Text style={styles.buttonText}>I Agree</Text>
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: { flex: 1 },
  container: { flex: 1, padding: 24, justifyContent: 'center' },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 12, color: '#2C3E50', textAlign: 'center' },
  body: { color: '#2C3E50', textAlign: 'center', marginBottom: 12 },
  link: { color: '#4A90E2', textAlign: 'center', marginBottom: 8, textDecorationLine: 'underline' },
  button: { backgroundColor: '#4A90E2', borderRadius: 12, padding: 14, alignItems: 'center', marginTop: 8 },
  buttonText: { color: 'white', fontWeight: 'bold' }
});
```

---

## study-buddy/src/utils/analytics.ts
```ts
import Constants from 'expo-constants';
import { Platform } from 'react-native';
import { getAppConfig } from '@config/appConfig';

let posthog = null;

export const initAnalytics = async (): Promise<void> => {
  try {
    const { posthog: ph } = getAppConfig();
    const key = ph.apiKey;
    const host = ph.host;
    if (!key || !host) return;
    // Lazy import to avoid bundling if not set
    const { PostHog } = await import('posthog-react-native');
    posthog = new PostHog(key, { host, flushAt: 1 });
    await posthog.setup();
    posthog?.identify?.(undefined, { platform: Platform.OS });
  } catch {}
};

export const track = (event: string, props: Record<string, unknown> = {}): void => {
  try { posthog?.capture?.(event, props); } catch {}
};

export const flush = async (): Promise<void> => { try { await posthog?.flush?.(); } catch {} };
```

---

## study-buddy/src/utils/analytics/events.ts
```ts
import { track } from '@utils/analytics';

// Centralized, typed analytics events
export type EventsMap = {
  app_start: { version?: string };
  onboarding_complete: { ageGroup: string; buddyId?: string };
  consent_accepted: Record<string, never>;
  session_start: { subjectId: string; ageGroup: string };
  session_end: { duration: number; ageGroup: string; subjectId?: string };
  proof_photo_captured: { ageGroup: string; uri: string };
  notifications_permission: { status: string };
  purchase_success: { package?: string; price?: string };
  purchase_failed: { error: string };
  restore_success: Record<string, never>;
  restore_failed: { error: string };
};

export type EventName = keyof EventsMap;

export function trackTyped<E extends EventName>(event: E, payload: EventsMap[E]): void {
  track(event, payload as Record<string, unknown>);
}

// Convenience wrappers
export const Analytics = {
  sessionStart: (p: EventsMap['session_start']) => trackTyped('session_start', p),
  sessionEnd: (p: EventsMap['session_end']) => trackTyped('session_end', p),
  onboardingComplete: (p: EventsMap['onboarding_complete']) => trackTyped('onboarding_complete', p),
  consentAccepted: () => trackTyped('consent_accepted', {}),
  proofPhotoCaptured: (p: EventsMap['proof_photo_captured']) => trackTyped('proof_photo_captured', p),
  notificationsPermission: (p: EventsMap['notifications_permission']) => trackTyped('notifications_permission', p),
  purchaseSuccess: (p: EventsMap['purchase_success']) => trackTyped('purchase_success', p),
  purchaseFailed: (p: EventsMap['purchase_failed']) => trackTyped('purchase_failed', p),
  restoreSuccess: () => trackTyped('restore_success', {}),
  restoreFailed: (p: EventsMap['restore_failed']) => trackTyped('restore_failed', p),
};
```

---

## study-buddy/src/utils/permissions.ts
```ts
import { Alert, Platform } from 'react-native';
import * as Notifications from 'expo-notifications';
import { Camera } from 'expo-camera';
import { Audio } from 'expo-av';
import { trackTyped } from '@utils/analytics/events';

type PermissionResult = { granted: boolean; canAskAgain?: boolean };

export async function ensureNotificationPermission(): Promise<PermissionResult> {
  try {
    const existing = await Notifications.getPermissionsAsync();
    let status = existing.status;
    if (status !== 'granted') {
      await new Promise<void>((resolve) => {
        Alert.alert(
          'Notifications',
          'We use occasional check-ins to keep your child on track. You can change this anytime.',
          [
            { text: 'Not now', onPress: () => resolve() },
            { text: 'Continue', onPress: () => resolve() }
          ]
        );
      });
      const requested = await Notifications.requestPermissionsAsync();
      status = requested.status;
    }
    trackTyped('notifications_permission', { status });
    if (Platform.OS === 'android' && status === 'granted') {
      await Notifications.setNotificationChannelAsync('checkins', {
        name: 'Check-ins',
        importance: Notifications.AndroidImportance.DEFAULT,
        vibrationPattern: [0, 250, 250, 250],
        lightColor: '#FF231F7C',
      });
    }
    return { granted: status === 'granted', canAskAgain: existing.canAskAgain };
  } catch {
    return { granted: false };
  }
}

export async function ensureCameraPermission(): Promise<PermissionResult> {
  try {
    const existing = await Camera.getCameraPermissionsAsync();
    let status = existing.status;
    if (status !== 'granted') {
      const requested = await Camera.requestCameraPermissionsAsync();
      status = requested.status;
    }
    return { granted: status === 'granted', canAskAgain: existing.canAskAgain };
  } catch {
    return { granted: false };
  }
}

export async function ensureMicrophonePermission(): Promise<PermissionResult> {
  try {
    const existing = await Audio.getPermissionsAsync();
    let status = existing.status as Notifications.PermissionStatus | undefined;
    if (status !== 'granted') {
      const requested = await Audio.requestPermissionsAsync();
      status = requested.status as Notifications.PermissionStatus | undefined;
    }
    return { granted: status === 'granted', canAskAgain: existing.canAskAgain };
  } catch {
    return { granted: false };
  }
}
```

---

## study-buddy/src/utils/core/storageKeys.ts
```ts
import { z } from 'zod';
import { getStorageItem, setStorageItem, removeStorageItem } from '@utils/core/storage';

export const StorageKeys = {
  hasLaunched: 'hasLaunched',
  selectedAge: 'selectedAge',
  selectedBuddy: 'selectedBuddy',
  childName: 'childName',
  parentPin: 'parentPin',
  parentPinSetAt: 'parentPinSetAt',
  lastSessionLog: 'lastSessionLog',
  currentStreak: 'currentStreak',
  totalFocusTime: 'totalFocusTime',
  calmStreak: 'calmStreak',
  speechSettings: 'speechSettings',
  photoSettings: 'photoSettings',
  lastWorkPhoto: 'lastWorkPhoto',
  sessionsCount: 'sessionsCount',
  lastNotifAction: 'lastNotifAction',
  feedbackHistory: 'feedbackHistory',
  photoIndex: 'photoIndex',
} as const;

export type StorageKey = keyof typeof StorageKeys;

export async function getStringKey(key: StorageKey): Promise<string | null> {
  return getStorageItem(StorageKeys[key]);
}

export async function setStringKey(key: StorageKey, value: string): Promise<boolean> {
  return setStorageItem(StorageKeys[key], value);
}

export async function removeKey(key: StorageKey): Promise<boolean> {
  return removeStorageItem(StorageKeys[key]);
}

export async function getJson<T>(key: StorageKey, schema: z.ZodSchema<T>, fallback: T): Promise<T> {
  try {
    const raw = await getStorageItem(StorageKeys[key]);
    if (!raw) return fallback;
    const parsed = JSON.parse(raw);
    const result = schema.safeParse(parsed);
    if (!result.success) return fallback;
    return result.data;
  } catch {
    return fallback;
  }
}

export async function setJson<T>(key: StorageKey, value: T): Promise<boolean> {
  try {
    return await setStorageItem(StorageKeys[key], JSON.stringify(value));
  } catch {
    return false;
  }
}
```

---

## study-buddy/src/utils/purchases/index.ts
```ts
import { Platform } from 'react-native';
import Purchases from 'react-native-purchases';
import { getAppConfig } from '@config/appConfig';
import { Analytics, trackTyped } from '@utils/analytics/events';

export type PurchaseStatus = { isPremium: boolean };

const APP = getAppConfig();
const ENTITLEMENT_ID = APP.revenuecat?.entitlementId || 'premium';

export async function configurePurchases(): Promise<void> {
  const iosKey = APP.revenuecat?.iosApiKey || '';
  const androidKey = APP.revenuecat?.androidApiKey || '';
  const apiKey = Platform.select({ ios: iosKey, android: androidKey });
  if (!apiKey) return;
  await Purchases.configure({ apiKey });
}

export async function hasPremium(): Promise<PurchaseStatus> {
  try {
    const info = await Purchases.getCustomerInfo();
    return { isPremium: !!info?.entitlements?.active?.[ENTITLEMENT_ID] };
  } catch (e) {
    return { isPremium: false };
  }
}

export async function getCurrentOfferings() {
  return Purchases.getOfferings();
}

export async function purchasePackage(pkg: any): Promise<PurchaseStatus> {
  try {
    const { customerInfo } = await Purchases.purchasePackage(pkg);
    const isPremium = !!customerInfo?.entitlements?.active?.[ENTITLEMENT_ID];
    if (isPremium) {
      Analytics.purchaseSuccess({ package: pkg?.identifier, price: pkg?.product?.priceString });
    }
    return { isPremium };
  } catch (e: any) {
    if (!e?.userCancelled) {
      trackTyped('purchase_failed', { error: String(e) });
    }
    return { isPremium: false };
  }
}

export async function restore(): Promise<PurchaseStatus> {
  try {
    const info = await Purchases.restorePurchases();
    const isPremium = !!info?.entitlements?.active?.[ENTITLEMENT_ID];
    if (isPremium) Analytics.restoreSuccess();
    else trackTyped('restore_failed', { error: 'no_active' });
    return { isPremium };
  } catch (e) {
    trackTyped('restore_failed', { error: String(e) });
    return { isPremium: false };
  }
}
```

---

## study-buddy/src/utils/voice/speakWithBuddy.ts
```ts
import { smartSpeak } from '@utils/voice/speech';
import { resolveVoiceForBuddy } from '@utils/voice/voice';

type SpeakOptions = {
  screenType?: 'main' | 'calm' | 'celebration';
  forceSpeak?: boolean;
  language?: string;
};

export async function speakWithBuddy({
  buddy,
  ageGroup = 'elementary',
  text,
  options = {},
}: {
  buddy?: { personality?: string } | null;
  ageGroup?: 'young' | 'elementary' | 'tween' | 'teen';
  text: string;
  options?: SpeakOptions;
}): Promise<void> {
  const voice = await resolveVoiceForBuddy({ ageGroup, buddy: buddy || undefined });
  await smartSpeak(text, {
    screenType: options.screenType || 'main',
    forceSpeak: options.forceSpeak,
    language: voice.language,
    rate: voice.rate,
    pitch: voice.pitch,
    voice: voice.voice,
  });
}
```

---

## study-buddy/src/utils/feedback/index.ts
```ts
import * as Haptics from 'expo-haptics';
import { playSound } from '@utils/media/audio';

export type Impact = 'light' | 'medium' | 'heavy';

export async function impact(level: Impact = 'medium'): Promise<void> {
  const map = {
    light: Haptics.ImpactFeedbackStyle.Light,
    medium: Haptics.ImpactFeedbackStyle.Medium,
    heavy: Haptics.ImpactFeedbackStyle.Heavy,
  } as const;
  await Haptics.impactAsync(map[level]);
}

export async function success(): Promise<void> {
  await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
}

export async function warning(): Promise<void> {
  await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
}

export async function error(): Promise<void> {
  await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
}

export async function selection(): Promise<void> {
  await Haptics.selectionAsync();
}

export async function playClick(sound?: any): Promise<void> {
  // Optionally pass a short embedded sound; otherwise, haptics alone
  if (sound) {
    await playSound(sound);
  } else {
    await selection();
  }
}
```

---

## study-buddy/src/utils/media/index.ts
```ts
import { Camera } from 'expo-camera';
import { ensureCameraPermission } from '@utils/permissions';
import { savePhoto as savePhotoToDisk, cleanOldPhotos } from '@utils/media/photoManager';
import { getJson } from '@utils/core/storageKeys';
import { z } from 'zod';
import { Analytics } from '@utils/analytics/events';

type CameraRefLike = { takePictureAsync: (opts?: any) => Promise<{ uri: string }> } | null | undefined;

const PhotoSettingsSchema = z.object({
  autoDeleteDays: z.number().int().min(1).max(365).default(7),
  privacyOverlay: z.boolean().default(false),
});

export async function takeProofPhoto(cameraRef?: CameraRefLike, ageGroup: string = 'elementary'): Promise<string | null> {
  const perm = await ensureCameraPermission();
  if (!perm.granted) return null;

  // If a Camera ref is provided (screen-managed camera), capture using it
  if (cameraRef && typeof cameraRef.takePictureAsync === 'function') {
    const photo = await cameraRef.takePictureAsync();
    const saved = await savePhoto(photo.uri, ageGroup);
    return saved;
  }

  // Fallback: no ref provided — cannot capture without UI camera. Return null.
  return null;
}

export async function savePhoto(uri: string, ageGroup: string = 'elementary'): Promise<string> {
  // Respect privacy settings (overlay is a visual concern handled by UI; photos are stored locally only)
  const settings = await getJson('photoSettings' as any, PhotoSettingsSchema, { autoDeleteDays: 7, privacyOverlay: false });
  const savedUri = await savePhotoToDisk(uri);
  Analytics.proofPhotoCaptured({ ageGroup, uri: savedUri });
  // Opportunistic cleanup
  cleanOldPhotos().catch(() => {});
  return savedUri;
}

export { cleanOldPhotos };
```

---

## study-buddy/src/utils/scheduler/index.ts
```ts
import { AppState, AppStateStatus } from 'react-native';

type IntervalHandle = number;
type TimeoutHandle = number;

class Scheduler {
  private intervals = new Set<IntervalHandle>();
  private timeouts = new Set<TimeoutHandle>();
  private pauseOnBackground = new Set<IntervalHandle>();
  private appState: AppStateStatus = AppState.currentState;

  constructor() {
    AppState.addEventListener('change', this.onAppStateChange);
  }

  private onAppStateChange = (next: AppStateStatus) => {
    if (this.appState.match(/inactive|background/) && next === 'active') {
      // Resume intervals if needed (no-op; JS intervals continue). Could re-sync timers here.
    }
    if (next.match(/inactive|background/)) {
      // Clear intervals that opted-in to pause on background
      for (const id of Array.from(this.pauseOnBackground)) {
        clearInterval(id);
        this.intervals.delete(id);
        this.pauseOnBackground.delete(id);
      }
    }
    this.appState = next;
  };

  setInterval(callback: () => void, ms: number, options: { pauseOnBackground?: boolean } = {}): IntervalHandle {
    const id = setInterval(callback, ms) as unknown as number;
    this.intervals.add(id);
    if (options.pauseOnBackground) this.pauseOnBackground.add(id);
    return id;
  }

  clearInterval(id: IntervalHandle): void {
    clearInterval(id as any);
    this.intervals.delete(id);
    this.pauseOnBackground.delete(id);
  }

  setTimeout(callback: () => void, ms: number): TimeoutHandle {
    const id = setTimeout(callback, ms) as unknown as number;
    this.timeouts.add(id);
    return id;
  }

  clearTimeout(id: TimeoutHandle): void {
    clearTimeout(id as any);
    this.timeouts.delete(id);
  }

  clearAll(): void {
    for (const id of this.intervals) clearInterval(id as any);
    for (const id of this.timeouts) clearTimeout(id as any);
    this.intervals.clear();
    this.timeouts.clear();
    this.pauseOnBackground.clear();
  }
}

export const scheduler = new Scheduler();
```

---

## study-buddy/src/assets/registry.ts
```ts
export type AnimationName = 'studying' | 'celebrating' | 'idle' | 'encouraging' | 'confetti';

export function getAnimation(name: AnimationName) {
  switch (name) {
    case 'studying':
      return require('../assets/animations/studying.json');
    case 'celebrating':
      return require('../assets/animations/celebrating.json');
    case 'idle':
      return require('../assets/animations/idle.json');
    case 'encouraging':
      return require('../assets/animations/encouraging.json');
    case 'confetti':
      return require('../assets/animations/confetti.json');
    default:
      return require('../assets/animations/idle.json');
  }
}
```

---

## study-buddy/src/ui/tokens.ts
```ts
import { getAgeConfig } from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

export type Tokens = {
  colors: { primary: string; secondary: string; accent: string; text: string; muted: string; white: string };
  spacing: (n: number, age?: AgeGroup) => number;
  radius: (n?: number) => number;
  typography: { title: number; body: number; small: number };
};

export function useAgeTokens(ageGroup: AgeGroup = 'elementary'): Tokens {
  const cfg = getAgeConfig(ageGroup);
  const base = {
    colors: {
      primary: cfg.primaryColor || '#4A90E2',
      secondary: cfg.secondaryColor || '#F0F8FF',
      accent: cfg.accentColor || '#4A90E2',
      text: '#2C3E50',
      muted: '#7F8C8D',
      white: '#FFFFFF',
    },
    spacing: (n: number) => n * (cfg.buttonScale || 1.0) * 4,
    radius: (n: number = 10) => n,
    typography: {
      title: 24 * (cfg.fontSize || 1.0),
      body: 16 * (cfg.fontSize || 1.0),
      small: 12 * (cfg.fontSize || 1.0),
    },
  } as const;
  return base as Tokens;
}
```

---

## study-buddy/src/ui/components/Button.tsx
```tsx
import React from 'react';
import { TouchableOpacity, Text, StyleSheet } from 'react-native';
import type { AgeGroup } from '@types/index';
import { useAgeTokens } from '@ui/tokens';

type Props = { title: string; onPress: () => void; ageGroup?: AgeGroup; color?: string; style?: any };

export default function Button({ title, onPress, ageGroup = 'elementary', color, style }: Props) {
  const t = useAgeTokens(ageGroup);
  return (
    <TouchableOpacity style={[styles.btn, { backgroundColor: color || t.colors.primary, borderRadius: t.radius(16), paddingHorizontal: t.spacing(10), paddingVertical: t.spacing(5) }, style]} onPress={onPress} activeOpacity={0.85}>
      <Text style={[styles.txt, { color: t.colors.white, fontSize: t.typography.body * 1.1 }]}>{title}</Text>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  btn: { alignItems: 'center', justifyContent: 'center' },
  txt: { fontWeight: '700' },
});
```

---

## study-buddy/src/ui/components/Card.tsx
```tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import type { AgeGroup } from '@types/index';
import { useAgeTokens } from '@ui/tokens';

type Props = { children: React.ReactNode; ageGroup?: AgeGroup; style?: any };

export default function Card({ children, ageGroup = 'elementary', style }: Props) {
  const t = useAgeTokens(ageGroup);
  return (
    <View style={[styles.card, { backgroundColor: t.colors.white, borderRadius: t.radius(16), padding: t.spacing(6), shadowColor: '#000', shadowOpacity: 0.1, shadowRadius: 8, shadowOffset: { width: 0, height: 2 }, elevation: 5 }, style]}>
      {children}
    </View>
  );
}

const styles = StyleSheet.create({ card: {} });
```

---

## study-buddy/src/ui/components/ModalFrame.tsx
```tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import type { AgeGroup } from '@types/index';
import { useAgeTokens } from '@ui/tokens';

type Props = { children: React.ReactNode; ageGroup?: AgeGroup; style?: any };

export default function ModalFrame({ children, ageGroup = 'elementary', style }: Props) {
  const t = useAgeTokens(ageGroup);
  return (
    <View style={styles.backdrop}>
      <View style={[styles.content, { backgroundColor: t.colors.white, borderRadius: t.radius(20), padding: t.spacing(8) }, style]}>
        {children}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  backdrop: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.5)' },
  content: { width: '90%', maxWidth: 420, alignItems: 'center' },
});
```

---

## study-buddy/src/ui/alerts.ts
```ts
import { Alert } from 'react-native';

export function uiAlert(
  title: string,
  message?: string,
  buttons?: Array<{ text: string; onPress?: () => void; style?: 'default' | 'cancel' | 'destructive' }>
): void {
  try { Alert.alert(title, message, buttons); } catch {}
}

export function uiConfirm(title: string, message?: string, okText: string = 'OK', cancelText: string = 'Cancel'): Promise<boolean> {
  return new Promise((resolve) => {
    try {
      Alert.alert(title, message, [
        { text: cancelText, style: 'cancel', onPress: () => resolve(false) },
        { text: okText, onPress: () => resolve(true) },
      ]);
    } catch {
      resolve(false);
    }
  });
}
```

---

## study-buddy/src/utils/errors/index.ts
```ts
import * as Sentry from 'sentry-expo';

type ErrorContext = { ageGroup?: string; buddyId?: string; screen?: string; [k: string]: unknown };

export function captureError(error: unknown, context: ErrorContext = {}): void {
  try {
    Sentry.Native.captureException(error, { extra: context, tags: { screen: String(context.screen || '') } });
  } catch {}
}

export function captureMessage(message: string, context: ErrorContext = {}): void {
  try {
    Sentry.Native.captureMessage(message, { extra: context, tags: { screen: String(context.screen || '') } });
  } catch {}
}
```

---

## study-buddy/src/utils/nav/index.ts
```ts
import type { NavigationProp } from '@react-navigation/native';
import type { RootStackParamList } from '../../App';

export function navigateToCelebration(navigation: NavigationProp<RootStackParamList>, params: RootStackParamList['Celebration']): void {
  navigation.navigate('Celebration', params);
}

export function navigateToMain(navigation: NavigationProp<RootStackParamList>, params?: RootStackParamList['Main']): void {
  navigation.navigate('Main', params as any);
}

export function navigateToPaywall(navigation: NavigationProp<RootStackParamList>, params: RootStackParamList['Paywall']): void {
  navigation.navigate('Paywall', params);
}
```

---

## study-buddy/src/utils/adaptive/index.ts
```ts
import { getJson, setJson } from '@utils/core/storageKeys';
import { z } from 'zod';

type SubjectId = string;

type Model = {
  subjects: Record<SubjectId, { score: number; updatedAt: number }>;
  lastWeekStart?: string;
};

const Schema = z.object({
  subjects: z.record(z.object({ score: z.number(), updatedAt: z.number() })),
  lastWeekStart: z.string().optional(),
});

const DEFAULT_MODEL: Model = { subjects: {} };

function clamp(x: number, min = 0, max = 1) { return Math.max(min, Math.min(max, x)); }

export async function loadModel(): Promise<Model> {
  return await getJson('adaptiveModel' as any, Schema, DEFAULT_MODEL);
}

export async function saveModel(m: Model): Promise<void> {
  await setJson('adaptiveModel' as any, m);
}

// Update subject score: higher means easier for the child; lower means needs more support
// response values: 'easy'|'ok'|'hard'|'help'|'complete'|'most'|'half'|'started'
export async function recordInteraction(subjectId: string, response