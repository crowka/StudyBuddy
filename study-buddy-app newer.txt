## study-buddy/src/utils/notifications.ts
```ts
import * as Notifications from 'expo-notifications';
import { Alert, Platform } from 'react-native';
import { track } from '@utils/analytics';
import { t } from '@utils/intl/i18n';

export async function ensureNotificationsSetup(): Promise<void> {
  try {
    const { status: existingStatus } = await Notifications.getPermissionsAsync();
    let finalStatus = existingStatus;
    if (existingStatus !== 'granted') {
      try {
        await new Promise<void>((resolve) => {
          Alert.alert(
            t('notificationsPermissionTitle'),
            t('notificationsPermissionBody'),
            [
              { text: t('notNow'), onPress: () => resolve() },
              { text: t('continue'), onPress: () => resolve() }
            ]
          );
        });
      } catch {}
      const { status } = await Notifications.requestPermissionsAsync();
      finalStatus = status;
    }
    track('notifications_permission', { status: finalStatus });
    if (finalStatus !== 'granted') return;

    // Android: idempotent channel setup
    if (Platform.OS === 'android') {
      await Notifications.setNotificationChannelAsync('checkins', {
        name: t('checkinTitle'),
        importance: Notifications.AndroidImportance.DEFAULT,
        vibrationPattern: [0, 250, 250, 250],
        lightColor: '#FF231F7C',
      });
    }

    // iOS/Android: idempotent categories
    await Notifications.setNotificationCategoryAsync('checkin-actions', [
      { identifier: 'RESUME', buttonTitle: t('resume') },
      { identifier: 'BREAK', buttonTitle: t('break5') },
      { identifier: 'DONE', buttonTitle: t('imDone') },
    ]);
  } catch {}
}

export function extractActionIdFromResponse(response: Notifications.NotificationResponse | { actionIdentifier?: string }): string {
  return (response as any)?.actionIdentifier || '';
}
```

---

## study-buddy/src/utils/notificationsSchedule.ts
```ts
import type { AgeGroup } from '@types/index';
import { generatePeerLine } from '@utils/content/peerLines';
import { t } from '@utils/intl/i18n';

type BuildArgs = {
  ageGroup: AgeGroup;
  subjectId: string;
  sessionTime: number; // seconds elapsed at scheduling time
  intervalMs: number;  // base check-in interval in ms
  sessionLength: number; // seconds
  sessionId: string; // seed string (e.g., `${startTime}:${salt}`)
};

export function buildCheckInNotifications({
  ageGroup,
  subjectId,
  sessionTime,
  intervalMs,
  sessionLength,
  sessionId,
}: BuildArgs): Array<{ content: { title: string; body: string; categoryIdentifier: string }; trigger: { seconds: number } }> {
  const items = [1, 2, 3].map((i) => {
    const secondsOffset = Math.floor((intervalMs * i) / 1000);
    const seconds = sessionTime + secondsOffset;
    const body = generatePeerLine({
      ageGroup,
      subjectId: subjectId || 'other',
      seconds,
      sessionLength,
      context: 'backgroundReturn',
      sessionId,
    }).replace(/[^\w\s]/g, '');
    return {
      content: {
        title: t('checkinTitle'),
        body,
        categoryIdentifier: 'checkin-actions',
      },
      trigger: { seconds: Math.max(5, secondsOffset) },
    };
  });
  return items;
}
```

---

## study-buddy/src/utils/notifications.test.ts
```ts
import * as Notifications from 'expo-notifications';
import { ensureNotificationsSetup } from './notifications';

describe('notifications setup', () => {
  it('creates channel and category when granted', async () => {
    jest.spyOn(Notifications, 'getPermissionsAsync' as any).mockResolvedValueOnce({ status: 'granted' } as any);
    const channelSpy = jest.spyOn(Notifications, 'setNotificationChannelAsync' as any).mockResolvedValueOnce(undefined as any);
    const categorySpy = jest.spyOn(Notifications, 'setNotificationCategoryAsync' as any).mockResolvedValueOnce(undefined as any);

    await ensureNotificationsSetup();

    expect(categorySpy).toHaveBeenCalled();
    // Android-only channel may not be called on CI; assert category at minimum

    channelSpy.mockRestore();
    categorySpy.mockRestore();
  });
});
```

---

## study-buddy/scripts/check-config.js
```javascript
// Minimal runtime guard to ensure production config is present
const assert = (cond, msg) => { if (!cond) { console.error(msg); process.exit(1); } };

try {
  const Constants = require('expo-constants').default;
  const extra = (Constants?.manifest?.extra || {});
  const ph = extra?.posthog || {};
  const rc = extra?.revenuecat || {};
  const sentry = extra?.sentry || {};

  const isCI = process.env.CI === 'true' || process.env.GITHUB_ACTIONS === 'true';
  const isProd = process.env.APP_ENV === 'production' || process.env.NODE_ENV === 'production';

  if (isCI && isProd) {
    assert(!!ph.apiKey && !!ph.host, 'PostHog config missing in production');
    assert(!!rc.iosApiKey || !!rc.androidApiKey, 'RevenueCat API key missing in production');
    assert(typeof rc.entitlementId === 'string' && rc.entitlementId.length > 0, 'RevenueCat entitlementId missing');
    assert(typeof sentry.dsn === 'string' && sentry.dsn.length > 0, 'Sentry DSN missing in production');
  }

  console.log('Config check passed.');
  process.exit(0);
} catch (e) {
  console.error('Config check failed:', e?.message || e);
  process.exit(1);
}
```

## study-buddy/src/utils/config/appConfig.ts
```ts
import Constants from 'expo-constants';
import { z } from 'zod';

export type AppConfig = {
  revenuecat: { iosApiKey: string; androidApiKey: string; entitlementId: string };
  manageSubscriptions: { ios: string; android: string };
  sentry: { dsn: string };
  posthog: { apiKey: string; host: string };
  remote: { paywall: { sessionsTillPaywall: number; variants: Record<string, number> }; surprise: { frequencyMultiplier: number } };
  urls: { privacyPolicy: string; termsOfService: string; support: string };
};

export function getAppConfig(): AppConfig {
  const extra: any = (Constants?.manifest?.extra || {});
  const AppConfigSchema = z.object({
    revenuecat: z.object({
      iosApiKey: z.string().optional().default(''),
      androidApiKey: z.string().optional().default(''),
      entitlementId: z.string().optional().default('premium')
    }).optional().default({ iosApiKey: '', androidApiKey: '', entitlementId: 'premium' }),
    manageSubscriptions: z.object({
      ios: z.string().optional().default('itms-apps://apps.apple.com/account/subscriptions'),
      android: z.string().optional().default('https://play.google.com/store/account/subscriptions')
    }).optional().default({ ios: 'itms-apps://apps.apple.com/account/subscriptions', android: 'https://play.google.com/store/account/subscriptions' }),
    sentry: z.object({ dsn: z.string().optional().default('') }).optional().default({ dsn: '' }),
    posthog: z.object({ apiKey: z.string().optional().default(''), host: z.string().optional().default('') }).optional().default({ apiKey: '', host: '' }),
    remote: z.object({
      paywall: z.object({
        sessionsTillPaywall: z.number().int().min(1).max(10).default(3),
        variants: z.record(z.number()).default({ A: 1 })
      }).default({ sessionsTillPaywall: 3, variants: { A: 1 } }),
      surprise: z.object({ frequencyMultiplier: z.number().min(0).max(3).default(1.0) }).default({ frequencyMultiplier: 1.0 })
    }).optional().default({ paywall: { sessionsTillPaywall: 3, variants: { A: 1 } }, surprise: { frequencyMultiplier: 1.0 } }),
    urls: z.object({
      privacyPolicy: z.string().optional().default('https://example.com/privacy'),
      termsOfService: z.string().optional().default('https://example.com/terms'),
      support: z.string().optional().default('https://example.com/support')
    }).optional().default({ privacyPolicy: 'https://example.com/privacy', termsOfService: 'https://example.com/terms', support: 'https://example.com/support' })
  });

  const parsed = AppConfigSchema.safeParse(extra);
  if (!parsed.success) {
    try { console.warn('Invalid AppConfig; using defaults', parsed.error.format()); } catch {}
  }
  const data = parsed.success ? parsed.data : AppConfigSchema.parse({});
  return data as AppConfig;
}
```

## study-buddy/src/types/index.ts
```ts
export type AgeGroup = 'young' | 'elementary' | 'tween' | 'teen';

export interface Subject {
  id: string;
  label: string;
  emoji: string;
  category: string;
  difficulty: 'easy' | 'medium' | 'hard';
  checkIns: string[];
}

export interface Buddy {
  id: string;
  name: string;
  emoji: string;
  color: string;
  personality: string;
  sounds?: string[];
  animationStyle?: string;
  description?: string;
}

export interface VoiceConfig {
  language: string;
  rate: number;
  pitch: number;
  voice?: string;
}

export interface ParentGate {
  question: string;
  answer: string;
}

export interface AgeConfig {
  id: AgeGroup;
  displayRange: string;
  sessionLength: number; // seconds
  breakDuration: number; // seconds
  checkInFrequency: number; // minutes
  interactionFrequency: number; // minutes
  voicePitch: number;
  voiceRate: number;
  primaryColor: string;
  secondaryColor?: string;
  accentColor?: string;
  startMessage?: string;
  welcomeBackMessage?: string;
  completionMessage?: string;
  streakLabel?: string;
  statsLabel?: string;
  [key: string]: unknown;
}

export interface SessionLogEntry {
  time: number; // seconds
  question: string;
  response: string;
  timestamp: string; // ISO
}

export interface GeneratePeerLineInput {
  ageGroup: AgeGroup;
  buddyPersonality?: string;
  subjectId: string;
  seconds: number;
  sessionLength: number;
  context?: 'tick' | 'backgroundReturn';
  sessionId?: string;
}

// React Navigation augmentation (global)
import type { RootStackParamList } from '../App';
declare global {
  namespace ReactNavigation {
    interface RootParamList extends RootStackParamList {}
  }
}
```

# Study Buddy - Complete App Structure (Modular Architecture)

## Project Structure Overview
```
study-buddy/
‚îú‚îÄ‚îÄ app.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ babel.config.js
‚îú‚îÄ‚îÄ App.tsx
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îî‚îÄ‚îÄ check-config.js
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OnboardingScreen.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ModeSelectionScreen.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MainScreen.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CalmModeScreen.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ParentSettingsScreen.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CelebrationScreen.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaywallScreen.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ConsentScreen.tsx
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BuddyCharacter.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StudyTimer.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CheckInMessage.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BigButton.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ScreenBackground.tsx
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storage.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ storageKeys.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ constants.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ content/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ peerLines.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ intl/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ i18n.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ media/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ audio.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ photoManager.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ voice/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ speech.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ voice.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ analytics/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ events.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ purchases/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errors/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nav/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scheduler/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ animations/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ buddy-animations.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ confetti.json
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ studying.json
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ celebrating.json
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ idle.json
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encouraging.json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ icons/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ icon.png
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ adaptive-icon.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ splash.png
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ favicon.png
‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tokens.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ alerts.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Button.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Card.tsx
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ModalFrame.tsx
‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ       ‚îî‚îÄ‚îÄ index.ts
‚îî‚îÄ‚îÄ README.md
```

---

## study-buddy/package.json
```json
{
  "name": "study-buddy",
  "version": "1.0.0",
  "main": "node_modules/expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "check:config": "node ./scripts/check-config.js",
    "postinstall": "npx expo install --fix || true",
    "test": "jest",
    "test:e2e:ios": "detox test -c ios.sim.debug",
    "test:e2e:android": "detox test -c android.emu.debug"
  },
  "dependencies": {
    "expo": "~53.0.0",
    "expo-status-bar": "~1.6.0",
    "expo-av": "~13.4.1",
    "expo-speech": "~11.3.0",
    "expo-haptics": "~12.4.0",
    "expo-keep-awake": "~12.3.0",
    "expo-camera": "~13.4.0",
    "expo-local-authentication": "~13.4.0",
    "expo-crypto": "~12.6.0",
    "react": "19.0.0",
    "react-native": "0.79.0",
    "@react-navigation/native": "^6.1.7",
    "@react-navigation/stack": "^6.3.17",
    "react-native-safe-area-context": "4.6.3",
    "react-native-screens": "~3.22.0",
    "react-native-gesture-handler": "~2.12.0",
    "@react-native-async-storage/async-storage": "1.18.2",
    "lottie-react-native": "^6.0.0",
    "react-native-svg": "13.9.0",
    "expo-notifications": "~0.20.1",
    "react-native-reanimated": "~3.3.0",
    "react-native-purchases": "^7.0.0",
    "@react-native-community/slider": "4.4.2",
    "expo-localization": "~14.2.1",
    "expo-file-system": "~15.4.5",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "jest": "^29.7.0",
    "jest-expo": "~53.0.0",
    "@types/jest": "^29.5.12",
    "detox": "^20.0.0"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "private": true
}
```

---

## study-buddy/src/utils/notifications.errors.test.ts
```ts
import * as Notifications from 'expo-notifications';
import { ensureNotificationsSetup } from './notifications';

describe('notifications error paths', () => {
  beforeEach(() => {
    jest.resetAllMocks();
  });

  it('permission denied path exits without throwing', async () => {
    jest.spyOn(Notifications, 'getPermissionsAsync' as any).mockResolvedValueOnce({ status: 'denied' } as any);
    await expect(ensureNotificationsSetup()).resolves.toBeUndefined();
  });

  it('channel/category throw is caught and does not crash', async () => {
    jest.spyOn(Notifications, 'getPermissionsAsync' as any).mockResolvedValueOnce({ status: 'granted' } as any);
    jest.spyOn(Notifications, 'setNotificationChannelAsync' as any).mockRejectedValueOnce(new Error('channel-fail'));
    jest.spyOn(Notifications, 'setNotificationCategoryAsync' as any).mockRejectedValueOnce(new Error('category-fail'));
    await expect(ensureNotificationsSetup()).resolves.toBeUndefined();
  });
});
```

---

## study-buddy/src/utils/voice/speech-errors.test.ts
```ts
import * as Speech from 'expo-speech';
import { smartSpeak } from '@utils/voice/speech';

describe('smartSpeak error paths', () => {
  it('survives isSpeakingAsync rejection', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockResolvedValue(undefined as any);
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => {} as any);
    const isSpeakingSpy = jest.spyOn(Speech, 'isSpeakingAsync' as any).mockRejectedValueOnce(new Error('fail'));
    await expect(smartSpeak('hello', { forceSpeak: true })).resolves.toBeUndefined();
    stopSpy.mockRestore();
    speakSpy.mockRestore();
    isSpeakingSpy.mockRestore();
  });

  it('survives stop/speak rejections', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockRejectedValueOnce(new Error('fail'));
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => { throw new Error('speak-fail'); });
    const isSpeakingSpy = jest.spyOn(Speech, 'isSpeakingAsync' as any).mockResolvedValue(false as any);
    await expect(smartSpeak('hello', { forceSpeak: true })).resolves.toBeUndefined();
    stopSpy.mockRestore();
    speakSpy.mockRestore();
    isSpeakingSpy.mockRestore();
  });
});
```

---
## study-buddy/src/screens/__tests__/parentGate.test.ts
```ts
import { generateParentGate } from '@utils/config/constants';

describe('Parent gate generation', () => {
  it('generates valid question/answer for age template', () => {
    const gate = generateParentGate({ parentGate: { minNumber: 10, maxNumber: 30, operation: 'addition' } as any });
    expect(gate.question).toMatch(/What|\?|\d+/);
    expect(gate.answer).toMatch(/^\d+$/);
  });
});
```

---

## study-buddy/src/utils/config/appConfig.test.ts
```ts
import { getAppConfig } from '@config/appConfig';

describe('AppConfig URLs and manage subscriptions', () => {
  it('provides well-formed default URLs', () => {
    const cfg = getAppConfig();
    expect(cfg.urls.privacyPolicy).toMatch(/^https?:\/\//);
    expect(cfg.urls.termsOfService).toMatch(/^https?:\/\//);
    expect(cfg.urls.support).toMatch(/^https?:\/\//);
    expect(cfg.manageSubscriptions.ios).toMatch(/itms-apps:\/\//);
    expect(cfg.manageSubscriptions.android).toMatch(/^https?:\/\//);
  });
});
```

---

## study-buddy/src/screens/__tests__/purchases.test.ts
```ts
import Purchases from 'react-native-purchases';

describe('Purchases error handling', () => {
  it('configure/getCustomerInfo failures do not crash', async () => {
    const configureSpy = jest.spyOn(Purchases, 'configure' as any).mockRejectedValueOnce(new Error('fail'));
    const infoSpy = jest.spyOn(Purchases, 'getCustomerInfo' as any).mockRejectedValueOnce(new Error('fail'));
    // Minimal expectation: spies called, no throw here (actual App.tsx flow depends on runtime)
    await expect(Purchases.configure({ apiKey: 'x' } as any)).rejects.toThrow();
    await expect(Purchases.getCustomerInfo()).rejects.toThrow();
    configureSpy.mockRestore();
    infoSpy.mockRestore();
  });
});
```

---

## study-buddy/src/utils/voice/speech-disabled.test.ts
```ts
import * as Speech from 'expo-speech';
import { smartSpeak } from '@utils/voice/speech';

describe('smartSpeak screen disabled', () => {
  it('does not speak when screen disabled (no force)', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockResolvedValue(undefined as any);
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => {} as any);
    // Temporarily mock load settings to disable main screen
    const mod = await import('@utils/voice/speech');
    (mod as any).loadSpeechSettings = async () => ({ mainScreenEnabled: false, calmModeEnabled: true, celebrationEnabled: true, rate: 1, pitch: 1 });
    await smartSpeak('hello', { screenType: 'main' });
    expect(speakSpy).not.toHaveBeenCalled();
    stopSpy.mockRestore();
    speakSpy.mockRestore();
  });
});
```

---

## study-buddy/src/utils/media/photoPermissions.test.ts
```ts
import { ensureCameraPermission } from '@utils/permissions';
import * as CameraMod from 'expo-camera';

describe('Camera permission', () => {
  it('denied permission returns granted=false', async () => {
    jest.spyOn(CameraMod.Camera, 'getCameraPermissionsAsync' as any).mockResolvedValueOnce({ granted: false } as any);
    jest.spyOn(CameraMod.Camera, 'requestCameraPermissionsAsync' as any).mockResolvedValueOnce({ granted: false } as any);
    const res = await ensureCameraPermission();
    expect(res.granted).toBe(false);
  });
});
```

## study-buddy/src/utils/notificationsSchedule.test.ts
```ts
import { buildCheckInNotifications } from './notificationsSchedule';

describe('buildCheckInNotifications', () => {
  it('produces 3 scheduled notifications with increasing triggers', () => {
    const intervalMs = 6000; // 6s for test profile
    const out = buildCheckInNotifications({
      ageGroup: 'tween',
      subjectId: 'science',
      sessionTime: 120, // 2 min elapsed
      intervalMs,
      sessionLength: 1200,
      sessionId: 'seed-123',
    });
    expect(out).toHaveLength(3);
    expect(out[0].trigger.seconds).toBeGreaterThan(0);
    expect(out[1].trigger.seconds).toBeGreaterThan(out[0].trigger.seconds);
    expect(out[2].trigger.seconds).toBeGreaterThan(out[1].trigger.seconds);
    expect(out[0].content.title).toBe('Study Buddy');
    expect(typeof out[0].content.body).toBe('string');
    expect(out[0].content.body.length).toBeGreaterThan(0);
  });
});
```

---

## study-buddy/app.json
```json
{
  "expo": {
    "name": "Study Buddy",
    "slug": "study-buddy",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./src/assets/icons/icon.png",
    "userInterfaceStyle": "light",
    "runtimeVersion": { "policy": "sdkVersion" },
    "splash": {
      "image": "./src/assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#4A90E2"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.focusflow.studybuddy",
      "buildNumber": "1",
      "infoPlist": {
        "NSMicrophoneUsageDescription": "Study Buddy needs microphone access to record encouraging messages.",
        "NSCameraUsageDescription": "Study Buddy uses the camera to take an optional photo of completed homework.",
        "NSPhotoLibraryAddUsageDescription": "Study Buddy saves homework photos to your device only.",
        "UIFileSharingEnabled": false,
        "LSSupportsOpeningDocumentsInPlace": false
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./src/assets/icons/adaptive-icon.png",
        "backgroundColor": "#4A90E2"
      },
      "package": "com.focusflow.studybuddy",
      "versionCode": 1,
      "permissions": ["RECORD_AUDIO", "VIBRATE", "CAMERA", "POST_NOTIFICATIONS"]
    },
    "web": {
      "favicon": "./src/assets/favicon.png"
    },
    "plugins": [
      ["sentry-expo"]
    ],
    "extra": {
      "eas": {
        "projectId": "your-project-id"
      },
      "revenuecat": {
        "iosApiKey": "REPLACE_WITH_REVENUECAT_IOS_API_KEY",
        "androidApiKey": "REPLACE_WITH_REVENUECAT_ANDROID_API_KEY",
        "entitlementId": "premium"
      },
      "manageSubscriptions": {
        "ios": "itms-apps://apps.apple.com/account/subscriptions",
        "android": "https://play.google.com/store/account/subscriptions?package=com.focusflow.studybuddy"
      },
      "sentry": {
        "dsn": "REPLACE_WITH_SENTRY_DSN"
      },
      "posthog": {
        "apiKey": "REPLACE_WITH_POSTHOG_API_KEY",
        "host": "https://us.i.posthog.com"
      },
      "remote": {
        "paywall": { "sessionsTillPaywall": 3, "variants": { "A": 0.5, "B": 0.5 } },
        "surprise": { "frequencyMultiplier": 1.0 }
      },
      "urls": {
        "privacyPolicy": "https://example.com/privacy",
        "termsOfService": "https://example.com/terms",
        "support": "https://example.com/support"
      }
    }
  }
}
```

---

## study-buddy/babel.config.js
```javascript
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      ['module-resolver', {
        root: ['./'],
        alias: {
          '@screens': './src/screens',
          '@components': './src/components',
          '@utils': './src/utils',
          '@assets': './src/assets',
          '@config': './src/utils/config',
          '@config/*': './src/utils/config/*',
          '@content': './src/utils/content',
          '@types': './src/types',
          '@ui': './src/ui',
          '@ui/*': './src/ui/*'
        },
        extensions: ['.ts', '.tsx', '.js', '.json']
      }],
      'react-native-reanimated/plugin' // must be last
    ]
  };
};
```

---

## study-buddy/tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2019",
    "module": "ESNext",
    "jsx": "react-native",
    "strict": true,
    "noImplicitAny": true,
    "moduleResolution": "node",
    "allowJs": false,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@screens/*": ["src/screens/*"],
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"],
      "@assets/*": ["src/assets/*"],
      "@config": ["src/utils/config"],
      "@config/*": ["src/utils/config/*"],
      "@content/*": ["src/utils/content/*"],
      "@types/*": ["src/types/*"],
      "@ui": ["src/ui"],
      "@ui/*": ["src/ui/*"]
    }
  }
}
```

---

## study-buddy/.github/workflows/ci.yml
```yaml
name: CI

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]

jobs:
  unit-tests:
    name: Split project and run unit tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Split consolidated app into project files
        run: |
          cd "apps/get-rich-game/docs/study buddy"
          python3 ./split_study_buddy.py --create

      - name: Install dependencies
        run: |
          cd "apps/get-rich-game/docs/study buddy/study-buddy"
          npm ci

      - name: Run unit tests (Jest)
        run: |
          cd "apps/get-rich-game/docs/study buddy/study-buddy"
          npm run test -- --ci
```

---

## study-buddy/.github/workflows/build.yml
```yaml
name: Build (EAS)

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*.*.*'

jobs:
  build-ios:
    runs-on: macos-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest

      - name: Split consolidated app
        run: |
          cd "apps/get-rich-game/docs/study buddy"
          python3 ./split_study_buddy.py --create

      - name: Install deps
        run: |
          cd "apps/get-rich-game/docs/study buddy/study-buddy"
          npm ci

      - name: EAS build iOS
        working-directory: apps/get-rich-game/docs/study buddy/study-buddy
        env:
          EAS_TOKEN: ${{ secrets.EAS_TOKEN }}
        run: |
          eas build --platform ios --non-interactive --profile production

  build-android:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest

      - name: Split consolidated app
        run: |
          cd "apps/get-rich-game/docs/study buddy"
          python3 ./split_study_buddy.py --create

      - name: Install deps
        run: |
          cd "apps/get-rich-game/docs/study buddy/study-buddy"
          npm ci

      - name: EAS build Android
        working-directory: apps/get-rich-game/docs/study buddy/study-buddy
        env:
          EAS_TOKEN: ${{ secrets.EAS_TOKEN }}
        run: |
          eas build --platform android --non-interactive --profile production
```

---

## study-buddy/App.tsx
```tsx
import React, { useState, useEffect, createContext } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { StatusBar } from 'expo-status-bar';
import * as KeepAwake from 'expo-keep-awake';
import * as Notifications from 'expo-notifications';
import { Platform, View, Text, Alert } from 'react-native';
import Purchases from 'react-native-purchases';
import Constants from 'expo-constants';
import * as Sentry from 'sentry-expo';
import { initAnalytics, track } from '@utils/analytics';
import { ensureNotificationPermission } from '@utils/permissions';
import { extractActionIdFromResponse } from '@utils/notifications';
import { getAppConfig } from '@config/appConfig';

import OnboardingScreen from '@screens/OnboardingScreen';
import ModeSelectionScreen from '@screens/ModeSelectionScreen';
import MainScreen from '@screens/MainScreen';
import CalmModeScreen from '@screens/CalmModeScreen';
import ParentSettingsScreen from '@screens/ParentSettingsScreen';
import CelebrationScreen from '@screens/CelebrationScreen';
import PaywallScreen from '@screens/PaywallScreen';
import ConsentScreen from '@screens/ConsentScreen';
import { getStorageItem, setStorageItem } from '@utils/core/storage';
import { getStringKey, setStringKey } from '@utils/core/storageKeys';
import { initializeLanguage } from '@utils/intl/i18n';
import { cleanOldPhotos } from '@utils/media/photoManager';

const APP_CONFIG = getAppConfig();
Sentry.init({
  dsn: APP_CONFIG.sentry.dsn,
  enableInExpoDevelopment: true,
  debug: __DEV__,
});

class ErrorBoundary extends React.Component<{ children: React.ReactNode }, { hasError: boolean }>{
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  componentDidCatch(error, errorInfo) {
    this.setState({ hasError: true });
    Sentry.Native.captureException(error, { extra: errorInfo });
  }
  render() {
    if (this.state.hasError) {
      return (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
          <Text style={{ fontSize: 40 }}>üò¢</Text>
          <Text>Oops! Your buddy needs a quick break.</Text>
        </View>
      );
    }
    return this.props.children as any;
  }
}

export type RootStackParamList = {
  Onboarding: undefined;
  ModeSelection: undefined;
  Main: { selectedSubject?: { id: string; label: string }; quickStart?: { workMinutes?: number; breakMinutes?: number } } | undefined;
  CalmMode: undefined;
  ParentSettings: { sessionLog?: unknown[] } | undefined;
  Celebration: { sessionTime: number; totalTime: number; streak: number; ageGroup: string; workPhoto?: string | null; sessionLog: unknown[]; tokenAward?: number };
  Paywall: { ageGroup: string };
  Consent: undefined;
};

const Stack = createStackNavigator<RootStackParamList>();

export interface SubscriptionContextValue {
  isPremium: boolean;
  checkPremiumStatus: () => Promise<void> | void;
}

export const SubscriptionContext = createContext<SubscriptionContextValue>({
  isPremium: false,
  checkPremiumStatus: () => {},
});

export default function App(): JSX.Element {
  const [isFirstLaunch, setIsFirstLaunch] = useState<boolean | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [isPremium, setIsPremium] = useState<boolean>(false);

  useEffect(() => {
    runMigrations();
    checkFirstLaunch();
    KeepAwake.activateKeepAwakeAsync();
    ensureNotificationPermission();
    initializeLanguage();
    cleanOldPhotos();
    initializeRevenueCat();
    initAnalytics();

    const sub = Notifications.addNotificationResponseReceivedListener(async (response) => {
      try {
        const actionId = extractActionIdFromResponse(response);
        await setStorageItem('lastNotifAction', actionId || '');
      } catch (e) {}
    });
    return () => sub.remove();
  }, []);

  const initializeRevenueCat = async () => {
    try {
      const iosKey = APP_CONFIG.revenuecat.iosApiKey;
      const androidKey = APP_CONFIG.revenuecat.androidApiKey;
      const apiKey = Platform.select({ ios: iosKey, android: androidKey });
      if (apiKey) {
        await Purchases.configure({ apiKey });
        await checkPremiumStatus();
      }
    } catch {}
  };

  const checkPremiumStatus = async () => {
    try {
      const customerInfo = await Purchases.getCustomerInfo();
      const extra = (Constants?.manifest?.extra as any) || {};
      const entitlementId = extra?.revenuecat?.entitlementId || 'premium';
      setIsPremium(customerInfo.entitlements.active[entitlementId] !== undefined);
    } catch {}
  };

  // notifications moved to @utils/notifications

  const checkFirstLaunch = async () => {
    const hasLaunched = await getStorageItem('hasLaunched');
    setIsFirstLaunch(!hasLaunched);
    setIsLoading(false);
  };

  // Simple storage schema migration harness
  const runMigrations = async (): Promise<void> => {
    try {
      const VERSION_KEY = 'storageVersion' as any;
      const current = await getStringKey(VERSION_KEY);
      const ver = current ? parseInt(current) : 0;
      // v1 example: ensure streak keys exist with sane defaults
      if (ver < 1) {
        const streak = await getStringKey('currentStreak' as any);
        if (streak === null) await setStringKey('currentStreak' as any, '0');
        const total = await getStringKey('totalFocusTime' as any);
        if (total === null) await setStringKey('totalFocusTime' as any, '0');
        await setStringKey(VERSION_KEY, '1');
      }
      // future migrations go here
    } catch {}
  };

  if (isLoading) return null;

  // Gate production if critical config missing
  if (!__DEV__) {
    const ph = APP_CONFIG.posthog;
    const rc = APP_CONFIG.revenuecat;
    const sentryCfg = APP_CONFIG.sentry;
    const missing = !ph.apiKey || !ph.host || (!(rc.iosApiKey || rc.androidApiKey)) || !sentryCfg.dsn;
    if (missing) {
      return (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', padding: 24 }}>
          <Text style={{ fontSize: 22, fontWeight: 'bold', marginBottom: 8 }}>Configuration Required</Text>
          <Text style={{ textAlign: 'center', color: '#2C3E50' }}>
            Missing analytics, error reporting, or purchase configuration. Please update app settings and relaunch.
          </Text>
        </View>
      );
    }
  }

  return (
    <SubscriptionContext.Provider value={{ isPremium, checkPremiumStatus }}>
      <ErrorBoundary>
        <NavigationContainer>
          <StatusBar style="dark" />
          <Stack.Navigator screenOptions={{ headerShown: false, gestureEnabled: false }}>
            {isFirstLaunch ? (
              <Stack.Screen name="Onboarding" component={OnboardingScreen} />
            ) : null}
            <Stack.Screen name="ModeSelection" component={ModeSelectionScreen} />
            <Stack.Screen name="Main" component={MainScreen} />
            <Stack.Screen name="CalmMode" component={CalmModeScreen} />
            <Stack.Screen name="ParentSettings" component={ParentSettingsScreen} />
            <Stack.Screen name="Celebration" component={CelebrationScreen} />
            <Stack.Screen name="Paywall" component={PaywallScreen} options={{ presentation: 'modal' }} />
            <Stack.Screen name="Consent" component={ConsentScreen} />
          </Stack.Navigator>
        </NavigationContainer>
      </ErrorBoundary>
    </SubscriptionContext.Provider>
  );
}
```

---

## study-buddy/src/utils/config/constants.ts
```ts
import { Dimensions } from 'react-native';
import type { AgeGroup, AgeConfig, ParentGate, Subject } from '@types/index';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

// ===================================
// MODULAR CONFIGURATION SYSTEM
// Single source of truth for all app behavior
// ===================================

// === CORE TIMING CONFIGURATION ===
export const TIMING_CONFIG = {
  // Animation durations (milliseconds)
  animations: {
    fadeIn: 500,
    slideUp: 300,
    breathingIn: 4000,
    breathingOut: 4000,
    buttonPress: 100,
    celebrationDisplay: 3000,
  },
  
  // Session timings (milliseconds)
  session: {
    buddyFadeDelay: 60 * 1000, // 1 minute before buddy fades
    checkInDisplay: 5 * 1000, // How long check-in messages show
    modalTimeout: 30 * 1000, // Auto-pause if no interaction
    breathingCycle: 8 * 1000, // Calm mode breathing cycle
  },
  
  // Intervals (seconds - converted to ms in usage)
  intervals: {
    liveActivityUpdate: 30, // Update "X kids studying" counter
    progressSave: 60, // Auto-save progress
  }
};

// === RESPONSIVE UI SCALING ===
export const UI_SCALING_CONFIG = {
  // Screen size breakpoints
  breakpoints: {
    small: 350,   // iPhone SE
    medium: 414,  // Standard phones
    large: 768,   // Tablets
    xlarge: 1024  // Large tablets
  },
  
  // Age-based scaling multipliers
  ageScaling: {
    young: { 
      buddySize: 1.2,     // 20% larger buddy
      fontSize: 1.3,     // 30% larger text
      buttonScale: 1.2,   // 20% larger buttons
      spacing: 1.2,       // 20% more spacing
      iconSize: 1.4       // 40% larger icons
    },
    elementary: { 
      buddySize: 1.0,     // Base size
      fontSize: 1.0,     // Base text
      buttonScale: 1.0,   // Base buttons
      spacing: 1.0,       // Base spacing
      iconSize: 1.0       // Base icons
    },
    tween: { 
      buddySize: 0.85,    // 15% smaller buddy
      fontSize: 0.95,    // 5% smaller text
      buttonScale: 0.95,  // 5% smaller buttons
      spacing: 0.9,       // 10% less spacing
      iconSize: 0.9       // 10% smaller icons
    },
    teen: { 
      buddySize: 0.7,     // 30% smaller buddy
      fontSize: 0.85,    // 15% smaller text
      buttonScale: 0.9,   // 10% smaller buttons
      spacing: 0.8,       // 20% less spacing
      iconSize: 0.8       // 20% smaller icons
    }
  },
  
  // Base sizes (scaled by age and screen)
  baseSizes: {
    buddySize: 180,
    buttonHeight: 60,
    iconSize: 24,
    borderRadius: 15,
    shadowRadius: 8
  }
};

// === MODULAR AGE GROUP DATA ===
// All age-specific behavior controlled from here
const AGE_GROUP_TEMPLATES = {
  young: {
    id: 'young',
    ageRange: [5, 7],
    displayRange: '5-7',
    
    // Session defaults (minutes)
    session: {
      defaultDuration: 10,
      breakDuration: 3,
      checkInFrequency: 2,
      interactionFrequency: 15,
      maxDuration: 20
    },
    
    // Voice configuration
    voice: {
      pitch: 1.3,
      rate: 0.8,
      volume: 1.0
    },
    
    // Visual theme
    theme: {
      primary: '#FFB6C1',
      secondary: '#FFE4E1',
      accent: '#FF69B4',
      background: '#FFF8F9'
    },
    
    // Content personality
    personality: {
      encouragementLevel: 'high',    // high, medium, low
      celebrationStyle: 'enthusiastic', // enthusiastic, balanced, cool, minimal
      languageComplexity: 'simple', // simple, moderate, advanced, mature
      emojiUsage: 'frequent'        // frequent, moderate, minimal, none
    },
    
    // Parent gate (math difficulty)
    parentGate: {
      minNumber: 1,
      maxNumber: 10,
      operation: 'addition'
    }
  },
  
  elementary: {
    id: 'elementary',
    ageRange: [8, 10],
    displayRange: '8-10',
    
    session: {
      defaultDuration: 15,
      breakDuration: 5,
      checkInFrequency: 5,
      interactionFrequency: 20,
      maxDuration: 30
    },
    
    voice: {
      pitch: 1.1,
      rate: 0.9,
      volume: 1.0
    },
    
    theme: {
      primary: '#87CEEB',
      secondary: '#E0F6FF',
      accent: '#4682B4',
      background: '#F0F8FF'
    },
    
    personality: {
      encouragementLevel: 'medium',
      celebrationStyle: 'balanced',
      languageComplexity: 'moderate',
      emojiUsage: 'moderate'
    },
    
    parentGate: {
      minNumber: 10,
      maxNumber: 30,
      operation: 'addition'
    }
  },
  
  tween: {
    id: 'tween',
    ageRange: [11, 13],
    displayRange: '11-13',
    
    session: {
      defaultDuration: 20,
      breakDuration: 5,
      checkInFrequency: 7,
      interactionFrequency: 25,
      maxDuration: 45
    },
    
    voice: {
      pitch: 1.0,
      rate: 0.95,
      volume: 0.9
    },
    
    theme: {
      primary: '#98FB98',
      secondary: '#F0FFF0',
      accent: '#228B22',
      background: '#F8FFF8'
    },
    
    personality: {
      encouragementLevel: 'medium',
      celebrationStyle: 'cool',
      languageComplexity: 'advanced',
      emojiUsage: 'minimal'
    },
    
    parentGate: {
      minNumber: 20,
      maxNumber: 50,
      operation: 'addition'
    }
  },
  
  teen: {
    id: 'teen',
    ageRange: [14, 18],
    displayRange: '14+',
    
    session: {
      defaultDuration: 25,
      breakDuration: 5,
      checkInFrequency: 10,
      interactionFrequency: 30,
      maxDuration: 60
    },
    
    voice: {
      pitch: 0.95,
      rate: 1.0,
      volume: 0.8
    },
    
    theme: {
      primary: '#DDA0DD',
      secondary: '#F8F0FF',
      accent: '#9370DB',
      background: '#FDFBFF'
    },
    
    personality: {
      encouragementLevel: 'low',
      celebrationStyle: 'minimal',
      languageComplexity: 'mature',
      emojiUsage: 'none'
    },
    
    parentGate: {
      minNumber: 50,
      maxNumber: 100,
      operation: 'addition'
    }
  }
};

// === DYNAMIC CONTENT GENERATION ===
// Generate age-appropriate content from personality templates
const CONTENT_TEMPLATES = {
  // UI Labels by complexity and celebration style
  labels: {
    simple_enthusiastic: {
      buddySelectionTitle: 'Pick Your Friend!',
      buddySelectionSubtitle: 'Who will help you today?',
      namePrompt: 'Tell me your name, superstar!',
      readyMessage: 'so excited to be your friend!',
      startButtonText: 'Let\'s Learn! üåà',
      breakButtonText: 'Break Time! üéà',
      endButtonText: 'All Done! üåü',
      streakLabel: 'day streak',
      statsLabel: 'Learning time'
    },
    moderate_balanced: {
      buddySelectionTitle: 'Choose Your Buddy!',
      buddySelectionSubtitle: 'Pick your study partner!',
      namePrompt: 'What should I call you?',
      readyMessage: 'ready to help you focus!',
      startButtonText: 'Start Studying! üìö',
      breakButtonText: 'Break Time! üåü',
      endButtonText: 'Finished! üéâ',
      streakLabel: 'day streak',
      statsLabel: 'Study time'
    },
    advanced_cool: {
      buddySelectionTitle: 'Pick Your Focus Friend',
      buddySelectionSubtitle: 'Choose your style',
      namePrompt: 'What\'s your name?',
      readyMessage: 'here to help you crush it!',
      startButtonText: 'Let\'s Go üí™',
      breakButtonText: 'Quick Break',
      endButtonText: 'Done ‚úì',
      streakLabel: 'days',
      statsLabel: 'Focus time'
    },
    mature_minimal: {
      buddySelectionTitle: 'Focus Mode',
      buddySelectionSubtitle: 'Select your vibe',
      namePrompt: 'Name (optional)',
      readyMessage: 'ready.',
      startButtonText: 'Start',
      breakButtonText: 'Break',
      endButtonText: 'End',
      streakLabel: 'days',
      statsLabel: 'Total'
    }
  },
  
  // Messages by encouragement level
  messages: {
    high: [
      'You\'re doing AMAZING! üåü',
      'Wow! Look at you go! üöÄ',
      'Super duper job! üåà',
      'You\'re the best! üíñ',
      'Keep being awesome! ‚≠ê'
    ],
    medium: [
      'Great focus! Keep it up! üåü',
      'You\'re doing awesome! üí™',
      'Nice work! Stay strong! üöÄ',
      'Fantastic job! üéØ',
      'Keep going, you\'ve got this! ‚≠ê'
    ],
    low: [
      'In the zone üéØ',
      'Solid üíØ',
      'Keep going üìà',
      'Progress ‚úì',
      'On track üé™'
    ]
  },
  
  // Break messages by style
  breaks: {
    enthusiastic: {
      title: 'Wiggle Break! üéâ',
      message: 'Time to jump, dance, or get a snack!',
      resumeText: 'More Learning!'
    },
    balanced: {
      title: 'Break Time!',
      message: 'Great work! Take 5 minutes to stretch or grab water.',
      resumeText: 'Back to Work!'
    },
    cool: {
      title: 'Break Time',
      message: 'Good session. Take 5.',
      resumeText: 'Continue'
    },
    minimal: {
      title: 'Break',
      message: '5 minute break.',
      resumeText: 'Resume'
    }
  }
};

// === SUBJECT CONFIGURATION ===
export const SUBJECT_SYSTEM = {
  // Subject definitions with metadata
  subjects: {
    // Elementary subjects
    math: { 
      id: 'math', label: 'Math', emoji: 'üî¢', 
      category: 'core', difficulty: 'medium',
      checkIns: ['Check your calculations!', 'Show your work!', 'One problem at a time', 'Double-check that answer', 'Remember your formulas']
    },
    reading: { 
      id: 'reading', label: 'Reading', emoji: 'üìö', 
      category: 'core', difficulty: 'easy',
      checkIns: ['What\'s happening now?', 'Who\'s the main character?', 'What do you think happens next?', 'Picture the scene', 'Keep going, great reading!']
    },
    writing: { 
      id: 'writing', label: 'Writing', emoji: '‚úèÔ∏è', 
      category: 'core', difficulty: 'medium',
      checkIns: ['Check your spelling!', 'Add more details', 'How many sentences so far?', 'Remember punctuation', 'Great writing flow!']
    },
    other: { 
      id: 'other', label: 'Other', emoji: 'üìù', 
      category: 'flexible', difficulty: 'easy',
      checkIns: ['Keep it up!', 'You\'re doing great!', 'Stay focused!', 'Almost there!', 'Excellent work!']
    },
    
    // Advanced subjects
    science: { 
      id: 'science', label: 'Science', emoji: 'üî¨', 
      category: 'stem', difficulty: 'medium',
      checkIns: ['Test your hypothesis', 'Check your method', 'What\'s the evidence?', 'Think like a scientist', 'Record your observations']
    },
    chemistry: { 
      id: 'chemistry', label: 'Chemistry', emoji: '‚öóÔ∏è', 
      category: 'stem', difficulty: 'hard',
      checkIns: ['Balance those equations!', 'Check your formulas', 'Remember units!', 'Think about reactions', 'Safety first!']
    },
    biology: { 
      id: 'biology', label: 'Biology', emoji: 'üß¨', 
      category: 'stem', difficulty: 'medium',
      checkIns: ['Think about the process', 'Draw it out if it helps', 'Check your terms', 'Remember the system', 'Life is amazing!']
    },
    history: { 
      id: 'history', label: 'History', emoji: 'üèõÔ∏è', 
      category: 'social', difficulty: 'medium',
      checkIns: ['Dates and names matter', 'What caused this?', 'Think about the timeline', 'Connect the events', 'History repeats!']
    },
    geography: { 
      id: 'geography', label: 'Geography', emoji: 'üåç', 
      category: 'social', difficulty: 'easy',
      checkIns: ['Picture the map', 'Remember locations', 'Think about connections', 'Climate matters', 'Explore the world!']
    }
  },
  
  // Age-appropriate subject groupings
  ageGroups: {
    young: ['math', 'reading', 'writing', 'other'],
    elementary: ['math', 'reading', 'writing', 'other'],
    tween: ['math', 'reading', 'writing', 'science', 'history', 'geography', 'other'],
    teen: ['math', 'reading', 'writing', 'science', 'chemistry', 'biology', 'history', 'geography', 'other']
  }
};

// === GAMIFICATION SYSTEM ===
export const GAMIFICATION_CONFIG = {
  // Surprise events (5% chance per session)
  surprises: {
    frequency: 0.05,
    events: [
      { id: 'power_hour', message: 'Power Hour! Everything counts double!', emoji: '‚ö°' },
      { id: 'buddy_birthday', message: 'It\'s Buddy\'s Birthday!', emoji: 'üéÇ' },
      { id: 'opposite_day', message: 'Opposite Day! Breaks are longer!', emoji: 'üîÑ' },
      { id: 'challenge_mode', message: 'Challenge Mode! Beat yesterday!', emoji: 'üèÜ' },
      { id: 'guest_buddy', message: 'Guest Buddy visiting!', emoji: 'üëã' },
      { id: 'speed_round', message: 'Speed Round! Quick focus!', emoji: 'üí®' },
      { id: 'quiet_mode', message: 'Shh... Library Mode!', emoji: 'ü§´' },
      { id: 'party_mode', message: 'Party Mode! Extra celebrations!', emoji: 'üéâ' }
    ]
  },
  
  // Mystery Monday events (every Monday)
  mysteryMonday: [
    'Buddy has a hat today!',
    'Timer counts UP instead of down!',
    'Everything is backwards!',
    'Night mode activated!',
    'Speed mode - shorter sessions!',
    'Buddy is feeling quiet today',
    'Double points day!',
    'Surprise colors everywhere!'
  ],
  
  // Seasonal themes (auto-applied by month)
  seasonal: {
    january: { name: 'New Year', emoji: 'üéä', color: '#FFD700' },
    february: { name: 'Hearts', emoji: 'üíï', color: '#FF69B4' },
    march: { name: 'Spring', emoji: 'üå∏', color: '#98FB98' },
    april: { name: 'Rain', emoji: 'üåßÔ∏è', color: '#87CEEB' },
    may: { name: 'Flowers', emoji: 'üå∫', color: '#FF6347' },
    june: { name: 'Summer', emoji: '‚òÄÔ∏è', color: '#FFD700' },
    july: { name: 'Beach', emoji: 'üèñÔ∏è', color: '#20B2AA' },
    august: { name: 'Back to School', emoji: 'üéí', color: '#FF8C00' },
    september: { name: 'Fall', emoji: 'üçÇ', color: '#D2691E' },
    october: { name: 'Halloween', emoji: 'üéÉ', color: '#FF8C00' },
    november: { name: 'Thankful', emoji: 'ü¶É', color: '#8B4513' },
    december: { name: 'Winter', emoji: '‚ùÑÔ∏è', color: '#00CED1' }
  }
};

// ===================================
// COMPUTED CONFIGURATIONS
// Generated dynamically from templates
// ===================================

// Generate parent gate questions
export function generateParentGate(ageTemplate: { parentGate: { minNumber: number; maxNumber: number; operation: string } }): ParentGate {
  const { minNumber, maxNumber, operation } = ageTemplate.parentGate;
  const a = Math.floor(Math.random() * (maxNumber - minNumber)) + minNumber;
  const b = Math.floor(Math.random() * (maxNumber - minNumber)) + minNumber;
  
  switch (operation) {
    case 'addition':
      return {
        question: `What's ${a} + ${b}?`,
        answer: (a + b).toString()
      };
    default:
      return { question: `What's ${a} + ${b}?`, answer: (a + b).toString() };
  }
}

// Generate content from templates
function generateContentForAge(ageTemplate) {
  const { languageComplexity, celebrationStyle, encouragementLevel } = ageTemplate.personality;
  const contentKey = `${languageComplexity}_${celebrationStyle}`;
  
  const labels = CONTENT_TEMPLATES.labels[contentKey] || CONTENT_TEMPLATES.labels.moderate_balanced;
  const messages = CONTENT_TEMPLATES.messages[encouragementLevel] || CONTENT_TEMPLATES.messages.medium;
  const breakInfo = CONTENT_TEMPLATES.breaks[celebrationStyle] || CONTENT_TEMPLATES.breaks.balanced;
  const parentGate = generateParentGate(ageTemplate);
  
  return {
    ...labels,
    checkInMessages: messages,
    breakTitle: breakInfo.title,
    breakMessage: breakInfo.message,
    resumeButtonText: breakInfo.resumeText,
    parentGateQuestion: parentGate.question,
    parentGateAnswer: parentGate.answer,
    
    // Generated session messages
    startMessage: generateStartMessage(ageTemplate.personality),
    welcomeBackMessage: generateWelcomeMessage(ageTemplate.personality),
    completionMessage: generateCompletionMessage(ageTemplate.personality)
  };
}

function generateStartMessage(personality) {
  const templates = {
    simple: 'Yay! Let\'s learn together! You\'re amazing!',
    moderate: 'Let\'s do this! I\'m right here with you.',
    advanced: 'Let\'s get this done.',
    mature: 'Focus mode activated.'
  };
  return templates[personality.languageComplexity] || templates.moderate;
}

function generateWelcomeMessage(personality) {
  const templates = {
    simple: 'Welcome back superstar!',
    moderate: 'Welcome back! Ready to continue?',
    advanced: 'Back at it. Nice.',
    mature: 'Resuming.'
  };
  return templates[personality.languageComplexity] || templates.moderate;
}

function generateCompletionMessage(personality) {
  const templates = {
    simple: 'Amazing job! You\'re a superstar!',
    moderate: 'Excellent work! You did it!',
    advanced: 'Solid work today.',
    mature: 'Session complete.'
  };
  return templates[personality.languageComplexity] || templates.moderate;
}

// ===================================
// FINAL COMPUTED CONFIGURATIONS
// Ready-to-use by components
// ===================================

// Generate complete age configurations
export const AGE_CONFIGS: Record<AgeGroup, AgeConfig> = Object.fromEntries(
  (Object.entries(AGE_GROUP_TEMPLATES) as Array<[AgeGroup, typeof AGE_GROUP_TEMPLATES[keyof typeof AGE_GROUP_TEMPLATES]]>).map(([key, template]) => [
    key,
    {
      // Copy base template
      ...template,
      
      // Add computed content
      ...generateContentForAge(template),
      
      // Convert session minutes to seconds for timers
      sessionLength: template.session.defaultDuration * 60,
      breakDuration: template.session.breakDuration * 60,
      checkInFrequency: template.session.checkInFrequency,
      interactionFrequency: template.session.interactionFrequency,
      
      // Add computed UI properties
      buddySize: UI_SCALING_CONFIG.baseSizes.buddySize * UI_SCALING_CONFIG.ageScaling[key].buddySize,
      fontSize: UI_SCALING_CONFIG.ageScaling[key].fontSize,
      buttonScale: UI_SCALING_CONFIG.ageScaling[key].buttonScale,
      
      // Voice properties (direct copy)
      voicePitch: template.voice.pitch,
      voiceRate: template.voice.rate,
      
      // Theme properties (direct copy) 
      primaryColor: template.theme.primary,
      secondaryColor: template.theme.secondary,
      accentColor: template.theme.accent
    }
  ])
);

// ===================================
// UTILITY FUNCTIONS
// For components to access configurations
// ===================================

// Get configuration for specific age group
export const getAgeConfig = (ageGroup: AgeGroup): AgeConfig => {
  return AGE_CONFIGS[ageGroup] ?? AGE_CONFIGS.elementary;
};

// Get subjects appropriate for age
export const getSubjectsForAge = (ageGroup: AgeGroup): Subject[] => {
  const subjectIds = SUBJECT_SYSTEM.ageGroups[ageGroup] ?? SUBJECT_SYSTEM.ageGroups.elementary;
  return subjectIds.map((id: string) => SUBJECT_SYSTEM.subjects[id]);
};

// Get check-in messages for subject
export const getSubjectCheckIns = (subjectId: string): string[] => {
  return SUBJECT_SYSTEM.subjects[subjectId]?.checkIns || SUBJECT_SYSTEM.subjects.other.checkIns;
};

// Get responsive value based on screen size
export const getResponsiveValue = <T,>(values: { small?: T; medium: T; large?: T; xlarge?: T }): T => {
  if (screenWidth < UI_SCALING_CONFIG.breakpoints.small) return values.small || values.medium;
  if (screenWidth < UI_SCALING_CONFIG.breakpoints.medium) return values.medium;
  if (screenWidth < UI_SCALING_CONFIG.breakpoints.large) return values.large || values.medium;
  return values.xlarge || values.large;
};

// Get scaled size for age group
type ScaleKey = 'buddySize' | 'fontSize' | 'buttonScale' | 'spacing' | 'iconSize';
export const getScaledSize = (
  baseSize: number,
  ageGroup: AgeGroup,
  sizeType: ScaleKey = 'buddySize'
): number => {
  const scaling = UI_SCALING_CONFIG.ageScaling[ageGroup] ?? UI_SCALING_CONFIG.ageScaling.elementary;
  return baseSize * scaling[sizeType];
};

// Get timing value
export const getTiming = <T extends keyof typeof TIMING_CONFIG, K extends keyof (typeof TIMING_CONFIG)[T]>(category: T, key: K): number => {
  const group = TIMING_CONFIG[category] as any;
  const value = group?.[key as string];
  return typeof value === 'number' ? value : 1000;
};

// Get current seasonal theme
export const getCurrentSeasonalTheme = () => {
  const month = new Date().getMonth(); // 0-11
  const monthNames = ['january', 'february', 'march', 'april', 'may', 'june', 
                     'july', 'august', 'september', 'october', 'november', 'december'];
  return GAMIFICATION_CONFIG.seasonal[monthNames[month]];
};

// Get random surprise event
export const getRandomSurpriseEvent = () => {
  const events = GAMIFICATION_CONFIG.surprises.events;
  return events[Math.floor(Math.random() * events.length)];
};

// Check if surprise should trigger
export const shouldTriggerSurprise = () => {
  try {
    const extra: any = (require('expo-constants').default?.manifest?.extra || {});
    const mult = extra?.remote?.surprise?.frequencyMultiplier ?? 1.0;
    const freq = Math.max(0, GAMIFICATION_CONFIG.surprises.frequency * mult);
    return Math.random() < freq;
  } catch {
    return Math.random() < GAMIFICATION_CONFIG.surprises.frequency;
  }
};

// Get Mystery Monday change for current week
export const getMysteryMondayChange = () => {
  const today = new Date();
  if (today.getDay() !== 1) return null; // Not Monday
  
  const weekNumber = Math.floor(today.getDate() / 7);
  const changes = GAMIFICATION_CONFIG.mysteryMonday;
  return changes[weekNumber % changes.length];
};

// ===================================
// BACKWARD COMPATIBILITY EXPORTS
// For existing code that uses old names
// ===================================

// Legacy exports (auto-generated from new system)
export const SUBJECTS_ELEMENTARY = getSubjectsForAge('elementary');
export const SUBJECTS_ADVANCED = getSubjectsForAge('teen');
export const SUBJECT_CHECK_INS = Object.fromEntries(
  Object.entries(SUBJECT_SYSTEM.subjects).map(([id, subject]) => [id, subject.checkIns])
);
export const SURPRISE_EVENTS = GAMIFICATION_CONFIG.surprises.events;
export const MYSTERY_MONDAY_CHANGES = GAMIFICATION_CONFIG.mysteryMonday;
export const SEASONAL_THEMES = GAMIFICATION_CONFIG.seasonal;

// Colors system
export const COLORS = {
  primary: '#4A90E2',
  success: '#27AE60',
  warning: '#F39C12',
  danger: '#E74C3C',
  info: '#3498DB',
  purple: '#9B59B6',
  dark: '#2C3E50',
  gray: '#7F8C8D',
  lightGray: '#ECF0F1',
  background: '#F0F8FF',
};
```

---

## study-buddy/src/screens/OnboardingScreen.tsx
```tsx
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Alert
} from 'react-native';
import { Audio } from 'expo-av';
import * as Speech from 'expo-speech';
import { setStorageItem } from '@utils/core/storage';
import { getBuddiesForAge } from '@assets/animations/buddy-animations';
import { 
  AGE_CONFIGS, 
  getAgeConfig, 
  getResponsiveValue, 
  getScaledSize,
  UI_SCALING_CONFIG,
  TIMING_CONFIG
} from '@utils/config/constants';
import { track } from '@utils/analytics';
import { speakWithBuddy } from '@utils/voice/speakWithBuddy';
import { impact } from '@utils/feedback';
import { uiAlert } from '@ui/alerts';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getBalance, getRewardsCatalog } from '@utils/rewards';
import { t } from '@utils/intl/i18n';

type Props = StackScreenProps<RootStackParamList, 'Onboarding'>;

const { width, height } = Dimensions.get('window');

export default function OnboardingScreen({ navigation }: Props) {
  const [selectedAge, setSelectedAge] = useState<'young' | 'elementary' | 'tween' | 'teen' | null>(null);
  const [selectedBuddy, setSelectedBuddy] = useState<{ id: string; name: string; emoji: string; color: string; personality?: string } | null>(null);
  const [childName, setChildName] = useState<string>('');
  const [recording, setRecording] = useState<import('expo-av').Audio.Recording | null>(null);
  const [step, setStep] = useState<'chooseAge' | 'chooseBuddy' | 'recordName' | 'ready'>('chooseAge');

  const selectAge = (ageGroup) => {
    setSelectedAge(ageGroup);
    setStep('chooseBuddy');
  };

  const selectBuddy = (buddy) => {
    setSelectedBuddy(buddy);
    const config = getAgeConfig(selectedAge);
    
    speakWithBuddy({ buddy, ageGroup: selectedAge, text: `Great choice! I'm ${buddy.name} and I'm excited to study with you!` });
    
    setTimeout(() => setStep('recordName'), TIMING_CONFIG.animations.fadeIn * 4);
  };

  const startRecording = async () => {
    try {
      await Audio.requestPermissionsAsync();
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: true,
        playsInSilentModeIOS: true,
      });

      const { recording } = await Audio.Recording.createAsync(
        Audio.RecordingOptionsPresets.HIGH_QUALITY
      );
      setRecording(recording);
    } catch (err) {
      uiAlert('Oops!', 'Could not start recording. You can set this up later!');
    }
  };

  const stopRecording = async () => {
    if (!recording) return;
    
    setRecording(null);
    await recording.stopAndUnloadAsync();
    const uri = recording.getURI();
    
    await setStorageItem('childNameRecording', uri);
    setStep('ready');
    
    const config = getAgeConfig(selectedAge);
    speakWithBuddy({ buddy: selectedBuddy, ageGroup: selectedAge, text: config.completionMessage });
  };

  const completeOnboarding = async () => {
    await setStorageItem('hasLaunched', 'true');
    await setStorageItem('selectedAge', selectedAge);
    await setStorageItem('selectedBuddy', JSON.stringify(selectedBuddy));
    await setStorageItem('childName', childName || 'Buddy');
    track('onboarding_complete', { ageGroup: selectedAge, buddyId: selectedBuddy?.id });
    navigation.replace('Consent');
  };

  const renderChooseAge = () => {
    const ageGroups = Object.entries(AGE_CONFIGS);
    
    return (
      <View style={styles.container}>
        <Text accessibilityRole="header" style={[styles.title, getResponsiveStyles('title')]}> 
          {t('howOldIsYourChild')}
        </Text>
        <Text style={[styles.subtitle, getResponsiveStyles('subtitle')]}> 
          {t('weWillCustomize')}
        </Text>
        
        <View style={styles.ageContainer}>
          {ageGroups.map(([ageKey, config]) => (
            <TouchableOpacity
              key={ageKey}
              style={[styles.ageCard, getAgeCardStyle(ageKey)]}
              onPress={() => selectAge(ageKey)}
            >
              <Text style={[styles.ageEmoji, getResponsiveStyles('ageEmoji')]}>
                {getAgeEmoji(ageKey)}
              </Text>
              <Text style={[styles.ageTitle, getResponsiveStyles('ageTitle')]}>
                {getAgeTitle(ageKey)}
              </Text>
              <Text style={[styles.ageRange, getResponsiveStyles('ageRange')]}>
                Ages {config.displayRange || config.ageRange}
              </Text>
              <Text style={[styles.ageDescription, getResponsiveStyles('ageDescription')]}>
                {getAgeDescription(ageKey)}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>
    );
  };

  const renderChooseBuddy = () => {
    const buddies = selectedAge ? getBuddiesForAge(selectedAge) : [];
    const config = getAgeConfig(selectedAge);
    
    return (
      <View style={styles.container}>
        <Text style={[styles.title, getResponsiveStyles('title')]}>
          {config.buddySelectionTitle}
        </Text>
        <Text style={[styles.subtitle, getResponsiveStyles('subtitle')]}>
          {config.buddySelectionSubtitle}
        </Text>
        
        <View style={styles.buddyContainer}>
          {buddies.map((buddy) => (
            <TouchableOpacity
              key={buddy.id}
              style={[
                styles.buddyCard, 
                selectedBuddy?.id === buddy.id && styles.selectedBuddy,
                getResponsiveStyles('buddyCard')
              ]}
              onPress={() => selectBuddy(buddy)}
            >
              <View style={[
                styles.buddyAvatar, 
                { backgroundColor: buddy.color },
                getResponsiveStyles('buddyAvatar')
              ]}>
                <Text style={[styles.buddyEmoji, getResponsiveStyles('buddyEmoji')]}>
                  {buddy.emoji}
                </Text>
              </View>
              <Text style={[styles.buddyName, getResponsiveStyles('buddyName')]}>
                {buddy.name}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>
    );
  };

  const renderRecordName = () => {
    const config = getAgeConfig(selectedAge);
    
    return (
      <View style={styles.container}>
        <View style={[
          styles.bigBuddyAvatar, 
          { backgroundColor: selectedBuddy?.color },
          getResponsiveStyles('bigBuddyAvatar')
        ]}>
          <Text style={[styles.bigBuddyEmoji, getResponsiveStyles('bigBuddyEmoji')]}>
            {selectedBuddy?.emoji}
          </Text>
        </View>
        
        <Text accessibilityRole="header" style={[styles.title, getResponsiveStyles('title')]}>{t('whatsYourName')}</Text>
        <Text style={[styles.subtitle, getResponsiveStyles('subtitle')]}>{config.namePrompt}</Text>
        
        <TouchableOpacity
          style={[
            styles.recordButton, 
            recording && styles.recordingActive,
            getResponsiveStyles('recordButton')
          ]}
          testID="record-button"
          onPressIn={startRecording}
          onPressOut={stopRecording}
        >
          <Text style={[styles.recordButtonText, getResponsiveStyles('recordButtonText')]}> 
            {recording ? `üéôÔ∏è ${t('recording')}` : `üé§ ${t('holdToRecord')}`}
          </Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.skipButton} onPress={() => setStep('ready')} accessibilityRole="button" accessibilityLabel={t('skipForNow')}>
          <Text style={styles.skipText}>{t('skipForNow')}</Text>
        </TouchableOpacity>
      </View>
    );
  };

  const renderReady = () => {
    const config = getAgeConfig(selectedAge);
    
    return (
      <View style={styles.container}>
        <View style={[
          styles.bigBuddyAvatar, 
          { backgroundColor: selectedBuddy?.color },
          getResponsiveStyles('bigBuddyAvatar')
        ]}>
          <Text style={[styles.bigBuddyEmoji, getResponsiveStyles('bigBuddyEmoji')]}>
            {selectedBuddy?.emoji}
          </Text>
        </View>
        
        <Text accessibilityRole="header" style={[styles.title, getResponsiveStyles('title')]}>{t('weAreReady')}</Text>
        <Text style={[styles.subtitle, getResponsiveStyles('subtitle')]}>
          {selectedBuddy?.name} is {config.readyMessage}
        </Text>
        
        <TouchableOpacity
          style={[styles.startButton, getResponsiveStyles('startButton')]}
          onPress={completeOnboarding}
        >
          <Text style={[styles.startButtonText, getResponsiveStyles('startButtonText')]}>
            {config.startButtonText}
          </Text>
        </TouchableOpacity>
      </View>
    );
  };

  // Helper functions for age-specific content
  const getAgeEmoji = (ageKey) => {
    const emojis = { young: 'üß∏', elementary: 'üìö', tween: 'üéÆ', teen: 'üí™' };
    return emojis[ageKey] || 'üìö';
  };

  const getAgeTitle = (ageKey) => {
    const titles = { young: 'Little Learner', elementary: 'Elementary', tween: 'Tween', teen: 'Teen' };
    return titles[ageKey] || 'Elementary';
  };

  const getAgeDescription = (ageKey) => {
    const descriptions = { 
      young: 'Big celebrations, short sessions', 
      elementary: 'Balanced support & fun',
      tween: 'Cool & independent',
      teen: 'Minimal & focused'
    };
    return descriptions[ageKey] || 'Balanced support & fun';
  };

  const getAgeCardStyle = (ageKey) => {
    const config = getAgeConfig(ageKey);
    return { borderColor: config.primaryColor, borderWidth: 2 };
  };

  const getResponsiveStyles = (component) => {
    const scaling = selectedAge ? UI_SCALING_CONFIG.ageScaling[selectedAge] : UI_SCALING_CONFIG.ageScaling.elementary;
    
    return getResponsiveValue({
      small: getComponentStyle(component, scaling, 0.9),
      medium: getComponentStyle(component, scaling, 1.0),
      large: getComponentStyle(component, scaling, 1.1),
      xlarge: getComponentStyle(component, scaling, 1.2)
    });
  };

  const getComponentStyle = (component, scaling, screenScale) => {
    const baseStyles = {
      title: { fontSize: 32 * scaling.fontSize * screenScale },
      subtitle: { fontSize: 18 * scaling.fontSize * screenScale },
      ageEmoji: { fontSize: 40 * scaling.iconSize * screenScale },
      ageTitle: { fontSize: 18 * scaling.fontSize * screenScale },
      ageRange: { fontSize: 14 * scaling.fontSize * screenScale },
      ageDescription: { fontSize: 12 * scaling.fontSize * screenScale },
      buddyCard: { padding: 15 * scaling.spacing * screenScale },
      buddyAvatar: { 
        width: 80 * scaling.buddySize * screenScale, 
        height: 80 * scaling.buddySize * screenScale,
        borderRadius: 40 * scaling.buddySize * screenScale 
      },
      buddyEmoji: { fontSize: 40 * scaling.iconSize * screenScale },
      buddyName: { fontSize: 16 * scaling.fontSize * screenScale },
      bigBuddyAvatar: { 
        width: 150 * scaling.buddySize * screenScale, 
        height: 150 * scaling.buddySize * screenScale,
        borderRadius: 75 * scaling.buddySize * screenScale 
      },
      bigBuddyEmoji: { fontSize: 70 * scaling.iconSize * screenScale },
      recordButton: { 
        paddingHorizontal: 40 * scaling.spacing * screenScale,
        paddingVertical: 20 * scaling.spacing * screenScale 
      },
      recordButtonText: { fontSize: 20 * scaling.fontSize * screenScale },
      startButton: { 
        paddingHorizontal: 60 * scaling.spacing * screenScale,
        paddingVertical: 20 * scaling.spacing * screenScale 
      },
      startButtonText: { fontSize: 24 * scaling.fontSize * screenScale }
    };
    
    return baseStyles[component] || {};
  };

  return (
    <SafeAreaView style={styles.safeArea}>
      {step === 'chooseAge' && renderChooseAge()}
      {step === 'chooseBuddy' && renderChooseBuddy()}
      {step === 'recordName' && renderRecordName()}
      {step === 'ready' && renderReady()}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#F0F8FF',
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 10,
    textAlign: 'center',
  },
  subtitle: {
    color: '#7F8C8D',
    marginBottom: 40,
    textAlign: 'center',
  },
  ageContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    width: '100%',
  },
  ageCard: {
    width: '45%',
    margin: '2.5%',
    padding: 20,
    borderRadius: 20,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
    alignItems: 'center',
  },
  ageEmoji: {
    marginBottom: 10,
  },
  ageTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 5,
  },
  ageRange: {
    color: '#7F8C8D',
    marginBottom: 5,
  },
  ageDescription: {
    color: '#95A5A6',
    textAlign: 'center',
  },
  buddyContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
  },
  buddyCard: {
    alignItems: 'center',
    borderRadius: 20,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  selectedBuddy: {
    transform: [{ scale: 1.1 }],
    borderWidth: 3,
    borderColor: '#4A90E2',
  },
  buddyAvatar: {
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  buddyEmoji: {},
  buddyName: {
    fontWeight: '600',
    color: '#2C3E50',
  },
  bigBuddyAvatar: {
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 40,
  },
  bigBuddyEmoji: {},
  recordButton: {
    backgroundColor: '#E74C3C',
    borderRadius: 30,
    marginTop: 20,
  },
  recordingActive: {
    backgroundColor: '#C0392B',
    transform: [{ scale: 1.05 }],
  },
  recordButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  skipButton: {
    marginTop: 20,
    padding: 10,
  },
  skipText: {
    color: '#7F8C8D',
    fontSize: 16,
  },
  startButton: {
    backgroundColor: '#27AE60',
    borderRadius: 30,
    marginTop: 40,
  },
  startButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
});
```

---

## study-buddy/src/screens/ModeSelectionScreen.tsx
```tsx
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Modal
} from 'react-native';
import { getStorageItem } from '@utils/core/storage';
import { 
  getAgeConfig, 
  getSubjectsForAge,
  getResponsiveValue,
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import ScreenBackground from '@components/ScreenBackground';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { t } from '@utils/intl/i18n';

const { width } = Dimensions.get('window');

type Props = StackScreenProps<RootStackParamList, 'ModeSelection'>;

export default function ModeSelectionScreen({ navigation }: Props) {
  const [ageGroup, setAgeGroup] = useState('elementary');
  const [studyingCount, setStudyingCount] = useState(0);
  const [streakCount, setStreakCount] = useState(0);
  const [showSubjectModal, setShowSubjectModal] = useState(false);
  const [tokenBalance, setTokenBalance] = useState(0);
  const [showRewardsModal, setShowRewardsModal] = useState(false);

  useEffect(() => {
    loadUserData();
    setupLiveActivity();
    loadBalance();
  }, []);

  const loadUserData = async () => {
    const age = await getStorageItem('selectedAge');
    if (age) setAgeGroup(age);
    
    // Set initial "live" counts with realistic numbers
    setStudyingCount(Math.floor(Math.random() * 500) + 800);
    setStreakCount(Math.floor(Math.random() * 100) + 100);
  };

  const setupLiveActivity = () => {
    // Simulate live activity updates using configured timing
    const interval = setInterval(() => {
      setStudyingCount(Math.floor(Math.random() * 500) + 800);
      setStreakCount(Math.floor(Math.random() * 100) + 100);
    }, TIMING_CONFIG.intervals.liveActivityUpdate * 1000);
    
    return () => clearInterval(interval);
  };

  const loadBalance = async () => {
    try {
      const bal = await getBalance();
      setTokenBalance(bal);
    } catch {}
  };

  const selectSubjectAndStart = (subject) => {
    setShowSubjectModal(false);
    navigation.navigate('Main', { selectedSubject: subject });
  };

  const config = getAgeConfig(ageGroup);

  // Responsive sizing
  const responsiveStyles = useMemo(() => ({
    title: getResponsiveValue({
      small: { fontSize: getScaledSize(24, ageGroup, 'fontSize') },
      medium: { fontSize: getScaledSize(28, ageGroup, 'fontSize') },
      large: { fontSize: getScaledSize(32, ageGroup, 'fontSize') }
    }),
    modeCard: getResponsiveValue({
      small: { width: '90%', padding: getScaledSize(15, ageGroup, 'spacing') },
      medium: { width: '45%', padding: getScaledSize(20, ageGroup, 'spacing') },
      large: { width: '40%', padding: getScaledSize(25, ageGroup, 'spacing') }
    }),
    modeEmoji: getResponsiveValue({
      small: { fontSize: getScaledSize(40, ageGroup, 'iconSize') },
      medium: { fontSize: getScaledSize(50, ageGroup, 'iconSize') },
      large: { fontSize: getScaledSize(60, ageGroup, 'iconSize') }
    })
  }), [ageGroup]);

  return (
    <ScreenBackground ageGroup={ageGroup}>
      <View style={styles.container}>

        {/* Title */}
        <Text
          accessibilityRole="header"
          style={[styles.title, responsiveStyles.title, { color: config.primaryColor }]}
        >
          {t('howAreYouFeeling')}
        </Text>

        {/* Token Badge */}
        <View style={{ alignSelf: 'flex-end', marginBottom: 8 }}>
          <TouchableOpacity onPress={() => setShowRewardsModal(true)} style={{ backgroundColor: '#FFD700', paddingHorizontal: 10, paddingVertical: 6, borderRadius: 16 }}>
            <Text style={{ color: '#2C3E50', fontWeight: '700' }}>üéüÔ∏è {tokenBalance}</Text>
          </TouchableOpacity>
        </View>

        {/* Mode Selection */}
        <View style={styles.modeContainer}>
          <TouchableOpacity
            style={[
              styles.modeCard, 
              responsiveStyles.modeCard,
              styles.studyMode,
              { borderColor: config.accentColor }
            ]}
            onPress={() => setShowSubjectModal(true)}
            accessibilityRole="button"
            accessibilityLabel={t('readyToWork')}
            accessibilityHint={t('startQuickly')}
          >
            <Text style={[styles.modeEmoji, responsiveStyles.modeEmoji]}>üìö</Text>
            <Text style={[
              styles.modeTitle, 
              { fontSize: getScaledSize(16, ageGroup, 'fontSize'), color: config.primaryColor }
            ]}>
              {t('readyToWork')}
            </Text>
            <Text style={[
              styles.modeDescription,
              { fontSize: getScaledSize(12, ageGroup, 'fontSize') }
            ]}>
              {getModeDescription(ageGroup, 'study')}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[
              styles.modeCard,
              responsiveStyles.modeCard, 
              styles.calmMode,
              { borderColor: '#2196F3' }
            ]}
            onPress={() => navigation.navigate('CalmMode')}
            accessibilityRole="button"
            accessibilityLabel={t('needToCalmDown')}
          >
            <Text style={[styles.modeEmoji, responsiveStyles.modeEmoji]}>üßò</Text>
            <Text style={[
              styles.modeTitle,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize'), color: '#2196F3' }
            ]}>
              {t('needToCalmDown')}
            </Text>
            <Text style={[
              styles.modeDescription,
              { fontSize: getScaledSize(12, ageGroup, 'fontSize') }
            ]}>
              {getModeDescription(ageGroup, 'calm')}
            </Text>
          </TouchableOpacity>
        </View>

        {/* Quick Stats */}
        <View style={styles.statsPreview}>
          <Text style={[
            styles.statsText,
            { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
          ]}>
            {t('startQuickly')}
          </Text>
          <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'center', marginTop: 10 }}>
            {getQuickStarts(ageGroup).map((qs) => (
              <TouchableOpacity
                key={qs.id}
                style={{
                  backgroundColor: 'white',
                  borderColor: config.accentColor,
                  borderWidth: 2,
                  borderRadius: 16,
                  paddingHorizontal: getScaledSize(14, ageGroup, 'spacing'),
                  paddingVertical: getScaledSize(8, ageGroup, 'spacing'),
                  margin: 6,
                }}
                onPress={() => {
                  const subject = getSubjectsForAge(ageGroup).find(s => s.id === qs.subjectId) || { id: 'other', label: 'Other' };
                  navigation.navigate('Main', { selectedSubject: subject, quickStart: { workMinutes: qs.work, breakMinutes: qs.break } });
                }}
                accessibilityRole="button"
                accessibilityLabel={`${qs.label}`}
              >
                <Text style={{ color: config.primaryColor, fontWeight: '600' }}>{qs.emoji} {qs.label}</Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>
      </View>

      {/* Subject Selection Modal */}
      <Modal
        visible={showSubjectModal}
        transparent={true}
        animationType="slide"
      >
        <View style={styles.modalContainer}>
          <View style={[
            styles.modalContent,
            { padding: getScaledSize(30, ageGroup, 'spacing') }
          ]}>
            <Text
              accessibilityRole="header"
              style={[
              styles.modalTitle,
              { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
            ]}
            >
              {t('whatAreYouWorkingOn')}
            </Text>
            <View style={styles.subjectGrid}>
              {getSubjectsForAge(ageGroup).map((subject) => (
                <TouchableOpacity
                  key={subject.id}
                  style={[
                    styles.subjectButton,
                    { 
                      padding: getScaledSize(20, ageGroup, 'spacing'),
                      borderColor: config.accentColor 
                    }
                  ]}
                  onPress={() => selectSubjectAndStart(subject)}
                >
                  <Text style={[
                    styles.subjectEmoji,
                    { fontSize: getScaledSize(32, ageGroup, 'iconSize') }
                  ]}>
                    {subject.emoji}
                  </Text>
                  <Text style={[
                    styles.subjectLabel,
                    { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
                  ]}>
                    {subject.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
            
            <TouchableOpacity
              style={[styles.closeButton, { backgroundColor: config.primaryColor }]}
              onPress={() => setShowSubjectModal(false)}
              accessibilityRole="button"
              accessibilityLabel="Close"
            >
              <Text style={styles.closeButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Rewards Modal */}
      <Modal visible={showRewardsModal} transparent={true} animationType="slide" onRequestClose={() => setShowRewardsModal(false)}>
        <View style={styles.modalContainer}>
          <View style={[styles.modalContent, { padding: getScaledSize(30, ageGroup, 'spacing') }]}>
            <Text style={[styles.modalTitle, { fontSize: getScaledSize(24, ageGroup, 'fontSize') }]}>Rewards</Text>
            <Text style={{ color: '#2C3E50', marginBottom: 10 }}>Balance: {tokenBalance} tokens</Text>
            {getRewardsCatalog().map((r) => (
              <View key={r.id} style={{ backgroundColor: '#F0F8FF', margin: 8, borderRadius: 12, padding: 12, width: '100%' }}>
                <Text style={{ color: '#2C3E50', fontWeight: '600' }}>{r.name}</Text>
                <Text style={{ color: '#7F8C8D' }}>{r.cost} tokens</Text>
              </View>
            ))}
            <Text style={{ color: '#7F8C8D', marginTop: 6, textAlign: 'center' }}>Redeem from Parent Settings</Text>
            <TouchableOpacity style={[styles.closeButton, { backgroundColor: config.primaryColor }]} onPress={() => setShowRewardsModal(false)}>
              <Text style={styles.closeButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

    </ScreenBackground>
  );
}

// Helper function for mode descriptions
function getModeDescription(ageGroup, mode) {
  const descriptions = {
    study: {
      young: 'Time to learn!',
      elementary: 'Study time',
      tween: 'Focus mode', 
      teen: 'Work mode'
    },
    calm: {
      young: 'Feel better',
      elementary: 'Take a breath',
      tween: 'Reset',
      teen: 'Mindfulness'
    }
  };
  
  return descriptions[mode][ageGroup] || descriptions[mode].elementary;
}

// Quick Start presets by age group
function getQuickStarts(ageGroup) {
  const presets = {
    young: [
      { id: 'qs-math-10-3', subjectId: 'math', work: 10, break: 3, emoji: 'üî¢', label: 'Math 10 + 3' },
      { id: 'qs-read-10-3', subjectId: 'reading', work: 10, break: 3, emoji: 'üìö', label: 'Read 10 + 3' }
    ],
    elementary: [
      { id: 'qs-math-15-5', subjectId: 'math', work: 15, break: 5, emoji: 'üî¢', label: 'Math 15 + 5' },
      { id: 'qs-read-15-5', subjectId: 'reading', work: 15, break: 5, emoji: 'üìö', label: 'Read 15 + 5' }
    ],
    tween: [
      { id: 'qs-sci-20-5', subjectId: 'science', work: 20, break: 5, emoji: 'üî¨', label: 'Science 20 + 5' },
      { id: 'qs-math-20-5', subjectId: 'math', work: 20, break: 5, emoji: 'üî¢', label: 'Math 20 + 5' }
    ],
    teen: [
      { id: 'qs-write-25-5', subjectId: 'writing', work: 25, break: 5, emoji: '‚úèÔ∏è', label: 'Write 25 + 5' },
      { id: 'qs-chem-25-5', subjectId: 'chemistry', work: 25, break: 5, emoji: '‚öóÔ∏è', label: 'Chem 25 + 5' }
    ]
  };
  return presets[ageGroup] || presets.elementary;
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
  },
  liveActivity: {
    position: 'absolute',
    top: 50,
    width: '100%',
    alignItems: 'center',
  },
  liveText: {
    color: '#7F8C8D',
    marginBottom: 5,
  },
  title: {
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 40,
  },
  modeContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginBottom: 40,
    flexWrap: 'wrap',
  },
  modeCard: {
    borderRadius: 20,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.12,
    shadowRadius: 20,
    elevation: 6,
    backgroundColor: 'white',
    marginBottom: 20,
  },
  studyMode: {
    borderWidth: 2,
  },
  calmMode: {
    borderWidth: 2,
  },
  modeEmoji: {
    marginBottom: 15,
  },
  modeTitle: {
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 8,
  },
  modeDescription: {
    color: '#7F8C8D',
    textAlign: 'center',
  },
  statsPreview: {
    position: 'absolute',
    bottom: 50,
    width: '100%',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  statsText: {
    color: '#95A5A6',
    textAlign: 'center',
    fontStyle: 'italic',
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 20,
    width: '90%',
    maxWidth: 400,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 10,
    elevation: 10,
  },
  modalTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 30,
    textAlign: 'center',
  },
  subjectGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    width: '100%',
  },
  subjectButton: {
    backgroundColor: '#F0F8FF',
    margin: 8,
    borderRadius: 15,
    alignItems: 'center',
    minWidth: 100,
    borderWidth: 2,
  },
  subjectEmoji: {
    marginBottom: 8,
  },
  subjectLabel: {
    fontWeight: '600',
    color: '#2C3E50',
  },
  closeButton: {
    paddingHorizontal: 30,
    paddingVertical: 15,
    borderRadius: 20,
    marginTop: 20,
  },
  closeButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
```

---

## study-buddy/src/screens/MainScreen.tsx
```tsx
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Alert,
  AppState,
  Modal
} from 'react-native';
import * as Speech from 'expo-speech';
import * as Haptics from 'expo-haptics';
import * as LocalAuthentication from 'expo-local-authentication';
import { Camera } from 'expo-camera';
import * as Notifications from 'expo-notifications';
import { getStorageItem, setStorageItem } from '@utils/core/storage';
import { smartSpeak, stopSpeech } from '@utils/voice/speech';
import { speakWithBuddy } from '@utils/voice/speakWithBuddy';
import { impact, success as hapticSuccess } from '@utils/feedback';
import { uiAlert } from '@ui/alerts';
import BuddyCharacter from '@components/BuddyCharacter';
import StudyTimer from '@components/StudyTimer';
import CheckInMessage from '@components/CheckInMessage';
import BigButton from '@components/BigButton';
import { 
  getAgeConfig,
  getSubjectsForAge,
  getSubjectCheckIns,
  shouldTriggerSurprise,
  getRandomSurpriseEvent,
  getMysteryMondayChange,
  getCurrentSeasonalTheme,
  getScaledSize,
  TIMING_CONFIG,
  generateParentGate
} from '@utils/config/constants';
import { generatePeerLine } from '@utils/content/peerLines';
import { resolveVoiceForBuddy } from '@utils/voice/voice';
import ScreenBackground from '@components/ScreenBackground';
import { track } from '@utils/analytics';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getAdaptiveCheckInMinutes, recordInteraction } from '@utils/adaptive';
import { addTokens } from '@utils/rewards';
import { scheduler } from '@utils/scheduler';
import { getStringKey, setStringKey } from '@utils/core/storageKeys';
import { captureError } from '@utils/errors';

const { width, height } = Dimensions.get('window');

type Props = StackScreenProps<RootStackParamList, 'Main'>;

export default function MainScreen({ navigation, route }: Props) {
  const [buddy, setBuddy] = useState<{ id?: string; name?: string; emoji?: string; color?: string; personality?: string } | null>(null);
  const [ageGroup, setAgeGroup] = useState<'young' | 'elementary' | 'tween' | 'teen'>('elementary');
  const [isStudying, setIsStudying] = useState<boolean>(false);
  const [sessionTime, setSessionTime] = useState<number>(0);
  const [totalFocusTime, setTotalFocusTime] = useState<number>(0);
  const [checkInMessage, setCheckInMessage] = useState<string>('');
  const [showCheckIn, setShowCheckIn] = useState<boolean>(false);
  const [currentStreak, setCurrentStreak] = useState<number>(0);
  const [buddyFaded, setBuddyFaded] = useState<boolean>(false);
  const [workPhoto, setWorkPhoto] = useState<string | null>(null);
  const [showProofMode, setShowProofMode] = useState<boolean>(false);
  const [showInteractionModal, setShowInteractionModal] = useState<boolean>(false);
  const [currentQuestion, setCurrentQuestion] = useState<{ id: string; text: string; options: Array<{ label: string; value: string }> } | null>(null);
  const [sessionLog, setSessionLog] = useState<Array<{ time: number; question: string; response: string; timestamp: string }>>([]);
  const [currentSubject, setCurrentSubject] = useState<{ id: string; label: string } | null>(null);
  const [currentSurprise, setCurrentSurprise] = useState<{ id?: string; message: string; emoji: string } | null>(null);
  const [showParentGate, setShowParentGate] = useState<boolean>(false);
  const [parentAnswerInput, setParentAnswerInput] = useState<string>('');
  const [parentGateQA, setParentGateQA] = useState<{ question: string; answer: string }>({ question: '', answer: '' });
  const [wrongAttempts, setWrongAttempts] = useState<number>(0);
  const [gateLockedUntil, setGateLockedUntil] = useState<number>(0);
  const [longPressReady, setLongPressReady] = useState<boolean>(false);
  const quickStart = route.params?.quickStart || null;
  
  const timerInterval = useRef<number | null>(null);
  const checkInInterval = useRef<number | null>(null);
  const interactionInterval = useRef<number | null>(null);
  const fadeTimeout = useRef<number | null>(null);
  const startTimeRef = useRef<number | null>(null);
  const sessionSaltRef = useRef<string>('');
  const appState = useRef(AppState.currentState);
  const cameraRef = useRef<any>(null);
  const scheduledNotifications = useRef<string[]>([]);

  useEffect(() => {
    loadUserData();
    loadSessionData();
    
    // Get selected subject from navigation if available
    if (route.params?.selectedSubject) {
      setCurrentSubject(route.params.selectedSubject);
      startStudyingWithSubject(route.params.selectedSubject);
    }
    
    const subscription = AppState.addEventListener('change', handleAppStateChange);
    return () => {
      clearAllIntervals();
      subscription?.remove();
    };
  }, []);

  const clearAllIntervals = () => {
    if (timerInterval.current) scheduler.clearInterval(timerInterval.current as any);
    if (checkInInterval.current) scheduler.clearInterval(checkInInterval.current as any);
    if (interactionInterval.current) scheduler.clearInterval(interactionInterval.current as any);
    if (fadeTimeout.current) scheduler.clearTimeout(fadeTimeout.current as any);
    timerInterval.current = null;
    checkInInterval.current = null;
    interactionInterval.current = null;
    fadeTimeout.current = null;
  };

  const handleAppStateChange = (nextAppState) => {
    if (appState.current.match(/inactive|background/) && nextAppState === 'active') {
      if (isStudying) {
        showEncouragement();
        cancelScheduledCheckIns();
      }
      checkNotificationAction();
    }
    if (nextAppState.match(/inactive|background/) && isStudying) {
      scheduleBackgroundCheckIns();
    }
    appState.current = nextAppState;
  };

  const checkNotificationAction = async () => {
    const action = await getStringKey('lastNotifAction' as any);
    if (!action) return;
    await setStringKey('lastNotifAction' as any, '');
    if (action === 'RESUME') {
      if (!isStudying) {
        const fallbackSubject = currentSubject || getSubjectsForAge(ageGroup)[0] || { id: 'other', label: 'Other' };
        startStudyingWithSubject(fallbackSubject);
      }
    } else if (action === 'BREAK') {
      takeBreak();
    } else if (action === 'DONE') {
      endSession();
    }
  };

  const loadUserData = async () => {
    const buddyData = await getStorageItem('selectedBuddy');
    const age = await getStorageItem('selectedAge');
    if (buddyData) setBuddy(JSON.parse(buddyData));
    if (age) setAgeGroup(age);
  };

  const loadSessionData = async () => {
    const streak = await getStringKey('currentStreak' as any);
    const totalTime = await getStringKey('totalFocusTime' as any);
    if (streak) setCurrentStreak(parseInt(streak));
    if (totalTime) setTotalFocusTime(parseInt(totalTime));
  };

  const startStudyingWithSubject = (subject: { id: string; label: string }) => {
    setCurrentSubject(subject);
    setIsStudying(true);
    setSessionTime(0);
    setBuddyFaded(false);
    setSessionLog([]);
    startTimeRef.current = Date.now();
    sessionSaltRef.current = Math.random().toString(36).slice(2, 10);
    
    const baseConfig = getAgeConfig(ageGroup);
    const sessionLength = quickStart?.workMinutes ? quickStart.workMinutes * 60 : baseConfig.sessionLength;
    const breakDuration = quickStart?.breakMinutes ? quickStart.breakMinutes * 60 : baseConfig.breakDuration;
    
    // Check for special events
    checkForSpecialEvents();
    
    // Setup all timers using configured values
    setupSessionTimers({ ...baseConfig, sessionLength, breakDuration });
    
    // Initial encouragement
    smartSpeak(`Let's work on ${subject.label}! ${config.startMessage}`, {
      screenType: 'main',
      language: 'en'
    });
    
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    track('session_start', { subjectId: subject.id, ageGroup });
  };

  const setupSessionTimers = (config: { sessionLength: number; breakDuration: number; checkInFrequency: number; interactionFrequency: number }) => {
    // Main timer - compute elapsed to reduce drift
    timerInterval.current = scheduler.setInterval(() => {
      if (startTimeRef.current) {
        const elapsed = Math.floor((Date.now() - startTimeRef.current) / 1000);
        setSessionTime(elapsed);
      }
    }, 1000);
    
    // Voice check-ins using adaptive frequency per subject
    const adaptiveMinutesPromise = getAdaptiveCheckInMinutes(ageGroup, (currentSubject?.id || 'other'), config.checkInFrequency);
    let checkInTime = config.checkInFrequency * 60 * 1000;
    adaptiveMinutesPromise.then((mins) => {
      checkInTime = mins * 60 * 1000;
      if (checkInInterval.current) {
        scheduler.clearInterval(checkInInterval.current as any);
        checkInInterval.current = scheduler.setInterval(() => {
          if (shouldTriggerSurprise()) {
            showSurpriseEvent();
          } else {
            showCheckInMessage();
          }
        }, checkInTime);
      }
    }).catch(() => {});
    // initial interval until adaptive promise resolves
    checkInInterval.current = scheduler.setInterval(() => {
      if (shouldTriggerSurprise()) {
        showSurpriseEvent();
      } else {
        showCheckInMessage();
      }
    }, checkInTime);
    
    // Two-way interaction using config frequency
    const interactionTime = config.interactionFrequency * 60 * 1000;
    interactionInterval.current = scheduler.setInterval(() => {
      showInteractionPrompt();
    }, interactionTime);
    
    // Buddy fade using configured delay
    fadeTimeout.current = scheduler.setTimeout(() => {
      setBuddyFaded(true);
    }, TIMING_CONFIG.session.buddyFadeDelay);
  };

  const scheduleBackgroundCheckIns = async () => {
    try {
      const config = getAgeConfig(ageGroup);
      const intervalMs = config.checkInFrequency * 60 * 1000;
      // Schedule next 3 check-ins using peer-style generator
      const toSchedule = [1, 2, 3].map(i => ({
        content: {
          title: 'Study Buddy',
          body: generatePeerLine({
            ageGroup,
            buddyPersonality: buddy?.personality,
            subjectId: currentSubject?.id || 'other',
            seconds: sessionTime + Math.floor((intervalMs * i) / 1000),
            sessionLength: getAgeConfig(ageGroup).sessionLength,
            context: 'backgroundReturn',
            sessionId: `${startTimeRef.current || 'default'}:${sessionSaltRef.current || 'salt'}`,
          }).replace(/[^\w\s]/g, ''),
          categoryIdentifier: 'checkin-actions',
        },
        trigger: { seconds: Math.max(5, Math.floor((intervalMs * i) / 1000)) },
      }));
      const ids = [];
      for (const n of toSchedule) {
        const id = await Notifications.scheduleNotificationAsync({ content: n.content, trigger: n.trigger });
        ids.push(id);
      }
      scheduledNotifications.current = ids;
    } catch (e) {
      captureError(e, { screen: 'Main', op: 'scheduleBackgroundCheckIns' });
    }
  };

  const cancelScheduledCheckIns = async () => {
    try {
      for (const id of scheduledNotifications.current) {
        await Notifications.cancelScheduledNotificationAsync(id);
      }
      scheduledNotifications.current = [];
    } catch (e) {
      captureError(e, { screen: 'Main', op: 'cancelScheduledCheckIns' });
    }
  };

  const checkForSpecialEvents = () => {
    // Mystery Monday check
    const mysteryChange = getMysteryMondayChange();
    if (mysteryChange) {
      Alert.alert('Mystery Monday! üé≠', mysteryChange);
      setCurrentSurprise({ emoji: 'üé≠', message: mysteryChange });
    }
    
    // Seasonal theme check
    const seasonalTheme = getCurrentSeasonalTheme();
    if (seasonalTheme) {
      console.log(`Seasonal theme: ${seasonalTheme.name} ${seasonalTheme.emoji}`);
    }
  };

  const showSurpriseEvent = () => {
    const surprise = getRandomSurpriseEvent();
    setCurrentSurprise(surprise);
    
    uiAlert(
      `${surprise.emoji} Surprise!`,
      surprise.message,
      [{ text: 'Awesome!', style: 'default' }]
    );
    
    const config = getAgeConfig(ageGroup);
    speakWithBuddy({ buddy, ageGroup, text: surprise.message, options: { screenType: 'main', forceSpeak: true } });
    hapticSuccess();
  };

  const showCheckInMessage = async () => {
    const config = getAgeConfig(ageGroup);
    const line = generatePeerLine({
      ageGroup,
      buddyPersonality: buddy?.personality,
      subjectId: currentSubject?.id || 'other',
      seconds: sessionTime,
      sessionLength: config.sessionLength,
      context: 'tick',
      sessionId: `${startTimeRef.current || 'default'}:${sessionSaltRef.current || 'salt'}`,
    });
    setCheckInMessage(line);
    setShowCheckIn(true);
    setBuddyFaded(false);
    setTimeout(() => setBuddyFaded(true), TIMING_CONFIG.session.checkInDisplay);
    const voice = await resolveVoiceForBuddy({ ageGroup, buddy });
    await smartSpeak(line.replace(/[^\w\s]/gi, ''), {
      screenType: 'main',
      language: voice.language,
      rate: voice.rate,
      pitch: voice.pitch,
      voice: voice.voice,
    });
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setTimeout(() => setShowCheckIn(false), TIMING_CONFIG.session.checkInDisplay);
  };

  const showInteractionPrompt = () => {
    const questions = getInteractionQuestions();
    const randomQuestion = questions[Math.floor(Math.random() * questions.length)];
    setCurrentQuestion(randomQuestion);
    setShowInteractionModal(true);
    
    // Auto-pause if no response using configured timeout
    setTimeout(() => {
      if (showInteractionModal) {
        pauseSession();
        uiAlert('Timer Paused', 'Tap to continue when ready!');
      }
    }, TIMING_CONFIG.session.modalTimeout);
    
    const config = getAgeConfig(ageGroup);
    speakWithBuddy({ buddy, ageGroup, text: randomQuestion.text });
  };

  const getInteractionQuestions = () => {
    // Dynamic questions based on current subject
    const baseQuestions = [
      {
        id: 'subject',
        text: 'What are you working on?',
        options: getSubjectsForAge(ageGroup).slice(0, 4).map(subject => ({
          label: `${subject.emoji} ${subject.label}`,
          value: subject.id
        }))
      },
      {
        id: 'progress',
        text: 'How much have you finished?',
        options: [
          { label: 'All done! ‚úÖ', value: 'complete' },
          { label: 'Most üîµ', value: 'most' },
          { label: 'Half üü°', value: 'half' },
          { label: 'Just started üî¥', value: 'started' }
        ]
      },
      {
        id: 'difficulty',
        text: "How's it going?",
        options: [
          { label: 'Easy! üòä', value: 'easy' },
          { label: 'OK üòê', value: 'ok' },
          { label: 'Hard üòü', value: 'hard' },
          { label: 'Need help üÜò', value: 'help' }
        ]
      }
    ];
    
    return baseQuestions;
  };

  const handleInteractionResponse = (response) => {
    const logEntry = {
      time: sessionTime,
      question: currentQuestion.id,
      response: response.value,
      timestamp: new Date().toISOString()
    };
    
    setSessionLog([...sessionLog, logEntry]);
    setShowInteractionModal(false);
    // Feed adaptive model
    try { recordInteraction(currentSubject?.id || 'other', response.value); } catch {}
    
    // Handle special responses
    if (response.value === 'help') {
      handleHelpRequest();
    } else {
      provideFeedback(response.value);
    }
  };

  const handleHelpRequest = () => {
    Alert.alert(
      'Need Help?',
      'Should I let your parent know?',
      [
        { text: 'No, I\'ll keep trying', style: 'cancel' },
        { text: 'Yes please', onPress: () => {
          Alert.alert('Help is on the way!', 'Keep trying, someone will check on you soon.');
        }}
      ]
    );
  };

  const provideFeedback = (responseValue) => {
    const encouragements = {
      easy: "Great! Keep crushing it!",
      ok: "Nice steady progress!",
      hard: "You're doing great even though it's tough!",
      complete: "Amazing! You finished!",
      most: "Almost there, fantastic!",
      half: "Halfway is great progress!",
      started: "Good start, keep going!"
    };
    
    if (encouragements[responseValue]) {
      const config = getAgeConfig(ageGroup);
      speakWithBuddy({ buddy, ageGroup, text: encouragements[responseValue] });
    }
  };

  const pauseSession = () => {
    clearAllIntervals();
    setIsStudying(false);
  };

  const takeBreak = () => {
    const config = getAgeConfig(ageGroup);
    
    Alert.alert(
      config.breakTitle,
      config.breakMessage,
      [
        {
          text: "Start Break",
          onPress: () => {
            pauseSession();
            saveSessionData();
            
            // Resume after configured break duration
            setTimeout(() => {
              Alert.alert(
                "Break's Over!",
                "Ready to get back to work?",
                [
                  { text: "5 More Minutes", style: "cancel" },
                  { text: config.resumeButtonText, onPress: () => startStudyingWithSubject(currentSubject) }
                ]
              );
            }, config.breakDuration * 1000); // Already in seconds from config
          }
        },
        {
          text: "Keep Working",
          style: "cancel"
        }
      ]
    );
  };

  const takeWorkPhoto = async () => {
    const { status } = await Camera.requestCameraPermissionsAsync();
    if (status === 'granted') {
      setShowProofMode(true);
    } else {
      Alert.alert('Camera Permission', 'We need camera access for one photo of your work (optional)');
    }
  };

  const capturePhoto = async () => {
    if (cameraRef.current) {
      try {
        const photo = await cameraRef.current.takePictureAsync();
        setWorkPhoto(photo.uri);
        setShowProofMode(false);
        await setStringKey('lastWorkPhoto' as any, photo.uri);
        Alert.alert('Great Work!', 'Your completed homework has been saved!');
      } catch (e) {
        captureError(e, { screen: 'Main', op: 'capturePhoto' });
        Alert.alert('Oops', 'Could not capture photo.');
      }
    }
  };

  const endSession = () => {
    const config = getAgeConfig(ageGroup);
    
    // Offer photo for older kids
    if (['tween', 'teen'].includes(ageGroup)) {
      Alert.alert(
        'Show Your Work!',
        'Take a photo of your completed homework?',
        [
          { text: 'Skip', onPress: () => completeSession() },
          { text: 'Take Photo', onPress: () => {
            takeWorkPhoto();
            completeSession();
          }}
        ]
      );
    } else {
      completeSession();
    }
  };

  const completeSession = () => {
    pauseSession();
    saveSessionData();
    
    // Award tokens based on effort (scaled by minutes and subject difficulty)
    const minutes = Math.floor(sessionTime / 60);
    const base = minutes >= 25 ? 5 : minutes >= 15 ? 3 : minutes >= 5 ? 1 : 0;
    addTokens(base).catch(() => {});

    navigation.navigate('Celebration', {
      sessionTime: sessionTime,
      totalTime: totalFocusTime + sessionTime,
      streak: currentStreak + 1,
      ageGroup: ageGroup,
      workPhoto: workPhoto,
      sessionLog: sessionLog,
      tokenAward: base
    });
    track('session_end', { duration: sessionTime, ageGroup, subjectId: currentSubject?.id });
  };

  const saveSessionData = async () => {
    const newTotalTime = totalFocusTime + sessionTime;
    const newStreak = currentStreak + 1;
    
    // Save all session data
    const savePromises = [
      setStringKey('totalFocusTime' as any, newTotalTime.toString()),
      setStringKey('currentStreak' as any, newStreak.toString()),
      setStringKey('lastSessionDate' as any, new Date().toISOString()),
      setStringKey('lastSessionLog' as any, JSON.stringify(sessionLog))
    ];
    
    try { await Promise.all(savePromises); } catch (e) { captureError(e, { screen: 'Main', op: 'saveSessionData' }); }
    
    setTotalFocusTime(newTotalTime);
    setCurrentStreak(newStreak);
  };

  const showEncouragement = () => {
    const config = getAgeConfig(ageGroup);
    speakWithBuddy({ buddy, ageGroup, text: config.welcomeBackMessage });
  };

  const openParentSettings = () => {
    // Check if gate is locked
    const now = Date.now();
    if (now < gateLockedUntil) {
      const remainingSeconds = Math.ceil((gateLockedUntil - now) / 1000);
      Alert.alert('Please Wait', `Parent gate is locked for ${remainingSeconds} more seconds`);
      return;
    }
    
    // Try biometric first if available
    LocalAuthentication.hasHardwareAsync().then(async (hasHardware) => {
      if (hasHardware) {
        const enrolled = await LocalAuthentication.isEnrolledAsync();
        if (enrolled) {
          const res = await LocalAuthentication.authenticateAsync({ promptMessage: 'Parent Access' });
          if (res.success) {
            navigation.navigate('ParentSettings', { sessionLog });
            return;
          }
        }
      }
      // Fallback: PIN if set, otherwise math gate
      const pin = await getStorageItem('parentPin');
      if (pin) {
        setParentGateQA({ question: 'Enter 4-digit PIN', answer: pin });
        setParentAnswerInput('');
        setLongPressReady(false);
        setShowParentGate(true);
      } else {
        const newGate = generateParentGate(getAgeConfig(ageGroup));
        setParentGateQA(newGate);
        setParentAnswerInput('');
        setLongPressReady(false);
        setShowParentGate(true);
      }
    });
  };

  // Camera mode render
  if (showProofMode) {
    return (
      <Camera style={styles.camera} ref={cameraRef}>
        <View style={styles.cameraContainer}>
          <Text style={[
            styles.cameraText,
            { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
          ]}>
            Show your completed work!
          </Text>
          <TouchableOpacity 
            style={[
              styles.captureButton,
              { 
                width: getScaledSize(70, ageGroup, 'buttonScale'),
                height: getScaledSize(70, ageGroup, 'buttonScale'),
                borderRadius: getScaledSize(35, ageGroup, 'buttonScale')
              }
            ]} 
            onPress={capturePhoto}
          >
            <Text style={[
              styles.captureButtonText,
              { fontSize: getScaledSize(40, ageGroup, 'iconSize') }
            ]}>
              üì∏
            </Text>
          </TouchableOpacity>
        </View>
      </Camera>
    );
  }

  const config = getAgeConfig(ageGroup);

  return (
    <SafeAreaView style={[styles.safeArea]}>
      <ScreenBackground ageGroup={ageGroup}>
      <View style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity onPress={openParentSettings} style={styles.settingsButton} accessibilityRole="button" accessibilityLabel="Parent settings">
            <Text style={[
              styles.settingsIcon,
              { fontSize: getScaledSize(24, ageGroup, 'iconSize') }
            ]}>
              ‚öôÔ∏è
            </Text>
          </TouchableOpacity>
          <View style={[
            styles.streakContainer,
            { backgroundColor: (config.theme?.accent || '#FFF3CD') + '40' }
          ]}>
            <Text style={[
              styles.streakText,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              üî• {currentStreak} {config.streakLabel}
            </Text>
          </View>
        </View>

        <BuddyCharacter 
          buddy={buddy} 
          isStudying={isStudying}
          isFaded={buddyFaded}
          ageGroup={ageGroup}
          style={styles.buddyContainer}
        />

        {showCheckIn && (
          <CheckInMessage message={checkInMessage} ageGroup={ageGroup} />
        )}

        {isStudying && (
          <StudyTimer seconds={sessionTime} ageGroup={ageGroup} />
        )}

        <View style={[
          styles.buttonContainer,
          { paddingVertical: getScaledSize(30, ageGroup, 'spacing') }
        ]}>
          {!isStudying ? (
            <BigButton 
              title={config.startButtonText}
              onPress={() => navigation.navigate('ModeSelection')}
              color={config.primaryColor}
              ageGroup={ageGroup}
            />
          ) : (
            <>
              <BigButton 
                title={config.breakButtonText}
                onPress={takeBreak}
                color="#F39C12"
                ageGroup={ageGroup}
              />
              <BigButton 
                title={config.endButtonText}
                onPress={endSession}
                color="#E74C3C"
                ageGroup={ageGroup}
                style={{ marginTop: getScaledSize(20, ageGroup, 'spacing') }}
              />
            </>
          )}
        </View>

        <View style={styles.statsContainer}>
          <Text style={[
            styles.statsText,
            { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
          ]}>
            {config.statsLabel}: {Math.floor(totalFocusTime / 60)} minutes
          </Text>
        </View>
      </View>

      {/* Two-Way Interaction Modal */}
      <Modal
        visible={showInteractionModal}
        transparent={true}
        animationType="slide"
      >
        <View style={styles.modalContainer}>
          <View style={[
            styles.modalContent,
            { padding: getScaledSize(30, ageGroup, 'spacing') }
          ]}>
            <Text style={[
              styles.modalTitle,
              { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
            ]}>
              {currentQuestion?.text}
            </Text>
            <View style={styles.optionsContainer}>
              {currentQuestion?.options.map((option) => (
                <TouchableOpacity
                  key={option.value}
                  style={[
                    styles.optionButton,
                    { 
                      paddingVertical: getScaledSize(15, ageGroup, 'spacing'),
                      paddingHorizontal: getScaledSize(25, ageGroup, 'spacing'),
                      borderColor: config.accentColor 
                    }
                  ]}
                  onPress={() => handleInteractionResponse(option)}
                >
                  <Text style={[
                    styles.optionText,
                    { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
                  ]}>
                    {option.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>
        </View>
      </Modal>

      {/* Surprise Event Display */}
      {currentSurprise && (
        <View style={[
          styles.surpriseBanner,
          { 
            padding: getScaledSize(15, ageGroup, 'spacing'),
            top: getScaledSize(100, ageGroup, 'spacing') 
          }
        ]}>
          <Text style={[
            styles.surpriseText,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            {currentSurprise.emoji} {currentSurprise.message}
          </Text>
        </View>
      )}

      {/* Parent Gate Modal */}
      <Modal
        visible={showParentGate}
        transparent={true}
        animationType="fade"
      >
        <View style={styles.modalContainer}>
          <View style={[styles.modalContent, { padding: getScaledSize(30, ageGroup, 'spacing') }]}>
            <Text style={[styles.modalTitle, { fontSize: getScaledSize(20, ageGroup, 'fontSize') }]}>Parent Access</Text>
            
            {/* Long Press Instruction */}
            {!longPressReady && (
              <TouchableOpacity
                onLongPress={() => {
                  setLongPressReady(true);
                  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                }}
                delayLongPress={1500}
                style={{
                  backgroundColor: '#E8F4FF',
                  padding: 15,
                  borderRadius: 10,
                  marginBottom: 15
                }}
              >
                <Text style={{ textAlign: 'center', color: '#4A90E2' }}>
                  Hold this box for 2 seconds to continue
                </Text>
              </TouchableOpacity>
            )}
            
            {/* Question and Input */}
            {longPressReady && (
              <>
                <Text style={{ marginBottom: 10 }}>{parentGateQA.question}</Text>
                <TextInput
                  keyboardType="number-pad"
                  value={parentAnswerInput}
                  onChangeText={setParentAnswerInput}
                  style={{
                    borderWidth: 1,
                    borderColor: '#ccc',
                    borderRadius: 8,
                    padding: 10,
                    width: '80%',
                    alignSelf: 'center',
                    textAlign: 'center'
                  }}
                />
                <View style={{ flexDirection: 'row', marginTop: 15, justifyContent: 'center' }}>
                  <TouchableOpacity
                    style={[styles.optionButton, { paddingHorizontal: 20, paddingVertical: 10, marginRight: 10 }]}
                    onPress={() => {
                      setShowParentGate(false);
                      setWrongAttempts(0);
                    }}
                  >
                    <Text>Cancel</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.optionButton, { paddingHorizontal: 20, paddingVertical: 10 }]}
                    onPress={async () => {
                      // If expecting PIN, compare hashed values
                      if (parentGateQA.question === 'Enter 4-digit PIN') {
                        try {
                          const Crypto = await import('expo-crypto');
                          const entered = parentAnswerInput.trim();
                          if (!/^\d{4}$/.test(entered)) {
                            Alert.alert('Try again', 'PIN must be 4 digits.');
                            return;
                          }
                          const hash = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, entered);
                          if (hash === parentGateQA.answer) {
                            setShowParentGate(false);
                            setWrongAttempts(0);
                            navigation.navigate('ParentSettings', { sessionLog });
                          } else {
                            const attempts = wrongAttempts + 1;
                            setWrongAttempts(attempts);
                            if (attempts >= 3) {
                              setGateLockedUntil(Date.now() + 30000);
                              setShowParentGate(false);
                              setWrongAttempts(0);
                              Alert.alert('Gate Locked', 'Too many wrong attempts. Please wait 30 seconds.');
                            } else {
                              Alert.alert('Try again', `Incorrect PIN. ${3 - attempts} attempts remaining.`);
                              setParentAnswerInput('');
                            }
                          }
                        } catch {
                          Alert.alert('Error', 'Unexpected error.');
                        }
                        return;
                      }

                      if (parentAnswerInput.trim() === parentGateQA.answer) {
                        setShowParentGate(false);
                        setWrongAttempts(0);
                        navigation.navigate('ParentSettings', { sessionLog });
                      } else {
                        const attempts = wrongAttempts + 1;
                        setWrongAttempts(attempts);
                        
                        if (attempts >= 3) {
                          // Lock gate for 30 seconds after 3 wrong attempts
                          setGateLockedUntil(Date.now() + 30000);
                          setShowParentGate(false);
                          setWrongAttempts(0);
                          Alert.alert('Gate Locked', 'Too many wrong attempts. Please wait 30 seconds.');
                        } else {
                          Alert.alert('Try again', `Incorrect answer. ${3 - attempts} attempts remaining.`);
                          setParentAnswerInput('');
                        }
                      }
                    }}
                  >
                    <Text>Submit</Text>
                  </TouchableOpacity>
                </View>
              </>
            )}
          </View>
        </View>
      </Modal>
      </ScreenBackground>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 20,
  },
  settingsButton: {
    padding: 10,
  },
  settingsIcon: {},
  streakContainer: {
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 20,
  },
  streakText: {
    fontWeight: 'bold',
    color: '#856404',
  },
  buddyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  buttonContainer: {},
  statsContainer: {
    alignItems: 'center',
    paddingVertical: 20,
  },
  statsText: {
    color: '#7F8C8D',
  },
  camera: {
    flex: 1,
  },
  cameraContainer: {
    flex: 1,
    backgroundColor: 'transparent',
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingBottom: 50,
  },
  cameraText: {
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 30,
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: -1, height: 1 },
    textShadowRadius: 10,
  },
  captureButton: {
    backgroundColor: 'white',
    justifyContent: 'center',
    alignItems: 'center',
  },
  captureButtonText: {},
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 20,
    width: '90%',
    maxWidth: 400,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 10,
    elevation: 10,
  },
  modalTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 30,
    textAlign: 'center',
  },
  optionsContainer: {
    width: '100%',
  },
  optionButton: {
    backgroundColor: '#F0F8FF',
    borderRadius: 15,
    marginBottom: 12,
    borderWidth: 2,
  },
  optionText: {
    fontWeight: '600',
    color: '#2C3E50',
    textAlign: 'center',
  },
  surpriseBanner: {
    position: 'absolute',
    left: 20,
    right: 20,
    backgroundColor: '#FFD700',
    borderRadius: 20,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 10,
    elevation: 10,
  },
  surpriseText: {
    fontWeight: 'bold',
    color: '#2C3E50',
  },
});
```

---

## study-buddy/src/screens/CalmModeScreen.tsx
```tsx
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Alert,
  Animated
} from 'react-native';
import * as Speech from 'expo-speech';
import * as Haptics from 'expo-haptics';
import { getStorageItem, setStorageItem } from '@utils/core/storage';
import BuddyCharacter from '@components/BuddyCharacter';
import BigButton from '@components/BigButton';
import { 
  getAgeConfig, 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import ScreenBackground from '@components/ScreenBackground';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { speakWithBuddy } from '@utils/voice/speakWithBuddy';
import { success as hapticSuccess } from '@utils/feedback';
import { uiAlert } from '@ui/alerts';
import { t } from '@utils/intl/i18n';

const { width, height } = Dimensions.get('window');

type Props = StackScreenProps<RootStackParamList, 'CalmMode'>;

export default function CalmModeScreen({ navigation }: Props) {
  const [buddy, setBuddy] = useState(null);
  const [ageGroup, setAgeGroup] = useState('elementary');
  const [isCalming, setIsCalming] = useState(false);
  const [sessionTime, setSessionTime] = useState(0);
  const [breathCount, setBreathCount] = useState(0);
  const [calmStreak, setCalmStreak] = useState(0);
  
  const breathingAnim = useRef(new Animated.Value(1)).current;
  const [isInhale, setIsInhale] = useState(true);
  const timerInterval = useRef(null);
  const breathingInterval = useRef(null);

  useEffect(() => {
    loadUserData();
    loadCalmData();
    
    return () => {
      if (timerInterval.current) clearInterval(timerInterval.current);
      if (breathingInterval.current) clearInterval(breathingInterval.current);
    };
  }, []);

  const loadUserData = async () => {
    const buddyData = await getStorageItem('selectedBuddy');
    const age = await getStorageItem('selectedAge');
    if (buddyData) setBuddy(JSON.parse(buddyData));
    if (age) setAgeGroup(age);
  };

  const loadCalmData = async () => {
    const streak = await getStorageItem('calmStreak');
    if (streak) setCalmStreak(parseInt(streak));
  };

  const startCalming = () => {
    setIsCalming(true);
    setSessionTime(0);
    setBreathCount(0);
    
    const config = getAgeConfig(ageGroup);
    
    // Start timer - minimum 5 minutes
    timerInterval.current = setInterval(() => {
      setSessionTime(prev => {
        if (prev >= 300) { // 5 minutes minimum
          offerToFinish();
        }
        return prev + 1;
      });
    }, 1000);
    
    // Start breathing exercise with configured timing
    startBreathingExercise();
    
    // Initial calming message based on age
    const calmMessage = getCalmingMessage(config);
    speakWithBuddy({ buddy, ageGroup, text: calmMessage, options: { screenType: 'calm' } });
    hapticSuccess();
  };

  const getCalmingMessage = (config) => {
    const messages = {
      young: "Let's take some big breaths together. You're safe.",
      elementary: "Time to calm down. Breathe with me.",
      tween: "Let's reset. Deep breaths.",
      teen: "Breathing exercise. Follow the circle."
    };
    return messages[ageGroup] || messages.elementary;
  };

  const startBreathingExercise = () => {
    breathingInterval.current = setInterval(() => {
      // Breathe in and out cycle using configured timing
      Animated.sequence([
        Animated.timing(breathingAnim, {
          toValue: 1.5,
          duration: TIMING_CONFIG.animations.breathingIn,
          useNativeDriver: true,
        }),
        Animated.timing(breathingAnim, {
          toValue: 1,
          duration: TIMING_CONFIG.animations.breathingOut,
          useNativeDriver: true,
        }),
      ]).start(() => {
        setIsInhale(prev => !prev);
      });
      
      setBreathCount(prev => prev + 1);
      
      // Voice guidance every 3 breaths
      if ((breathCount + 1) % 3 === 0) {
        const prompts = getBreathingPrompts(ageGroup);
        const config = getAgeConfig(ageGroup);
        speakWithBuddy({ buddy, ageGroup, text: prompts[(breathCount + 1) % prompts.length], options: { screenType: 'calm' } });
      }
    }, TIMING_CONFIG.session.breathingCycle);
  };

  const getBreathingPrompts = (ageGroup) => {
    const prompts = {
      young: ["Big breath in... and out...", "You're doing great", "Nice and slow", "Feel better"],
      elementary: ["In... and out...", "You're doing great", "Nice and slow", "Feel calmer"],
      tween: ["Breathe in... breathe out...", "Good", "Stay calm", "Reset"],
      teen: ["In... out...", "Focus", "Steady", "Center"]
    };
    return prompts[ageGroup] || prompts.elementary;
  };

  const offerToFinish = () => {
    uiAlert(
      "Feeling Better?",
      "You've been calming for 5 minutes. Ready to stop?",
      [
        { text: "Keep Going", style: "cancel" },
        { text: "I'm Ready", onPress: finishCalming }
      ]
    );
  };

  const finishCalming = () => {
    setIsCalming(false);
    clearInterval(timerInterval.current);
    clearInterval(breathingInterval.current);
    
    saveCalmData();
    
    const finishMessage = getFinishMessage(ageGroup);
    uiAlert(
      "Great Job! üåü",
      finishMessage,
      [
        { text: "Not Yet", onPress: () => navigation.navigate('ModeSelection') },
        { 
          text: "Tell Parent", 
          onPress: () => {
            uiAlert("Message Sent!", "Someone will check on you soon.");
            navigation.navigate('ModeSelection');
          }
        }
      ]
    );
  };

  const getFinishMessage = (ageGroup) => {
    const messages = {
      young: "You did amazing at calming down! Want to tell someone you're ready?",
      elementary: "You did great at calming down. Want to tell someone you're ready?",
      tween: "Good work calming down. Want to let someone know you're ready?",
      teen: "Well done. Ready to tell someone you're good?"
    };
    return messages[ageGroup] || messages.elementary;
  };

  const saveCalmData = async () => {
    const newStreak = calmStreak + 1;
    const calmLog = {
      duration: sessionTime,
      breathCount: breathCount,
      timestamp: new Date().toISOString()
    };
    
    await Promise.all([
      setStorageItem('calmStreak', newStreak.toString()),
      setStorageItem('lastCalmSession', new Date().toISOString()),
      setStorageItem('lastCalmLog', JSON.stringify(calmLog))
    ]);
  };

  const config = getAgeConfig(ageGroup);

  return (
    <SafeAreaView style={[styles.safeArea]}>
      <ScreenBackground ageGroup={ageGroup}>
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()} style={styles.backButton}>
            <Text style={[
              styles.backText,
              { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
            ]}>
              ‚Üê
            </Text>
          </TouchableOpacity>
          <View style={[
            styles.streakContainer,
            { backgroundColor: config.accentColor + '20' }
          ]}>
            <Text style={[
              styles.streakText,
              { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
            ]}>
              üßò {calmStreak} calm sessions
            </Text>
          </View>
        </View>

        {/* Breathing Circle */}
        {isCalming && (
          <Animated.View 
            style={[
              styles.breathingCircle,
              {
                width: getScaledSize(200, ageGroup, 'buddySize'),
                height: getScaledSize(200, ageGroup, 'buddySize'),
                borderRadius: getScaledSize(100, ageGroup, 'buddySize'),
                transform: [{ scale: breathingAnim }]
              }
            ]}
          >
            <Text style={[
              styles.breathText,
              { fontSize: getScaledSize(20, ageGroup, 'fontSize') }
            ]}>
              {isInhale ? 'Breathe In' : 'Breathe Out'}
            </Text>
          </Animated.View>
        )}

        {/* Buddy (smaller and calmer) */}
        {!isCalming && buddy && (
          <View style={styles.buddyContainer}>
            <BuddyCharacter 
              buddy={buddy} 
              isStudying={false}
              isFaded={false}
              ageGroup={ageGroup}
              style={{ transform: [{ scale: 0.7 }] }}
            />
          </View>
        )}

        {/* Timer */}
        {isCalming && (
          <View style={styles.timerContainer}>
            <Text accessibilityRole="header" style=[
              styles.timerText,
              { fontSize: getScaledSize(36, ageGroup, 'fontSize') }
            ]}>
              {Math.floor(sessionTime / 60)}:{(sessionTime % 60).toString().padStart(2, '0')}
            </Text>
            <Text style={[
              styles.breathCountText,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              {breathCount} breaths
            </Text>
          </View>
        )}

        {/* Action Buttons */}
        <View style={[
          styles.buttonContainer,
          { paddingVertical: getScaledSize(30, ageGroup, 'spacing') }
        ]}>
          {!isCalming ? (
            <BigButton 
              title="Start Calming üåä"
              onPress={startCalming}
              color="#2196F3"
              ageGroup={ageGroup}
            />
          ) : (
            <BigButton 
              title="I'm Ready to Talk"
              onPress={finishCalming}
              color="#4CAF50"
              ageGroup={ageGroup}
            />
          )}
        </View>

        {/* Calm Tips */}
        {!isCalming && (
          <View style={styles.tipsContainer}>
            <Text style={[
              styles.tipText,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              {getCalmTip(ageGroup)}
            </Text>
          </View>
        )}
      </View>
      </ScreenBackground>
    </SafeAreaView>
  );
}

// Helper function for age-appropriate calm tips
function getCalmTip(ageGroup) {
  const tips = {
    young: 'üíô It\'s okay to feel big feelings',
    elementary: 'üíô Everyone needs to calm down sometimes',
    tween: 'üíô Take a moment to reset',
    teen: 'üíô Mindfulness helps focus'
  };
  return tips[ageGroup] || tips.elementary;
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 20,
  },
  backButton: {
    padding: 10,
  },
  backText: {
    color: '#2196F3',
  },
  streakContainer: {
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 20,
  },
  streakText: {
    fontWeight: 'bold',
    color: '#1565C0',
  },
  breathingCircle: {
    backgroundColor: '#64B5F6',
    justifyContent: 'center',
    alignItems: 'center',
    alignSelf: 'center',
    marginVertical: 50,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 10,
    elevation: 8,
  },
  breathText: {
    fontWeight: 'bold',
    color: 'white',
  },
  buddyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  timerContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  timerText: {
    fontWeight: 'bold',
    color: '#1565C0',
  },
  breathCountText: {
    color: '#7F8C8D',
    marginTop: 5,
  },
  buttonContainer: {},
  tipsContainer: {
    position: 'absolute',
    bottom: 50,
    left: 20,
    right: 20,
    alignItems: 'center',
  },
  tipText: {
    color: '#5E92B8',
    textAlign: 'center',
    fontStyle: 'italic',
  },
});
```

---

## study-buddy/src/screens/ParentSettingsScreen.tsx
```tsx
import React, { useState, useEffect, useContext } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
  Switch,
  Alert,
  TextInput
} from 'react-native';
import Slider from '@react-native-community/slider';
import { Audio } from 'expo-av';
import { getStorageItem, setStorageItem } from '@utils/core/storage';
import { 
  getAgeConfig, 
  getScaledSize,
  UI_SCALING_CONFIG
} from '@utils/config/constants';
import { t, getCurrentLanguage, setLanguage, getAvailableLanguages } from '@utils/intl/i18n';
import { SubscriptionContext } from '../../App';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getStringKey, setStringKey, removeKey } from '@utils/core/storageKeys';
import * as Crypto from 'expo-crypto';
import { computeWeeklyInsights } from '@utils/insights';
import { getBalance, getRewardsCatalog, redeemTokens, logRedemption } from '@utils/rewards';

type Props = StackScreenProps<RootStackParamList, 'ParentSettings'>;

export default function ParentSettingsScreen({ navigation, route }: Props) {
  const [ageGroup, setAgeGroup] = useState('elementary');
  const [workDuration, setWorkDuration] = useState(25);
  const [breakDuration, setBreakDuration] = useState(5);
  const [checkInFrequency, setCheckInFrequency] = useState(5);
  const [interactionFrequency, setInteractionFrequency] = useState(20);
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [vibrationEnabled, setVibrationEnabled] = useState(true);
  const [twoWayInteraction, setTwoWayInteraction] = useState(true);
  const [encouragementMessages, setEncouragementMessages] = useState([]);
  const [recording, setRecording] = useState(null);
  const [lastSessionLog, setLastSessionLog] = useState([]);
  const [appLanguage, setAppLanguage] = useState(getCurrentLanguage());
  const [speechSettings, setSpeechSettings] = useState({
    mainScreenEnabled: true,
    calmModeEnabled: true,
    celebrationEnabled: true,
    rate: 1.0,
    pitch: 1.0,
  });
  const [photoSettings, setPhotoSettings] = useState({
    autoDeleteDays: 7,
    privacyOverlay: false,
  });
  const [parentPin, setParentPin] = useState('');
  const [parentPinConfirm, setParentPinConfirm] = useState('');
  const [pinSet, setPinSet] = useState(false);
  const [insights, setInsights] = useState<{ totalMinutes: number; avgSessionMinutes: number; sessions: number; topHelps: Array<{ id: string; count: number }> } | null>(null);
  const [tokenBalance, setTokenBalance] = useState(0);
  const { isPremium } = useContext(SubscriptionContext);

  useEffect(() => {
    loadUserAge();
    loadSettings();
    loadSessionLog();
    loadInsightsAndRewards();
  }, []);
  const loadInsightsAndRewards = async () => {
    try {
      const data = await computeWeeklyInsights();
      setInsights(data);
    } catch {}
    try {
      const bal = await getBalance();
      setTokenBalance(bal);
    } catch {}
  };

  const loadUserAge = async () => {
    const age = await getStorageItem('selectedAge');
    if (age) setAgeGroup(age);
  };

  const loadSettings = async () => {
    // Load settings with age-appropriate defaults
    const config = getAgeConfig(ageGroup);
    
    const settingsMap = [
      ['workDuration', setWorkDuration, config.session?.defaultDuration || 25],
      ['breakDuration', setBreakDuration, config.session?.breakDuration / 60 || 5],
      ['checkInFrequency', setCheckInFrequency, config.checkInFrequency || 5],
      ['interactionFrequency', setInteractionFrequency, config.interactionFrequency || 20],
      ['soundEnabled', setSoundEnabled, true, 'boolean'],
      ['vibrationEnabled', setVibrationEnabled, true, 'boolean'],
      ['twoWayInteraction', setTwoWayInteraction, true, 'boolean']
    ];

    for (const [key, setter, defaultValue, type = 'number'] of settingsMap) {
      const value = await getStorageItem(key);
      if (value !== null) {
        if (type === 'boolean') {
          setter(value === 'true');
        } else {
          setter(parseInt(value));
        }
      } else {
        setter(defaultValue);
      }
    }
    
    // Load speech settings
    const speech = await getStorageItem('speechSettings');
    if (speech) {
      setSpeechSettings(JSON.parse(speech));
    }
    
    // Load photo settings
    const photo = await getStorageItem('photoSettings');
    if (photo) {
      setPhotoSettings(JSON.parse(photo));
    }

    // Load parent PIN
    const existingPin = await getStringKey('parentPin' as any);
    if (existingPin) setPinSet(true);
  };

  const loadSessionLog = async () => {
    const log = await getStorageItem('lastSessionLog');
    if (log) {
      setLastSessionLog(JSON.parse(log));
    }
    if (route.params?.sessionLog) {
      setLastSessionLog(route.params.sessionLog);
    }
  };

  const saveSettings = async () => {
    const settings = {
      workDuration: workDuration.toString(),
      breakDuration: breakDuration.toString(),
      checkInFrequency: checkInFrequency.toString(),
      interactionFrequency: interactionFrequency.toString(),
      soundEnabled: soundEnabled.toString(),
      vibrationEnabled: vibrationEnabled.toString(),
      twoWayInteraction: twoWayInteraction.toString()
    };
    
    const savePromises = Object.entries(settings).map(([key, value]) => 
      setStorageItem(key, value)
    );
    
    // Save speech settings separately as JSON
    savePromises.push(setStorageItem('speechSettings', JSON.stringify(speechSettings)));
    
    // Save photo settings
    savePromises.push(setStorageItem('photoSettings', JSON.stringify(photoSettings)));
    
    await Promise.all(savePromises);

    // Save parent PIN if provided and matches confirmation (4 digits)
    if (parentPin || parentPinConfirm) {
      if (parentPin === parentPinConfirm && /^\d{4}$/.test(parentPin)) {
        const hash = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, parentPin);
        await setStringKey('parentPin' as any, hash);
        await setStringKey('parentPinSetAt' as any, Date.now().toString());
        setPinSet(true);
      } else {
        Alert.alert('PIN mismatch', 'Please enter matching 4-digit PINs.');
        return;
      }
    }
    
    Alert.alert('Success!', 'Settings saved successfully!', [
      { text: 'OK', onPress: () => navigation.goBack() }
    ]);
  };

  const startRecordingMessage = async () => {
    try {
      await Audio.requestPermissionsAsync();
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: true,
        playsInSilentModeIOS: true,
      });

      const { recording } = await Audio.Recording.createAsync(
        Audio.RecordingOptionsPresets.HIGH_QUALITY
      );
      setRecording(recording);
      
      Alert.alert('Recording', 'Say your encouraging message now!');
    } catch (err) {
      Alert.alert('Error', 'Failed to start recording');
    }
  };

  const stopRecordingMessage = async () => {
    if (!recording) return;
    
    setRecording(null);
    await recording.stopAndUnloadAsync();
    const uri = recording.getURI();
    
    const messages = [...encouragementMessages, uri];
    setEncouragementMessages(messages);
    await setStorageItem('encouragementMessages', JSON.stringify(messages));
    
    Alert.alert('Success!', 'Your message has been saved!');
  };

  const resetProgress = () => {
    Alert.alert(
      'Reset Progress',
      'This will reset all progress and streaks. Are you sure?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Reset',
          style: 'destructive',
          onPress: async () => {
            await Promise.all([
              setStorageItem('currentStreak', '0'),
              setStorageItem('totalFocusTime', '0'),
              setStorageItem('calmStreak', '0')
            ]);
            Alert.alert('Reset Complete', 'All progress has been reset.');
          }
        }
      ]
    );
  };

  const formatSessionLog = () => {
    if (!lastSessionLog || lastSessionLog.length === 0) {
      return 'No interaction data from last session';
    }

    const responses = {
      math: 'üìä Math', reading: 'üìö Reading', writing: '‚úèÔ∏è Writing', other: 'üìù Other',
      easy: 'üòä Easy', ok: 'üòê OK', hard: 'üòü Hard', help: 'üÜò Need help',
      complete: '‚úÖ Complete', most: 'üîµ Most done', half: 'üü° Half done', started: 'üî¥ Just started'
    };

    return lastSessionLog.map((entry, index) => {
      const time = Math.floor(entry.time / 60);
      return `${time} min: ${responses[entry.response] || entry.response}`;
    }).join('\n');
  };

  const config = getAgeConfig(ageGroup);
  
  // Get age-appropriate slider ranges
  const getSliderConfig = (setting) => {
    const ranges = {
      workDuration: {
        young: { min: 5, max: 20, step: 5 },
        elementary: { min: 10, max: 30, step: 5 },
        tween: { min: 15, max: 45, step: 5 },
        teen: { min: 20, max: 60, step: 5 }
      },
      breakDuration: { min: 3, max: 15, step: 1 },
      checkInFrequency: { min: 2, max: 15, step: 1 },
      interactionFrequency: { min: 10, max: 45, step: 5 }
    };
    
    return ranges[setting][ageGroup] || ranges[setting] || { min: 1, max: 10, step: 1 };
  };

  return (
    <SafeAreaView style={[styles.safeArea]}>
      <ScreenBackground ageGroup={ageGroup}>
      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()} accessibilityRole="button" accessibilityLabel="Back">
            <Text style={[
              styles.backButton,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              ‚Üê Back
            </Text>
          </TouchableOpacity>
          <Text style={[
            styles.title,
            { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
          ]}>
            Parent Settings
          </Text>
        </View>

        {/* Session Report */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Last Session Report
          </Text>
          <Text style={[
            styles.sessionLog,
            { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
          ]}>
            {formatSessionLog()}
          </Text>
        </View>

        {/* Timer Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Timer Settings
          </Text>
          
          {[
            { key: 'workDuration', label: 'Work Duration', value: workDuration, setter: setWorkDuration, unit: 'minutes' },
            { key: 'breakDuration', label: 'Break Duration', value: breakDuration, setter: setBreakDuration, unit: 'minutes' },
            { key: 'checkInFrequency', label: 'Voice Check-in Every', value: checkInFrequency, setter: setCheckInFrequency, unit: 'minutes' }
          ].map(({ key, label, value, setter, unit }) => {
            const sliderConfig = getSliderConfig(key);
            return (
              <View key={key} style={styles.setting}>
                <Text style={[
                  styles.settingLabel,
                  { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
                ]}>
                  {label}: {value} {unit}
                </Text>
                <Slider
                  style={[
                    styles.slider,
                    { height: getScaledSize(40, ageGroup, 'spacing') }
                  ]}
                  minimumValue={sliderConfig.min}
                  maximumValue={sliderConfig.max}
                  step={sliderConfig.step}
                  value={value}
                  onValueChange={setter}
                  minimumTrackTintColor={config.accentColor}
                  maximumTrackTintColor="#D0D0D0"
                />
              </View>
            );
          })}
        </View>

        {/* Weekly Insights */}
        <View style={[styles.section, { padding: getScaledSize(20, ageGroup, 'spacing') }]}>
          <Text style={[styles.sectionTitle, { fontSize: getScaledSize(18, ageGroup, 'fontSize') }]}>This Week</Text>
          <Text style={{ color: '#2C3E50' }}>{insights ? `${insights.sessions} sessions ‚Ä¢ ${insights.totalMinutes} min total ‚Ä¢ avg ${insights.avgSessionMinutes} min` : 'No data yet'}</Text>
          {insights && insights.topHelps?.length ? (
            <View style={{ marginTop: 8 }}>
              {insights.topHelps.map(h => (
                <Text key={h.id} style={{ color: '#7F8C8D' }}>‚Ä¢ {h.id} √ó{h.count}</Text>
              ))}
            </View>
          ) : null}
        </View>

        {/* Interaction Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Check-In Settings
          </Text>
          
          <View style={styles.switchSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Two-Way Interaction
            </Text>
            <Switch
              value={twoWayInteraction}
              onValueChange={setTwoWayInteraction}
              trackColor={{ false: '#D0D0D0', true: config.accentColor }}
            />
          </View>

          {twoWayInteraction && (
            <View style={styles.setting}>
              <Text style={[
                styles.settingLabel,
                { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
              ]}>
                Ask Questions Every: {interactionFrequency} minutes
              </Text>
              <Slider
                style={[
                  styles.slider,
                  { height: getScaledSize(40, ageGroup, 'spacing') }
                ]}
                minimumValue={getSliderConfig('interactionFrequency').min}
                maximumValue={getSliderConfig('interactionFrequency').max}
                step={getSliderConfig('interactionFrequency').step}
                value={interactionFrequency}
                onValueChange={setInteractionFrequency}
                minimumTrackTintColor={config.accentColor}
                maximumTrackTintColor="#D0D0D0"
              />
            </View>
          )}
        </View>

        {/* Notification Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Notifications
          </Text>
          
          {[
            { key: 'soundEnabled', label: 'Sound Effects', value: soundEnabled, setter: setSoundEnabled },
            { key: 'vibrationEnabled', label: 'Vibration', value: vibrationEnabled, setter: setVibrationEnabled }
          ].map(({ key, label, value, setter }) => (
            <View key={key} style={styles.switchSetting}>
              <Text style={[
                styles.settingLabel,
                { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
              ]}>
                {label}
              </Text>
              <Switch
                value={value}
                onValueChange={setter}
                trackColor={{ false: '#D0D0D0', true: config.accentColor }}
              />
            </View>
          ))}
        </View>

        {/* Language Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Language / Idioma / Sprache
          </Text>
          
          <View style={{ flexDirection: 'row', justifyContent: 'space-around', marginTop: 10 }}>
            {getAvailableLanguages().map((lang) => (
              <TouchableOpacity
                key={lang.code}
                style={[
                  styles.languageButton,
                  appLanguage === lang.code && styles.languageButtonActive,
                  { padding: getScaledSize(15, ageGroup, 'spacing') }
                ]}
                onPress={async () => {
                  await setLanguage(lang.code);
                  setAppLanguage(lang.code);
                  Alert.alert('‚úì', t('saveSettings'));
                }}
              >
                <Text style={styles.languageFlag}>{lang.flag}</Text>
                <Text style={[
                  styles.languageName,
                  appLanguage === lang.code && styles.languageNameActive
                ]}>
                  {lang.name}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        {/* Speech Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Speech Settings
          </Text>

          {/* Per-Mode Speech Toggles */}
          {[
            { key: 'mainScreenEnabled', label: 'Speech during studying' },
            { key: 'calmModeEnabled', label: 'Speech in calm mode' },
            { key: 'celebrationEnabled', label: 'Speech for celebrations' }
          ].map(({ key, label }) => (
            <View key={key} style={styles.switchSetting}>
              <Text style={[
                styles.settingLabel,
                { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
              ]}>
                {label}
              </Text>
              <Switch
                value={speechSettings[key]}
                onValueChange={(value) => setSpeechSettings({...speechSettings, [key]: value})}
                trackColor={{ false: '#D0D0D0', true: config.accentColor }}
              />
            </View>
          ))}

          {/* Speech Rate */}
          <View style={styles.sliderSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Speech Speed: {speechSettings.rate.toFixed(1)}x
            </Text>
            <Slider
              style={{ height: 40, marginTop: 10 }}
              minimumValue={0.5}
              maximumValue={2.0}
              step={0.1}
              value={speechSettings.rate}
              onValueChange={(value) => setSpeechSettings({...speechSettings, rate: value})}
              minimumTrackTintColor={config.primaryColor}
              maximumTrackTintColor="#D0D0D0"
            />
          </View>

          {/* Speech Pitch */}
          <View style={styles.sliderSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Voice Pitch: {speechSettings.pitch.toFixed(1)}
            </Text>
            <Slider
              style={{ height: 40, marginTop: 10 }}
              minimumValue={0.5}
              maximumValue={2.0}
              step={0.1}
              value={speechSettings.pitch}
              onValueChange={(value) => setSpeechSettings({...speechSettings, pitch: value})}
              minimumTrackTintColor={config.primaryColor}
              maximumTrackTintColor="#D0D0D0"
            />
          </View>
        </View>

        {/* Parent PIN */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Parent PIN (optional)
          </Text>
          <Text style={{ color: '#7F8C8D', marginBottom: 10 }}>{pinSet ? 'A PIN is currently set.' : 'Set a 4-digit PIN for parent access.'} Biometrics will be used when available.</Text>
          <View style={{ width: '100%', marginBottom: 10 }}>
            <TextInput
              value={parentPin}
              onChangeText={(v) => setParentPin(v.replace(/[^0-9]/g, '').slice(0, 4))}
              placeholder={pinSet ? 'Enter new PIN (optional)' : 'Enter 4-digit PIN'}
              keyboardType="number-pad"
              secureTextEntry
              style={{ borderWidth: 1, borderColor: '#ccc', borderRadius: 8, padding: 12 }}
              maxLength={4}
            />
          </View>
          <View style={{ width: '100%' }}>
            <TextInput
              value={parentPinConfirm}
              onChangeText={(v) => setParentPinConfirm(v.replace(/[^0-9]/g, '').slice(0, 4))}
              placeholder={pinSet ? 'Confirm new PIN' : 'Confirm 4-digit PIN'}
              keyboardType="number-pad"
              secureTextEntry
              style={{ borderWidth: 1, borderColor: '#ccc', borderRadius: 8, padding: 12 }}
              maxLength={4}
            />
          </View>
          {pinSet && (
            <TouchableOpacity
              style={{ marginTop: 10, alignSelf: 'flex-start' }}
              onPress={async () => { await removeKey('parentPin' as any); await removeKey('parentPinSetAt' as any); setPinSet(false); setParentPin(''); setParentPinConfirm(''); }}
            >
              <Text style={{ color: '#E74C3C' }}>Clear existing PIN</Text>
            </TouchableOpacity>
          )}
        </View>

        {/* Photo Privacy Settings */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Photo Privacy
          </Text>

          {/* Auto-Delete Setting */}
          <View style={styles.sliderSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Auto-delete photos after: {photoSettings.autoDeleteDays} days
            </Text>
            <Slider
              style={{ height: 40, marginTop: 10 }}
              minimumValue={1}
              maximumValue={30}
              step={1}
              value={photoSettings.autoDeleteDays}
              onValueChange={(value) => setPhotoSettings({...photoSettings, autoDeleteDays: value})}
              minimumTrackTintColor={config.primaryColor}
              maximumTrackTintColor="#D0D0D0"
            />
            <Text style={{ fontSize: 12, color: '#7F8C8D', marginTop: 5 }}>
              Photos are stored locally only and never synced to cloud
            </Text>
          </View>

          {/* Privacy Overlay Toggle */}
          <View style={styles.switchSetting}>
            <Text style={[
              styles.settingLabel,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Privacy blur overlay
            </Text>
            <Switch
              value={photoSettings.privacyOverlay}
              onValueChange={(value) => setPhotoSettings({...photoSettings, privacyOverlay: value})}
              trackColor={{ false: '#D0D0D0', true: config.accentColor }}
            />
          </View>
        </View>

        {/* Custom Messages */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.sectionTitle,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            Custom Encouragement
          </Text>
          
          <TouchableOpacity
            style={[
              styles.recordButton,
              recording && styles.recordingActive,
              { 
                padding: getScaledSize(15, ageGroup, 'spacing'),
                backgroundColor: recording ? '#C0392B' : '#E74C3C'
              }
            ]}
            testID="record-encouragement"
            onPress={recording ? stopRecordingMessage : startRecordingMessage}
          >
            <Text style={[
              styles.recordButtonText,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              {recording ? '‚èπÔ∏è Stop Recording' : 'üé§ Record Message'}
            </Text>
          </TouchableOpacity>
          
          <Text style={[
            styles.hint,
            { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
          ]}>
            Record encouraging messages in your voice for check-ins!
          </Text>
        </View>

        {/* Rewards */}
        <View style={[styles.section, { padding: getScaledSize(20, ageGroup, 'spacing') }]}>
          <Text style={[styles.sectionTitle, { fontSize: getScaledSize(18, ageGroup, 'fontSize') }]}>Rewards</Text>
          <Text style={{ color: '#2C3E50', marginBottom: 8 }}>Balance: {tokenBalance} tokens</Text>
          {getRewardsCatalog().map(r => (
            <TouchableOpacity key={r.id} style={{ backgroundColor: '#F0F8FF', borderRadius: 10, padding: 12, marginBottom: 8 }}
              onPress={async () => {
                const ok = await redeemTokens(r.cost);
                if (ok) {
                  await logRedemption(r);
                  const bal = await getBalance();
                  setTokenBalance(bal);
                  Alert.alert('Redeemed', `${r.name}`);
                } else {
                  Alert.alert('Not enough tokens', `Need ${r.cost} tokens`);
                }
              }}>
              <Text style={{ color: '#2C3E50' }}>{r.name} ‚Äî {r.cost} tokens</Text>
            </TouchableOpacity>
          ))}
        </View>

        {/* Actions */}
        <View style={[
          styles.section,
          { padding: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          {!isPremium && (
            <TouchableOpacity 
              style={[
                styles.upgradeButton,
                { 
                  backgroundColor: '#FFD700',
                  padding: getScaledSize(15, ageGroup, 'spacing'),
                  marginBottom: 10,
                  borderRadius: 10,
                  alignItems: 'center'
                }
              ]} 
              onPress={() => navigation.navigate('Paywall', { ageGroup })}
            >
              <Text style={[
                styles.upgradeButtonText,
                { fontSize: getScaledSize(18, ageGroup, 'fontSize'), fontWeight: 'bold' }
              ]}>
                üåü Upgrade to Premium
              </Text>
            </TouchableOpacity>
          )}
          
          <TouchableOpacity 
            style={[
              styles.saveButton,
              { 
                padding: getScaledSize(15, ageGroup, 'spacing'),
                backgroundColor: config.primaryColor 
              }
            ]} 
            onPress={saveSettings}
          >
            <Text style={[
              styles.saveButtonText,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              Save Settings
            </Text>
          </TouchableOpacity>

          <TouchableOpacity 
            style={[
              styles.resetButton,
              { padding: getScaledSize(15, ageGroup, 'spacing') }
            ]} 
            onPress={resetProgress}
          >
            <Text style={[
              styles.resetButtonText,
              { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
            ]}>
              Reset All Progress
            </Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
      </ScreenBackground>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
  },
  header: {
    paddingVertical: 20,
    alignItems: 'center',
  },
  backButton: {
    position: 'absolute',
    left: 0,
    color: '#4A90E2',
  },
  title: {
    fontWeight: 'bold',
    color: '#2C3E50',
  },
  section: {
    backgroundColor: 'white',
    borderRadius: 15,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  sectionTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 20,
  },
  sessionLog: {
    color: '#2C3E50',
    lineHeight: 22,
    fontFamily: 'monospace',
  },
  setting: {
    marginBottom: 20,
  },
  settingLabel: {
    color: '#2C3E50',
    marginBottom: 10,
  },
  slider: {
    width: '100%',
  },
  switchSetting: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  recordButton: {
    borderRadius: 10,
    alignItems: 'center',
  },
  recordingActive: {
    backgroundColor: '#C0392B',
  },
  recordButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  hint: {
    color: '#7F8C8D',
    marginTop: 10,
    textAlign: 'center',
  },
  saveButton: {
    borderRadius: 10,
    alignItems: 'center',
    marginBottom: 15,
  },
  saveButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  resetButton: {
    backgroundColor: '#E74C3C',
    borderRadius: 10,
    alignItems: 'center',
  },
  resetButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  languageButton: {
    alignItems: 'center',
    backgroundColor: '#F0F8FF',
    borderRadius: 10,
    borderWidth: 2,
    borderColor: 'transparent',
  },
  languageButtonActive: {
    borderColor: '#4A90E2',
    backgroundColor: '#E8F4FF',
  },
  languageFlag: {
    fontSize: 32,
    marginBottom: 5,
  },
  languageName: {
    fontSize: 14,
    color: '#7F8C8D',
  },
  languageNameActive: {
    color: '#4A90E2',
    fontWeight: 'bold',
  },
  upgradeButton: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  upgradeButtonText: {
    color: '#2C3E50',
  },
});
```

---

## study-buddy/src/screens/CelebrationScreen.tsx
```tsx
import React, { useEffect, useRef, useState, useContext } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Dimensions,
  Share,
  Modal
} from 'react-native';
import LottieView from 'lottie-react-native';
import * as Speech from 'expo-speech';
import * as Haptics from 'expo-haptics';
import { setStorageItem, getStorageItem } from '@utils/core/storage';
import { 
  getAgeConfig, 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import ScreenBackground from '@components/ScreenBackground';
import { SubscriptionContext } from '../../App';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getAppConfig } from '@config/appConfig';
import { uiAlert } from '@ui/alerts';
import { speakWithBuddy } from '@utils/voice/speakWithBuddy';
import { success as hapticSuccess } from '@utils/feedback';
import { getBalance } from '@utils/rewards';
import { getAnimation } from '@assets/registry';

const { width, height } = Dimensions.get('window');

type Props = StackScreenProps<RootStackParamList, 'Celebration'>;

export default function CelebrationScreen({ navigation, route }: Props) {
  const { sessionTime, totalTime, streak, ageGroup, workPhoto, sessionLog, tokenAward } = route.params;
  const animationRef = useRef(null);
  const [showFeedback, setShowFeedback] = useState(false);
  const [whatWorked, setWhatWorked] = useState([]);
  const { isPremium } = useContext(SubscriptionContext);
  const [showAward, setShowAward] = useState(!!tokenAward && tokenAward > 0);

  useEffect(() => {
    celebrate();
    checkForPaywall();
    // Show feedback modal after configured delay
    setTimeout(() => setShowFeedback(true), TIMING_CONFIG.animations.celebrationDisplay);
    // Refresh balance for UI (optional future use)
    getBalance().catch(() => {});
  }, []);

  const checkForPaywall = async () => {
    if (!isPremium) {
      const sessionsCount = await getStorageItem('sessionsCount');
      const count = sessionsCount ? parseInt(sessionsCount) + 1 : 1;
      await setStorageItem('sessionsCount', count.toString());
      
      // Remote-configurable threshold
      const cfg = getAppConfig();
      const threshold = cfg.remote?.paywall?.sessionsTillPaywall ?? 3;
      if (count === threshold) {
        setTimeout(() => {
          navigation.navigate('Paywall', { ageGroup });
        }, 3000); // Show after celebration
      }
    }
  };

  const celebrate = () => {
    const config = getAgeConfig(ageGroup);
    const celebrationMessage = getCelebrationMessage(ageGroup, sessionTime);
    
    // Play celebration sound
    speakWithBuddy({ buddy: undefined, ageGroup, text: celebrationMessage, options: { screenType: 'celebration' } });
    
    // Haptic feedback
    hapticSuccess();
    
    // Play animation
    if (animationRef.current) {
      animationRef.current.play();
    }
  };

  const getCelebrationMessage = (ageGroup, sessionTime) => {
    const timeQuality = getTimeQuality(sessionTime);
    
    const messages = {
      young: {
        excellent: "WOW! You're AMAZING! Super duper job!",
        good: "Yay! You did it! I'm so proud!",
        okay: "Great job! You're learning so well!"
      },
      elementary: {
        excellent: "Amazing job! You did it! I'm so proud of you!",
        good: "Excellent work! You stayed focused so well!",
        okay: "Great job! You're building strong study habits!"
      },
      tween: {
        excellent: "Incredible focus! You crushed it!",
        good: "Solid work! Nice focus.",
        okay: "Good session. Keep it up."
      },
      teen: {
        excellent: "Outstanding work. Impressive focus.",
        good: "Good session. Well done.",
        okay: "Decent work. Progress made."
      }
    };
    
    return messages[ageGroup]?.[timeQuality] || messages.elementary.okay;
  };

  const getTimeQuality = (sessionTime) => {
    if (sessionTime >= 1800) return 'excellent'; // 30+ minutes
    if (sessionTime >= 900) return 'good';      // 15+ minutes
    return 'okay';                              // Under 15 minutes
  };

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const shareSuccess = async () => {
    const config = getAgeConfig(ageGroup);
    const shareMessage = getShareMessage(ageGroup, sessionTime, streak);
    
    try {
      await Share.share({ message: shareMessage });
    } catch (error) {
      console.log(error);
    }
  };

  const getShareMessage = (ageGroup, sessionTime, streak) => {
    const minutes = Math.floor(sessionTime / 60);
    const baseMessage = `üéâ My child just completed ${minutes} minutes of focused study time with Study Buddy! ${streak} day streak! üî•`;
    
    const ageSpecificAdditions = {
      young: ' They\'re such a superstar! ‚≠ê',
      elementary: ' So proud of their focus! üìö',
      tween: ' Building great study habits! üí™',
      teen: ' Excellent self-discipline! üéØ'
    };
    
    return baseMessage + (ageSpecificAdditions[ageGroup] || '');
  };

  const getAchievementBadge = (sessionTime, ageGroup) => {
    // Age-appropriate achievement thresholds
    const thresholds = {
      young: { gold: 600, silver: 300, bronze: 180 },      // 10, 5, 3 minutes
      elementary: { gold: 1200, silver: 600, bronze: 300 }, // 20, 10, 5 minutes  
      tween: { gold: 1500, silver: 900, bronze: 600 },     // 25, 15, 10 minutes
      teen: { gold: 1800, silver: 1200, bronze: 900 }      // 30, 20, 15 minutes
    };
    
    const t = thresholds[ageGroup] || thresholds.elementary;
    
    if (sessionTime >= t.gold) return 'üèÜ';
    if (sessionTime >= t.silver) return 'ü•á';
    if (sessionTime >= t.bronze) return 'ü•à';
    return 'ü•â';
  };

  const getEncouragementMessage = (sessionTime, ageGroup) => {
    const timeQuality = getTimeQuality(sessionTime);
    
    const messages = {
      young: {
        excellent: "Incredible focus! You're a study champion!",
        good: "Amazing work! You stayed focused so well!",
        okay: "Great job! Every minute counts!"
      },
      elementary: {
        excellent: "Incredible focus! You're a study champion!",
        good: "Amazing work! You stayed focused so well!",
        okay: "Great job! You're building strong study habits!"
      },
      tween: {
        excellent: "Outstanding focus! You're on fire!",
        good: "Great work! Your focus is getting stronger!",
        okay: "Good start! Building those focus muscles!"
      },
      teen: {
        excellent: "Exceptional focus. You're developing real discipline.",
        good: "Solid session. Your concentration is improving.",
        okay: "Good work. Consistency is key."
      }
    };
    
    return messages[ageGroup]?.[timeQuality] || messages.elementary.okay;
  };

  const handleWhatWorked = async (item) => {
    const newWhatWorked = whatWorked.includes(item) 
      ? whatWorked.filter(i => i !== item)
      : [...whatWorked, item];
    
    setWhatWorked(newWhatWorked);
  };

  const saveFeedback = async () => {
    const feedbackData = {
      whatWorked: whatWorked,
      sessionTime: sessionTime,
      ageGroup: ageGroup,
      timestamp: new Date().toISOString()
    };
    
    const existingFeedback = await getStorageItem('feedbackHistory');
    const history = existingFeedback ? JSON.parse(existingFeedback) : [];
    history.push(feedbackData);
    
    // Keep only last 30 sessions for performance
    if (history.length > 30) {
      history.shift();
    }
    
    await setStorageItem('feedbackHistory', JSON.stringify(history));
    setShowFeedback(false);
    
    navigation.navigate('ModeSelection');
  };

  const config = getAgeConfig(ageGroup);

  return (
    <SafeAreaView style={[styles.safeArea]}>
      <ScreenBackground ageGroup={ageGroup}>
      <View style={styles.container}>
        {/* Celebration Animation */}
        <View style={[
          styles.animationContainer,
          { height: getScaledSize(200, ageGroup, 'spacing') }
        ]}>
          <Text style={[
            styles.trophy,
            { fontSize: getScaledSize(100, ageGroup, 'iconSize') }
          ]}>
            {getAchievementBadge(sessionTime, ageGroup)}
          </Text>
          <LottieView
            ref={animationRef}
            source={getAnimation('confetti')}
            autoPlay
            loop={false}
            style={styles.lottie}
          />
          {showAward && (
            <View style={{ position: 'absolute', bottom: -10, backgroundColor: '#FFD700', paddingHorizontal: 16, paddingVertical: 8, borderRadius: 20 }}>
              <Text style={{ color: '#2C3E50', fontWeight: 'bold' }}>+{tokenAward} tokens üéüÔ∏è</Text>
            </View>
          )}
        </View>

        {/* Stats */}
        <View style={styles.statsContainer}>
          <Text style={[
            styles.title,
            { 
              fontSize: getScaledSize(32, ageGroup, 'fontSize'),
              color: config.primaryColor 
            }
          ]}>
            Amazing Job! üéâ
          </Text>
          <Text style={[
            styles.message,
            { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
          ]}>
            {getEncouragementMessage(sessionTime, ageGroup)}
          </Text>
          
          {/* Dynamic stat boxes */}
          {[
            { label: "Today's Focus Time", value: formatTime(sessionTime) },
            { label: "Current Streak", value: `üî• ${streak} days` },
            { label: "Total Focus Time", value: `${Math.floor(totalTime / 60)} minutes` }
          ].map((stat, index) => (
            <View key={index} style={[
              styles.statBox,
              { 
                paddingHorizontal: getScaledSize(30, ageGroup, 'spacing'),
                paddingVertical: getScaledSize(15, ageGroup, 'spacing'),
                minWidth: width * 0.7 
              }
            ]}>
              <Text style={[
                styles.statLabel,
                { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
              ]}>
                {stat.label}
              </Text>
              <Text style={[
                styles.statValue,
                { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
              ]}>
                {stat.value}
              </Text>
            </View>
          ))}
        </View>

        {/* Actions */}
        <View style={[
          styles.buttonContainer,
          { paddingHorizontal: getScaledSize(20, ageGroup, 'spacing') }
        ]}>
          <TouchableOpacity 
            style={[
              styles.shareButton,
              { 
                padding: getScaledSize(15, ageGroup, 'spacing'),
                marginBottom: getScaledSize(15, ageGroup, 'spacing')
              }
            ]} 
            onPress={shareSuccess}
            accessibilityRole="button"
            accessibilityLabel={t('shareSuccess')}
          >
            <Text style={[
              styles.shareButtonText,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              {t('shareSuccess')} üì§
            </Text>
          </TouchableOpacity>

          <TouchableOpacity 
            style={[
              styles.doneButton,
              { 
                padding: getScaledSize(15, ageGroup, 'spacing'),
                backgroundColor: config.primaryColor 
              }
            ]} 
            onPress={() => setShowFeedback(true)}
            accessibilityRole="button"
            accessibilityLabel={t('continue')}
          >
            <Text style={[
              styles.doneButtonText,
              { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
            ]}>
              {t('continue')}
            </Text>
          </TouchableOpacity>
        </View>
      </View>

      {/* What Worked Feedback Modal */}
      <Modal
        visible={showFeedback}
        transparent={true}
        animationType="slide"
      >
        <View style={styles.modalContainer}>
          <View style={[
            styles.modalContent,
            { padding: getScaledSize(30, ageGroup, 'spacing') }
          ]}>
            <Text style={[
              styles.modalTitle,
              { fontSize: getScaledSize(20, ageGroup, 'fontSize') }
            ]}>
              What helped you today?
            </Text>
            <Text style={[
              styles.modalSubtitle,
              { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
            ]}>
              Pick all that helped!
            </Text>
            
            <View style={styles.feedbackContainer}>
              {[
                { id: 'buddy', emoji: 'ü§ñ', label: 'Buddy' },
                { id: 'timer', emoji: '‚è∞', label: 'Timer' },
                { id: 'checkins', emoji: 'üí¨', label: 'Check-ins' },
                { id: 'breaks', emoji: 'üåü', label: 'Breaks' }
              ].map((item) => (
                <TouchableOpacity
                  key={item.id}
                  style={[
                    styles.feedbackButton,
                    whatWorked.includes(item.id) && [
                      styles.feedbackSelected,
                      { borderColor: config.accentColor }
                    ],
                    { 
                      padding: getScaledSize(15, ageGroup, 'spacing'),
                      minWidth: getScaledSize(80, ageGroup, 'spacing')
                    }
                  ]}
                  onPress={() => handleWhatWorked(item.id)}
                >
                  <Text style={[
                    styles.feedbackEmoji,
                    { fontSize: getScaledSize(30, ageGroup, 'iconSize') }
                  ]}>
                    {item.emoji}
                  </Text>
                  <Text style={[
                    styles.feedbackText,
                    { fontSize: getScaledSize(12, ageGroup, 'fontSize') }
                  ]}>
                    {item.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>

            <Text style={[
              styles.modalTitle,
              { fontSize: getScaledSize(20, ageGroup, 'fontSize') }
            ]}>
              How do you feel?
            </Text>
            
            <View style={styles.feelingContainer}>
              {[
                { id: 'great', emoji: 'üòä', label: 'Great!' },
                { id: 'good', emoji: 'üôÇ', label: 'Good' },
                { id: 'ok', emoji: 'üòê', label: 'OK' },
                { id: 'tired', emoji: 'üò¥', label: 'Tired' }
              ].map((feeling) => (
                <TouchableOpacity
                  key={feeling.id}
                  style={[
                    styles.feelingButton,
                    { padding: getScaledSize(10, ageGroup, 'spacing') }
                  ]}
                  onPress={saveFeedback}
                >
                  <Text style={[
                    styles.feelingEmoji,
                    { fontSize: getScaledSize(35, ageGroup, 'iconSize') }
                  ]}>
                    {feeling.emoji}
                  </Text>
                  <Text style={[
                    styles.feelingText,
                    { fontSize: getScaledSize(12, ageGroup, 'fontSize') }
                  ]}>
                    {feeling.label}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>

            <TouchableOpacity
              style={[
                styles.skipButton,
                { padding: getScaledSize(10, ageGroup, 'spacing') }
              ]}
              onPress={() => {
                setShowFeedback(false);
                navigation.navigate('ModeSelection');
              }}
            >
              <Text style={[
                styles.skipText,
                { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
              ]}>
                Skip
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
      </ScreenBackground>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
  },
  container: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  animationContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  trophy: {
    position: 'absolute',
    zIndex: 1,
  },
  lottie: {
    width: width,
    height: 200,
    position: 'absolute',
  },
  statsContainer: {
    alignItems: 'center',
    marginVertical: 30,
  },
  title: {
    fontWeight: 'bold',
    marginBottom: 10,
  },
  message: {
    color: '#7F8C8D',
    textAlign: 'center',
    marginBottom: 30,
  },
  statBox: {
    backgroundColor: 'white',
    borderRadius: 15,
    marginBottom: 15,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  statLabel: {
    color: '#7F8C8D',
    marginBottom: 5,
  },
  statValue: {
    fontWeight: 'bold',
    color: '#2C3E50',
  },
  buttonContainer: {
    width: '100%',
  },
  shareButton: {
    backgroundColor: '#3498DB',
    borderRadius: 10,
    alignItems: 'center',
  },
  shareButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  doneButton: {
    borderRadius: 10,
    alignItems: 'center',
  },
  doneButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 20,
    width: '90%',
    maxWidth: 400,
    alignItems: 'center',
  },
  modalTitle: {
    fontWeight: 'bold',
    color: '#2C3E50',
    marginBottom: 10,
    marginTop: 20,
  },
  modalSubtitle: {
    color: '#7F8C8D',
    marginBottom: 20,
  },
  feedbackContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    marginBottom: 20,
  },
  feedbackButton: {
    backgroundColor: '#F0F8FF',
    borderRadius: 15,
    margin: 5,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'transparent',
  },
  feedbackSelected: {
    backgroundColor: '#E3F2FD',
  },
  feedbackEmoji: {
    marginBottom: 5,
  },
  feedbackText: {
    color: '#2C3E50',
  },
  feelingContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
    marginVertical: 20,
  },
  feelingButton: {
    alignItems: 'center',
  },
  feelingEmoji: {
    marginBottom: 5,
  },
  feelingText: {
    color: '#2C3E50',
  },
  skipButton: {
    marginTop: 10,
  },
  skipText: {
    color: '#7F8C8D',
  },
});
```

---

## study-buddy/src/components/BuddyCharacter.tsx
```tsx
import React, { useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Animated, StyleProp, ViewStyle } from 'react-native';
import LottieView from 'lottie-react-native';
import { 
  getAgeConfig, 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import type { AgeGroup, Buddy } from '@types/index';

type BuddyCharacterProps = {
  buddy: Buddy | null;
  isStudying: boolean;
  isFaded: boolean;
  ageGroup?: AgeGroup;
  style?: StyleProp<ViewStyle>;
  customSize?: number | null;
};

export default function BuddyCharacter({ 
  buddy, 
  isStudying, 
  isFaded, 
  ageGroup = 'elementary', 
  style,
  customSize = null 
}: BuddyCharacterProps): JSX.Element | null {
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(1)).current;

  const config = getAgeConfig(ageGroup);
  
  // Calculate buddy size using modular system
  const buddySize = customSize || getScaledSize(config.buddySize || 180, ageGroup, 'buddySize');

  // Fade effect to prevent staring - using configured timing
  useEffect(() => {
    const targetOpacity = isStudying && isFaded ? 0.3 : 1;
    const duration = isStudying && isFaded ? TIMING_CONFIG.animations.fadeIn * 4 : TIMING_CONFIG.animations.fadeIn;
    
    Animated.timing(fadeAnim, {
      toValue: targetOpacity,
      duration,
      useNativeDriver: true,
    }).start();
  }, [isFaded, isStudying]);

  useEffect(() => {
    if (isStudying) {
      startStudyingAnimation();
    } else {
      startIdleAnimation();
    }
    
    return () => {
      scaleAnim.stopAnimation();
      rotateAnim.stopAnimation();
    };
  }, [isStudying]);

  const startStudyingAnimation = () => {
    // Gentle breathing animation using configured timing
    Animated.loop(
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 1.05,
          duration: TIMING_CONFIG.animations.breathingIn / 2, // Faster for study mode
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: TIMING_CONFIG.animations.breathingOut / 2,
          useNativeDriver: true,
        }),
      ])
    ).start();
  };

  const startIdleAnimation = () => {
    // Gentle idle sway animation
    Animated.loop(
      Animated.sequence([
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 3000,
          useNativeDriver: true,
        }),
        Animated.timing(rotateAnim, {
          toValue: -1,
          duration: 3000,
          useNativeDriver: true,
        }),
      ])
    ).start();
  };

  const spin = rotateAnim.interpolate({
    inputRange: [-1, 1],
    outputRange: ['-10deg', '10deg'],
  });

  if (!buddy) return null;

  const studyingIndicatorText = getStudyingIndicatorText(ageGroup);
  const fadedMessageText = getFadedMessageText(ageGroup);

  return (
    <Animated.View 
      style={[
        styles.container, 
        style,
        {
          opacity: fadeAnim,
          transform: [
            { scale: scaleAnim },
            { rotate: isStudying ? '0deg' : spin }
          ]
        }
      ]}
    >
      <View style={[styles.halo, { width: buddySize * 1.2, height: buddySize * 1.2, borderRadius: (buddySize * 1.2) / 2, backgroundColor: (buddy?.color || '#4A90E2') + '26' }]} />
      <View style={[
        styles.buddyCircle, 
        { 
          backgroundColor: buddy.color,
          width: buddySize,
          height: buddySize,
          borderRadius: buddySize / 2,
        }
      ]}>
        <Text style={[
          styles.buddyEmoji, 
          { fontSize: buddySize * 0.44 }
        ]}>
          {buddy.emoji}
        </Text>
      </View>
      
      {isStudying && !isFaded && (
        <View style={[
          styles.studyingIndicator,
          { 
            paddingHorizontal: getScaledSize(20, ageGroup, 'spacing'),
            paddingVertical: getScaledSize(8, ageGroup, 'spacing')
          }
        ]}>
          <Text style={[
            styles.studyingText,
            { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
          ]}>
            {studyingIndicatorText}
          </Text>
        </View>
      )}
      
      {isFaded && (
        <Text style={[
          styles.fadedMessage,
          { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
        ]}>
          {fadedMessageText}
        </Text>
      )}
    </Animated.View>
  );
}

// Helper functions for age-appropriate content
function getStudyingIndicatorText(ageGroup: AgeGroup): string {
  const indicators = {
    young: 'üìö Learning...',
    elementary: 'üìö Studying...',
    tween: 'üíª Working...',
    teen: 'üì± Focus'
  };
  return indicators[ageGroup] || indicators.elementary;
}

function getFadedMessageText(ageGroup: AgeGroup): string {
  const messages = {
    young: 'üëÄ Look at your work!',
    elementary: 'üëÄ Eyes on your work!',
    tween: 'üëÄ Stay focused',
    teen: 'üëÄ Focus'
  };
  return messages[ageGroup] || messages.elementary;
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
  },
  halo: {
    position: 'absolute',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.12,
    shadowRadius: 20,
    elevation: 6,
  },
  buddyCircle: {
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.14,
    shadowRadius: 20,
    elevation: 8,
  },
  buddyEmoji: {
    // Size set dynamically
  },
  studyingIndicator: {
    position: 'absolute',
    bottom: -30,
    backgroundColor: 'white',
    borderRadius: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.12,
    shadowRadius: 12,
    elevation: 4,
  },
  studyingText: {
    fontWeight: '600',
    color: '#2C3E50',
  },
  fadedMessage: {
    position: 'absolute',
    bottom: -30,
    color: '#7F8C8D',
    fontStyle: 'italic',
  },
});
```

---

## study-buddy/src/components/StudyTimer.tsx
```tsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { 
  getAgeConfig, 
  getScaledSize 
} from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

type StudyTimerProps = { seconds: number; ageGroup?: AgeGroup };

export default function StudyTimer({ seconds, ageGroup = 'elementary' }: StudyTimerProps): JSX.Element {
  const config = getAgeConfig(ageGroup);

  const formatTime = (totalSeconds: number) => {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const secs = totalSeconds % 60;

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  };

  const getTimerColor = (seconds: number, ageGroup: AgeGroup) => {
    // Age-appropriate color progression
    const colorProgression = {
      young: {
        early: '#27AE60',    // Green - exciting start
        middle: '#F39C12',   // Orange - keep going  
        late: '#E74C3C',     // Red - almost done!
        extended: '#9B59B6'  // Purple - wow!
      },
      elementary: {
        early: '#27AE60',    // Green
        middle: '#F39C12',   // Orange
        late: '#3498DB',     // Blue
        extended: '#9B59B6'  // Purple
      },
      tween: {
        early: '#3498DB',    // Blue - calm start
        middle: '#27AE60',   // Green - in the zone
        late: '#F39C12',     // Orange - pushing through
        extended: '#9B59B6'  // Purple - impressive
      },
      teen: {
        early: '#95A5A6',    // Gray - minimal
        middle: '#3498DB',   // Blue - focused
        late: '#27AE60',     // Green - strong
        extended: '#9B59B6'  // Purple - exceptional
      }
    };
    
    const colors = colorProgression[ageGroup] || colorProgression.elementary;
    
    if (seconds < 300) return colors.early;      // First 5 minutes
    if (seconds < 900) return colors.middle;     // 5-15 minutes  
    if (seconds < 1800) return colors.late;      // 15-30 minutes
    return colors.extended;                      // 30+ minutes
  };

  const getMilestoneMessage = (seconds, ageGroup) => {
    if (seconds % 300 !== 0) return null; // Only show every 5 minutes
    
    const minutes = Math.floor(seconds / 60);
    const milestones = {
      young: `üéâ ${minutes} minutes! You're amazing!`,
      elementary: `üéâ ${minutes} minutes! Great job!`,
      tween: `üî• ${minutes} minutes! Crushing it!`,
      teen: `üíØ ${minutes} minutes. Solid.`
    };
    
    return milestones[ageGroup] || milestones.elementary;
  };

  const timerColor = getTimerColor(seconds, ageGroup);
  const milestoneText = getMilestoneMessage(seconds, ageGroup);

  return (
    <View style={[
      styles.container, 
      { 
        backgroundColor: timerColor,
        paddingHorizontal: getScaledSize(40, ageGroup, 'spacing'),
        paddingVertical: getScaledSize(20, ageGroup, 'spacing'),
        borderRadius: getScaledSize(25, ageGroup, 'spacing')
      }
    ]}>
      <Text style={[
        styles.label,
        { fontSize: getScaledSize(14, ageGroup, 'fontSize') }
      ]}>
        Focus Time
      </Text>
      <Text style={[
        styles.time,
        { fontSize: getScaledSize(48, ageGroup, 'fontSize') }
      ]}>
        {formatTime(seconds)}
      </Text>
      {milestoneText && (
        <Text style={[
          styles.milestone,
          { fontSize: getScaledSize(16, ageGroup, 'fontSize') }
        ]}>
          {milestoneText}
        </Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    marginVertical: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 10,
    elevation: 8,
  },
  label: {
    color: 'white',
    opacity: 0.9,
    marginBottom: 5,
  },
  time: {
    fontWeight: 'bold',
    color: 'white',
  },
  milestone: {
    color: 'white',
    marginTop: 5,
  },
});
```

---

## study-buddy/src/components/CheckInMessage.tsx
```tsx
import React, { useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Animated } from 'react-native';
import { 
  getAgeConfig, 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

type CheckInMessageProps = { message: string; ageGroup?: AgeGroup };

export default function CheckInMessage({ message, ageGroup = 'elementary' }: CheckInMessageProps): JSX.Element {
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(-50)).current;

  const config = getAgeConfig(ageGroup);

  useEffect(() => {
    // Fade in and slide down using configured timing
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: TIMING_CONFIG.animations.fadeIn,
        useNativeDriver: true,
      }),
      Animated.spring(slideAnim, {
        toValue: 0,
        tension: 50,
        friction: 8,
        useNativeDriver: true,
      }),
    ]).start();

    // Fade out after configured display time
    setTimeout(() => {
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: TIMING_CONFIG.animations.fadeIn,
        useNativeDriver: true,
      }).start();
    }, TIMING_CONFIG.session.checkInDisplay);
  }, [message]);

  return (
    <Animated.View 
      style={[
        styles.container,
        {
          opacity: fadeAnim,
          transform: [{ translateY: slideAnim }],
          backgroundColor: (config.accentColor || '#4A90E2') + 'CC',
          paddingHorizontal: getScaledSize(20, ageGroup, 'spacing'),
          paddingVertical: getScaledSize(12, ageGroup, 'spacing'),
          borderRadius: getScaledSize(30, ageGroup, 'spacing'),
          top: getScaledSize(90, ageGroup, 'spacing')
        },
      ]}
    >
      <Text style={[
        styles.message,
        { fontSize: getScaledSize(18, ageGroup, 'fontSize') }
      ]}>
        {message}
      </Text>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    left: 20,
    right: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.14,
    shadowRadius: 20,
    elevation: 6,
    zIndex: 1000,
  },
  message: {
    fontWeight: '600',
    color: 'white',
    textAlign: 'center',
  },
});
```

---

## study-buddy/src/components/BigButton.tsx
```tsx
import React, { useRef } from 'react';
import { TouchableOpacity, Text, StyleSheet, Animated, StyleProp, ViewStyle } from 'react-native';
import * as Haptics from 'expo-haptics';
import { 
  getScaledSize,
  TIMING_CONFIG
} from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

type BigButtonProps = { title: string; onPress: () => void; color?: string; style?: StyleProp<ViewStyle>; ageGroup?: AgeGroup };

export default function BigButton({ 
  title, 
  onPress, 
  color = '#4A90E2', 
  style,
  ageGroup = 'elementary'
}: BigButtonProps): JSX.Element {
  const scaleAnim = useRef(new Animated.Value(1)).current;

  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: 0.95,
      tension: 100,
      friction: 10,
      useNativeDriver: true,
    }).start();
  };

  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      tension: 50,
      friction: 5,
      useNativeDriver: true,
    }).start();
  };

  const handlePress = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    onPress();
  };

  return (
    <Animated.View style={[{ transform: [{ scale: scaleAnim }] }, style]}>
      <TouchableOpacity
        style={[
          styles.button, 
          { 
            backgroundColor: color,
            paddingHorizontal: getScaledSize(40, ageGroup, 'spacing'),
            paddingVertical: getScaledSize(20, ageGroup, 'spacing'),
            borderRadius: getScaledSize(40, ageGroup, 'spacing')
          }
        ]}
        onPress={handlePress}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        activeOpacity={0.8}
        accessibilityRole="button"
        accessibilityLabel={title}
        accessibilityHint="Activates this action"
      >
        <Text style={[
          styles.buttonText,
          { fontSize: getScaledSize(24, ageGroup, 'fontSize') }
        ]}>
          {title}
        </Text>
      </TouchableOpacity>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  button: {
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.12,
    shadowRadius: 20,
    elevation: 6,
  },
  buttonText: {
    fontWeight: '700',
    color: 'white',
  },
});
```

---

## study-buddy/src/utils/intl/i18n.ts
```ts
// Minimal i18n implementation for Study Buddy
// Supports: English, German, Spanish

import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Localization from 'expo-localization';

const translations = {
  en: {
    // Mode Selection
    howAreYouFeeling: 'How are you feeling?',
    readyToWork: 'Ready to Work!',
    needToCalmDown: 'Need to Calm Down',
    startQuickly: 'Start quickly or pick a mode below.',
    
    // Onboarding
    howOldIsYourChild: 'How old is your study superstar?',
    weWillCustomize: "We'll customize everything for their age!",
    pickYourFriend: 'Pick Your Friend!',
    whoWillHelp: 'Who will help you today?',
    whatsYourName: "What's Your Name?",
    holdToRecord: 'Hold to Record',
    recording: 'Recording...',
    skipForNow: 'Skip for now',
    weAreReady: "We're Ready!",
    
    // Main Screen
    letsWorkOn: "Let's work on",
    focusTime: 'Focus Time',
    dayStreak: 'day streak',
    studyTime: 'Study time',
    startStudying: 'Start Studying!',
    breakTime: 'Break Time!',
    finished: 'Finished!',
    
    // Subjects
    math: 'Math',
    reading: 'Reading',
    writing: 'Writing',
    science: 'Science',
    chemistry: 'Chemistry',
    biology: 'Biology',
    history: 'History',
    geography: 'Geography',
    other: 'Other',
    
    // Check-ins
    whatAreYouWorkingOn: 'What are you working on?',
    howsItGoing: "How's it going?",
    howMuchDone: 'How much done?',
    easy: 'Easy!',
    ok: 'OK',
    hard: 'Hard',
    needHelp: 'Need help',
    allDone: 'All done',
    most: 'Most',
    half: 'Half',
    justStarted: 'Just started',
    
    // Celebration
    amazingJob: 'Amazing Job!',
    sessionComplete: 'Session Complete',
    todaysFocusTime: "Today's Focus Time",
    currentStreak: 'Current Streak',
    totalFocusTime: 'Total Focus Time',
    shareSuccess: 'Share Success!',
    continue: 'Continue',
    
    // Parent Settings
    parentSettings: 'Parent Settings',
    parentAccess: 'Parent Access',
    saveSettings: 'Save Settings',
    timerSettings: 'Timer Settings',
    workDuration: 'Work Duration',
    breakDuration: 'Break Duration',
    minutes: 'minutes',
    
    // Calm Mode
    startCalming: 'Start Calming',
    breatheIn: 'Breathe In',
    breatheOut: 'Breathe Out',
    breathsCount: 'breaths',
    imReadyToTalk: "I'm ready to talk",
    
    // Quick Start Labels
    quickMath: 'Math',
    quickRead: 'Read',
    quickScience: 'Science',
    quickWrite: 'Write',
    quickChem: 'Chem'
  },
  
  de: {
    // Mode Selection
    howAreYouFeeling: 'Wie f√ºhlst du dich?',
    readyToWork: 'Bereit zu arbeiten!',
    needToCalmDown: 'Muss mich beruhigen',
    startQuickly: 'Schnell starten oder Modus w√§hlen.',
    
    // Onboarding
    howOldIsYourChild: 'Wie alt ist dein Lern-Superstar?',
    weWillCustomize: 'Wir passen alles an das Alter an!',
    pickYourFriend: 'W√§hle deinen Freund!',
    whoWillHelp: 'Wer hilft dir heute?',
    whatsYourName: 'Wie hei√üt du?',
    holdToRecord: 'Halten zum Aufnehmen',
    recording: 'Aufnahme...',
    skipForNow: '√úberspringen',
    weAreReady: 'Wir sind bereit!',
    
    // Main Screen
    letsWorkOn: 'Lass uns arbeiten an',
    focusTime: 'Fokuszeit',
    dayStreak: 'Tage in Folge',
    studyTime: 'Lernzeit',
    startStudying: 'Lernen starten!',
    breakTime: 'Pausenzeit!',
    finished: 'Fertig!',
    
    // Subjects
    math: 'Mathe',
    reading: 'Lesen',
    writing: 'Schreiben',
    science: 'Wissenschaft',
    chemistry: 'Chemie',
    biology: 'Biologie',
    history: 'Geschichte',
    geography: 'Geographie',
    other: 'Andere',
    
    // Check-ins
    whatAreYouWorkingOn: 'Woran arbeitest du?',
    howsItGoing: 'Wie l√§uft es?',
    howMuchDone: 'Wie viel geschafft?',
    easy: 'Einfach!',
    ok: 'OK',
    hard: 'Schwer',
    needHelp: 'Brauche Hilfe',
    allDone: 'Alles fertig',
    most: 'Das meiste',
    half: 'H√§lfte',
    justStarted: 'Gerade angefangen',
    
    // Celebration
    amazingJob: 'Gro√üartige Arbeit!',
    sessionComplete: 'Sitzung abgeschlossen',
    todaysFocusTime: 'Heutige Fokuszeit',
    currentStreak: 'Aktuelle Serie',
    totalFocusTime: 'Gesamte Fokuszeit',
    shareSuccess: 'Erfolg teilen!',
    continue: 'Weiter',
    
    // Parent Settings
    parentSettings: 'Elterneinstellungen',
    parentAccess: 'Elternzugang',
    saveSettings: 'Einstellungen speichern',
    timerSettings: 'Timer-Einstellungen',
    workDuration: 'Arbeitsdauer',
    breakDuration: 'Pausendauer',
    minutes: 'Minuten',
    
    // Calm Mode
    startCalming: 'Beruhigung starten',
    breatheIn: 'Einatmen',
    breatheOut: 'Ausatmen',
    breathsCount: 'Atemz√ºge',
    imReadyToTalk: 'Ich bin bereit zu reden',
    
    // Quick Start Labels
    quickMath: 'Mathe',
    quickRead: 'Lesen',
    quickScience: 'Wissen',
    quickWrite: 'Schreiben',
    quickChem: 'Chemie',
    // Notifications & system
    notificationsPermissionTitle: 'Benachrichtigungen',
    notificationsPermissionBody: 'Wir verwenden gelegentliche Check-ins, um Ihr Kind zu unterst√ºtzen. Sie k√∂nnen dies jederzeit √§ndern.',
    notNow: 'Nicht jetzt',
    resume: 'Fortsetzen',
    break5: '+5 Min Pause',
    imDone: 'Ich bin fertig',
    checkinTitle: 'Study Buddy'
  },
  
  es: {
    // Mode Selection
    howAreYouFeeling: '¬øC√≥mo te sientes?',
    readyToWork: '¬°Listo para trabajar!',
    needToCalmDown: 'Necesito calmarme',
    startQuickly: 'Comienza r√°pido o elige un modo.',
    
    // Onboarding
    howOldIsYourChild: '¬øQu√© edad tiene tu superestrella?',
    weWillCustomize: '¬°Personalizaremos todo para su edad!',
    pickYourFriend: '¬°Elige tu amigo!',
    whoWillHelp: '¬øQui√©n te ayudar√° hoy?',
    whatsYourName: '¬øC√≥mo te llamas?',
    holdToRecord: 'Mant√©n para grabar',
    recording: 'Grabando...',
    skipForNow: 'Omitir por ahora',
    weAreReady: '¬°Estamos listos!',
    
    // Main Screen
    letsWorkOn: 'Trabajemos en',
    focusTime: 'Tiempo de enfoque',
    dayStreak: 'd√≠as seguidos',
    studyTime: 'Tiempo de estudio',
    startStudying: '¬°Empezar a estudiar!',
    breakTime: '¬°Tiempo de descanso!',
    finished: '¬°Terminado!',
    
    // Subjects
    math: 'Matem√°ticas',
    reading: 'Lectura',
    writing: 'Escritura',
    science: 'Ciencias',
    chemistry: 'Qu√≠mica',
    biology: 'Biolog√≠a',
    history: 'Historia',
    geography: 'Geograf√≠a',
    other: 'Otro',
    
    // Check-ins
    whatAreYouWorkingOn: '¬øEn qu√© est√°s trabajando?',
    howsItGoing: '¬øC√≥mo va?',
    howMuchDone: '¬øCu√°nto has hecho?',
    easy: '¬°F√°cil!',
    ok: 'OK',
    hard: 'Dif√≠cil',
    needHelp: 'Necesito ayuda',
    allDone: 'Todo listo',
    most: 'La mayor√≠a',
    half: 'La mitad',
    justStarted: 'Reci√©n empezado',
    
    // Celebration
    amazingJob: '¬°Trabajo incre√≠ble!',
    sessionComplete: 'Sesi√≥n completada',
    todaysFocusTime: 'Tiempo de enfoque de hoy',
    currentStreak: 'Racha actual',
    totalFocusTime: 'Tiempo total de enfoque',
    shareSuccess: '¬°Compartir √©xito!',
    continue: 'Continuar',
    
    // Parent Settings
    parentSettings: 'Ajustes para padres',
    parentAccess: 'Acceso para padres',
    saveSettings: 'Guardar ajustes',
    timerSettings: 'Ajustes del temporizador',
    workDuration: 'Duraci√≥n del trabajo',
    breakDuration: 'Duraci√≥n del descanso',
    minutes: 'minutos',
    
    // Calm Mode
    startCalming: 'Empezar a calmarse',
    breatheIn: 'Inhala',
    breatheOut: 'Exhala',
    breathsCount: 'respiraciones',
    imReadyToTalk: 'Estoy listo para hablar',
    
    // Quick Start Labels
    quickMath: 'Mate',
    quickRead: 'Leer',
    quickScience: 'Ciencias',
    quickWrite: 'Escribir',
    quickChem: 'Qu√≠mica',
    // Notifications & system
    notificationsPermissionTitle: 'Notificaciones',
    notificationsPermissionBody: 'Usamos check-ins ocasionales para mantener a su hijo en camino. Puede cambiar esto en cualquier momento.',
    notNow: 'Ahora no',
    resume: 'Reanudar',
    break5: '+5 min de descanso',
    imDone: 'Termin√©',
    checkinTitle: 'Study Buddy'
  }
};

// Current language state
let currentLanguage = 'en';

// Initialize from device settings
export const initializeLanguage = async (): Promise<void> => {
  try {
    // Try to get saved language preference
    const savedLang = await AsyncStorage.getItem('@StudyBuddy:language');
    if (savedLang && translations[savedLang]) {
      currentLanguage = savedLang;
      return;
    }
    
    // Otherwise use device language
    const deviceLang = Localization.locale.split('-')[0]; // 'en-US' -> 'en'
    if (translations[deviceLang]) {
      currentLanguage = deviceLang;
    }
  } catch (e) {
    // Default to English
  }
};

// Get current language
export const getCurrentLanguage = (): string => currentLanguage;

// Set language
export const setLanguage = async (lang: string): Promise<void> => {
  if (translations[lang]) {
    currentLanguage = lang;
    await AsyncStorage.setItem('@StudyBuddy:language', lang);
  }
};

// Get translated string
export const t = (key: string): string => {
  return translations[currentLanguage]?.[key] || translations.en[key] || key;
};

// Get all available languages
export const getAvailableLanguages = (): Array<{ code: string; name: string; flag: string }> => [
  { code: 'en', name: 'English', flag: 'üá∫üá∏' },
  { code: 'de', name: 'Deutsch', flag: 'üá©üá™' },
  { code: 'es', name: 'Espa√±ol', flag: 'üá™üá∏' }
];

// Format with parameters
export const tf = (key: string, params: Record<string, string | number> = {}): string => {
  let text = t(key);
  Object.keys(params).forEach(param => {
    text = text.replace(`{${param}}`, params[param]);
  });
  return text;
};
// Locale/timezone helpers and formatters
export const getLocale = (): string => {
  try {
    const deviceLocale = (Localization.locale || 'en-US');
    if (deviceLocale.toLowerCase().startsWith(currentLanguage.toLowerCase())) return deviceLocale;
  } catch {}
  return currentLanguage === 'en' ? 'en-US' : currentLanguage;
};

export const getTimeZone = (): string => {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
  } catch {
    return 'UTC';
  }
};

export const formatDate = (d: Date, opts?: Intl.DateTimeFormatOptions): string =>
  new Intl.DateTimeFormat(getLocale(), opts).format(d);

export const formatTime = (d: Date, opts?: Intl.DateTimeFormatOptions): string =>
  new Intl.DateTimeFormat(getLocale(), { hour: 'numeric', minute: '2-digit', ...opts }).format(d);

export const formatNumber = (n: number, opts?: Intl.NumberFormatOptions): string =>
  new Intl.NumberFormat(getLocale(), opts).format(n);
```

---

## study-buddy/src/utils/voice/speech.ts
```ts
import * as Speech from 'expo-speech';
import { getStorageItem } from '@utils/core/storage';

// Rate limiting
let lastSpeechTime = 0;
const MIN_SPEECH_INTERVAL = 1000; // Minimum 1 second between speeches

// Cached settings
let cachedSettings = {
  mainScreenEnabled: true,
  calmModeEnabled: true,
  celebrationEnabled: true,
  rate: 1.0,
  pitch: 1.0,
};

// Load speech settings from storage
export const loadSpeechSettings = async (): Promise<typeof cachedSettings> => {
  try {
    const settings = await getStorageItem('speechSettings');
    if (settings) {
      cachedSettings = JSON.parse(settings);
    }
  } catch (e) {
    console.log('Error loading speech settings:', e);
  }
  return cachedSettings;
};

// Smart speak function with rate limiting and settings respect
export const smartSpeak = async (
  text: string,
  options: {
    screenType?: 'main' | 'calm' | 'celebration';
    forceSpeak?: boolean;
    language?: string;
  } & Partial<Speech.SpeechOptions> = {}
): Promise<void> => {
  const {
    screenType = 'main', // 'main', 'calm', 'celebration'
    forceSpeak = false,  // Override rate limiting for critical messages
    language = 'en',
    ...speechOptions
  } = options;

  // Load latest settings
  await loadSpeechSettings();

  // Check if speech is enabled for this screen
  const screenEnabledMap: Record<'main'|'calm'|'celebration', boolean> = {
    main: cachedSettings.mainScreenEnabled,
    calm: cachedSettings.calmModeEnabled,
    celebration: cachedSettings.celebrationEnabled,
  };
  const enabled = screenEnabledMap[screenType];
  if (!enabled && !forceSpeak) {
    return;
  }

  // Rate limiting
  const now = Date.now();
  if (!forceSpeak && now - lastSpeechTime < MIN_SPEECH_INTERVAL) {
    return;
  }

  // Stop any ongoing speech
  await Speech.stop();

  // Update last speech time
  lastSpeechTime = now;

  // Speak with settings
  // Simple queue: if speaking, wait until finished or timeout
  const speaking = await Speech.isSpeakingAsync();
  if (speaking && !forceSpeak) {
    await new Promise((resolve) => setTimeout(resolve, 250));
  }
  await Speech.speak(text, {
    language,
    rate: cachedSettings.rate,
    pitch: cachedSettings.pitch,
    ...speechOptions
  });
};

// Stop all speech
export const stopSpeech = async (): Promise<void> => {
  await Speech.stop();
};

// Check if speaking
export const isSpeaking = async (): Promise<boolean> => {
  return await Speech.isSpeakingAsync();
};
```

---

## study-buddy/src/utils/media/photoManager.ts
```ts
import * as FileSystem from 'expo-file-system';
import { getStorageItem, setStorageItem } from '@utils/core/storage';

const PHOTO_DIR = (FileSystem.cacheDirectory || FileSystem.documentDirectory) + 'StudyBuddyPhotos/';
const PHOTO_INDEX_KEY = 'photoIndex';

// Ensure photo directory exists
export const ensurePhotoDirectory = async (): Promise<void> => {
  const dirInfo = await FileSystem.getInfoAsync(PHOTO_DIR);
  if (!dirInfo.exists) {
    await FileSystem.makeDirectoryAsync(PHOTO_DIR, { intermediates: true });
  }
};

// Save photo with metadata
export const savePhoto = async (photoUri: string): Promise<string> => {
  await ensurePhotoDirectory();
  
  const timestamp = Date.now();
  const fileName = `homework_${timestamp}.jpg`;
  const destUri = PHOTO_DIR + fileName;
  
  await FileSystem.copyAsync({
    from: photoUri,
    to: destUri
  });
  
  // Update photo index
  const indexStr = await getStorageItem(PHOTO_INDEX_KEY);
  const index = indexStr ? JSON.parse(indexStr) : [];
  index.push({ fileName, timestamp, uri: destUri });
  await setStorageItem(PHOTO_INDEX_KEY, JSON.stringify(index));
  
  return destUri;
};

// Clean old photos based on settings
export const cleanOldPhotos = async (): Promise<void> => {
  try {
    const settingsStr = await getStorageItem('photoSettings');
    const settings = settingsStr ? JSON.parse(settingsStr) : { autoDeleteDays: 7 };
    
    const indexStr = await getStorageItem(PHOTO_INDEX_KEY);
    if (!indexStr) return;
    
    const index = JSON.parse(indexStr);
    const now = Date.now();
    const maxAge = settings.autoDeleteDays * 24 * 60 * 60 * 1000;
    
    const updatedIndex: Array<{ fileName: string; timestamp: number; uri: string }> = [];
    
    for (const photo of index) {
      if (now - photo.timestamp > maxAge) {
        // Delete old photo
        try {
          await FileSystem.deleteAsync(photo.uri, { idempotent: true });
        } catch (e) {
          console.log('Error deleting photo:', e);
        }
      } else {
        updatedIndex.push(photo);
      }
    }
    
    await setStorageItem(PHOTO_INDEX_KEY, JSON.stringify(updatedIndex));
  } catch (e) {
    console.log('Error cleaning photos:', e);
  }
};

// Get all photos
export const getAllPhotos = async (): Promise<Array<{ fileName: string; timestamp: number; uri: string }>> => {
  const indexStr = await getStorageItem(PHOTO_INDEX_KEY);
  return indexStr ? JSON.parse(indexStr) : [];
};
```

---

## study-buddy/src/screens/PaywallScreen.tsx
```tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
  ActivityIndicator,
  Alert,
  Platform,
  Linking
} from 'react-native';
import Constants from 'expo-constants';
import { getAppConfig } from '@config/appConfig';
import { getAgeConfig, getScaledSize } from '@utils/config/constants';
import { t } from '@utils/intl/i18n';
import { track } from '@utils/analytics';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { getCurrentOfferings, purchasePackage as buyPkg, restore as restorePurchasesAPI } from '@utils/purchases';

type Props = StackScreenProps<RootStackParamList, 'Paywall'>;

export default function PaywallScreen({ navigation, route }: Props) {
  const [offerings, setOfferings] = useState(null);
  const [loading, setLoading] = useState(true);
  const [purchasing, setPurchasing] = useState(false);
  const [variant, setVariant] = useState<'A' | 'B'>('A');
  const ageGroup = route.params?.ageGroup || 'elementary';
  const config = getAgeConfig(ageGroup);
  const extra = getAppConfig();

  useEffect(() => {
    // Decide variant using weighted selection; persist for session via simple RNG
    const variants = extra.remote?.paywall?.variants || { A: 1 };
    const r = Math.random();
    const total = Object.values(variants).reduce((a, b) => a + b, 0) || 1;
    let acc = 0;
    let chosen: 'A' | 'B' = 'A';
    (Object.entries(variants) as Array<[string, number]>).forEach(([k, w]) => {
      if (acc / total <= r && r < (acc + w) / total) {
        chosen = (k === 'B' ? 'B' : 'A');
      }
      acc += w;
    });
    setVariant(chosen);
    loadOfferings();
  }, []);

  const loadOfferings = async () => {
    try {
      const offerings = await getCurrentOfferings();
      if (offerings.current !== null) {
        setOfferings(offerings.current);
      } else {
        setOfferings(null);
      }
      setLoading(false);
    } catch (e) {
      console.log('Error loading offerings:', e);
      setLoading(false);
    }
  };

  const purchasePackage = async (packageItem) => {
    setPurchasing(true);
    try {
      const { isPremium } = await buyPkg(packageItem);
      if (isPremium) {
        Alert.alert('Success!', 'Welcome to Study Buddy Premium!', [
          { text: 'OK', onPress: () => navigation.goBack() }
        ]);
      }
    } catch (e) {
      // Errors tracked in purchases wrapper
      Alert.alert('Error', 'Purchase failed. Please try again.');
    }
    setPurchasing(false);
  };

  const restorePurchases = async () => {
    setPurchasing(true);
    try {
      const { isPremium } = await restorePurchasesAPI();
      if (isPremium) {
        track('restore_success');
        Alert.alert('Restored', 'Your premium access has been restored.', [
          { text: 'OK', onPress: () => navigation.goBack() }
        ]);
      } else {
        track('restore_no_active');
        Alert.alert('No Active Subscriptions', 'We could not find an active premium subscription on this account.');
      }
    } catch (e) {
      track('restore_failed', { error: String(e) });
      Alert.alert('Error', 'Could not restore purchases. Please try again later.');
    }
    setPurchasing(false);
  };

  const openManageSubscriptions = async () => {
    const urls = extra?.manageSubscriptions || {};
    const url = Platform.OS === 'ios' ? urls.ios : urls.android;
    if (url) {
      try { await Linking.openURL(url); } catch {}
    }
  };

  const retryLoad = () => {
    setLoading(true);
    loadOfferings();
  };

  if (loading) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: config.secondaryColor }]}>
        <ActivityIndicator size="large" color={config.primaryColor} />
      </SafeAreaView>
    );
  }

  const noOffering = !offerings || !offerings.availablePackages?.length;

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: config.secondaryColor }]}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        {/* Header */}
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.closeButton}
          accessibilityRole="button"
          accessibilityLabel="Close"
        >
          <Text style={styles.closeText}>‚úï</Text>
        </TouchableOpacity>

        {/* Title */}
        <Text style={[styles.title, { color: config.primaryColor }]}>Study Buddy Premium</Text>
        {variant === 'B' && (
          <Text style={[styles.subtitle, { color: '#2C3E50', marginTop: 6 }]}>Unlock calmer study time and fewer battles at home.</Text>
        )}

        {noOffering ? (
          <View style={styles.benefitsContainer}>
            <Text style={[styles.benefitTitle, { marginBottom: 8 }]}>No plans available</Text>
            <Text style={{ color: '#2C3E50', textAlign: 'center' }}>
              We couldn't load subscription options. Please try again later or restore purchases.
            </Text>
            <TouchableOpacity
              style={styles.restoreButton}
              onPress={retryLoad}
              disabled={purchasing}
              accessibilityRole="button"
              accessibilityLabel="Retry"
            >
              <Text style={styles.restoreText}>Retry</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <>
            {/* Benefits */}
            <View style={styles.benefitsContainer}>
              <Text style={styles.benefitTitle}>Unlock Everything:</Text>
              {(variant === 'A'
                ? [
                    '‚úì Unlimited study sessions',
                    '‚úì All buddy characters',
                    '‚úì Custom encouragement messages',
                    '‚úì Detailed progress reports',
                    '‚úì Photo history gallery',
                    '‚úì Ad-free forever'
                  ]
                : [
                    '‚úì Calmer homework time, fewer negotiations',
                    '‚úì Buddy voices that match your child's age',
                    '‚úì Custom parent encouragement clips',
                    '‚úì Weekly focus insights for parents',
                    '‚úì Private on-device photo gallery',
                    '‚úì No ads ‚Äî ever'
                  ]).map((benefit, index) => (
                <Text key={index} style={styles.benefitItem}>{benefit}</Text>
              ))}
            </View>

            {/* Packages */}
            {offerings && offerings.availablePackages.map((pkg) => (
              <TouchableOpacity
                key={pkg.identifier}
                style={[styles.packageButton, { backgroundColor: config.primaryColor }]}
                onPress={() => purchasePackage(pkg)}
                disabled={purchasing}
                accessibilityRole="button"
                accessibilityLabel={`Purchase ${pkg.product.title}`}
              >
                <Text style={styles.packageTitle}>{pkg.product.title}</Text>
                <Text style={styles.packagePrice}>
                  {pkg.product.priceString}
                  {pkg.packageType === 'MONTHLY' && '/month'}
                  {pkg.packageType === 'ANNUAL' && '/year'}
                </Text>
                {pkg.packageType === 'ANNUAL' && (
                  <Text style={styles.savingsText}>Save 33%!</Text>
                )}
              </TouchableOpacity>
            ))}
          </>
        )}

        {/* Restore & Manage */}
        <TouchableOpacity
          style={styles.restoreButton}
          onPress={restorePurchases}
          disabled={purchasing}
          accessibilityRole="button"
          accessibilityLabel="Restore purchases"
        >
          <Text style={styles.restoreText}>Restore Purchases</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.restoreButton}
          onPress={openManageSubscriptions}
          disabled={purchasing}
          accessibilityRole="button"
          accessibilityLabel="Manage subscription"
        >
          <Text style={styles.restoreText}>Manage Subscription</Text>
        </TouchableOpacity>

        {/* Terms */}
        <Text style={styles.terms}>
          Subscriptions auto-renew. Manage or cancel anytime in App Store or Google Play settings.
        </Text>
      </ScrollView>
    </SafeAreaView>
  );
}
```

---

## study-buddy/src/utils/voice/speech.test.ts
```ts
import * as Speech from 'expo-speech';
import { smartSpeak } from './speech';

describe('smartSpeak', () => {
  it('rate-limits rapid calls when not forced', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockResolvedValue(undefined as any);
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => {} as any);
    const isSpeakingSpy = jest.spyOn(Speech, 'isSpeakingAsync' as any).mockResolvedValue(false as any);

    await smartSpeak('one');
    await smartSpeak('two'); // within MIN_SPEECH_INTERVAL, should be dropped

    expect(speakSpy).toHaveBeenCalledTimes(1);

    stopSpy.mockRestore();
    speakSpy.mockRestore();
    isSpeakingSpy.mockRestore();
  });

  it('forceSpeak bypasses rate limiting', async () => {
    const stopSpy = jest.spyOn(Speech, 'stop' as any).mockResolvedValue(undefined as any);
    const speakSpy = jest.spyOn(Speech, 'speak' as any).mockImplementation(() => {} as any);
    const isSpeakingSpy = jest.spyOn(Speech, 'isSpeakingAsync' as any).mockResolvedValue(false as any);

    await smartSpeak('one');
    await smartSpeak('two', { forceSpeak: true });

    expect(speakSpy).toHaveBeenCalledTimes(2);

    stopSpy.mockRestore();
    speakSpy.mockRestore();
    isSpeakingSpy.mockRestore();
  });
});
```

---

## study-buddy/src/utils/core/storage.ts
```ts
import AsyncStorage from '@react-native-async-storage/async-storage';

const STORAGE_PREFIX = '@StudyBuddy:';

export const setStorageItem = async (key: string, value: string): Promise<boolean> => {
  try {
    await AsyncStorage.setItem(STORAGE_PREFIX + key, value);
    return true;
  } catch (error) {
    console.error('Error saving to storage:', error);
    return false;
  }
};

export const getStorageItem = async (key: string): Promise<string | null> => {
  try {
    const value = await AsyncStorage.getItem(STORAGE_PREFIX + key);
    return value;
  } catch (error) {
    console.error('Error reading from storage:', error);
    return null;
  }
};

export const removeStorageItem = async (key: string): Promise<boolean> => {
  try {
    await AsyncStorage.removeItem(STORAGE_PREFIX + key);
    return true;
  } catch (error) {
    console.error('Error removing from storage:', error);
    return false;
  }
};

export const clearAllStorage = async (): Promise<boolean> => {
  try {
    const keys = await AsyncStorage.getAllKeys();
    const studyBuddyKeys = keys.filter(key => key.startsWith(STORAGE_PREFIX));
    await AsyncStorage.multiRemove(studyBuddyKeys);
    return true;
  } catch (error) {
    console.error('Error clearing storage:', error);
    return false;
  }
};
```

---

## study-buddy/src/utils/media/audio.ts
```ts
import { Audio } from 'expo-av';
import * as Speech from 'expo-speech';

export const playSound = async (soundFile: any): Promise<void> => {
  try {
    const { sound } = await Audio.Sound.createAsync(soundFile);
    await sound.playAsync();
    
    // Unload sound after playing
    sound.setOnPlaybackStatusUpdate((status) => {
      if (status.didJustFinish) {
        sound.unloadAsync();
      }
    });
  } catch (error) {
    console.error('Error playing sound:', error);
  }
};

export const speak = (text: string, options: Partial<Speech.SpeechOptions> = {}): void => {
  const defaultOptions = {
    language: 'en',
    pitch: 1.1,
    rate: 0.9,
    ...options
  };
  
  Speech.speak(text, defaultOptions as any);
};

export const stopSpeaking = (): void => {
  Speech.stop();
};

export const configureSpeech = async (): Promise<any> => {
  // Check if speech is available
  const available = await Speech.getAvailableVoicesAsync();
  return available;
};
```

---

## study-buddy/src/assets/animations/buddy-animations.ts
```ts
// ===================================
// MODULAR BUDDY SYSTEM
// Data-driven buddy configurations
// ===================================

// Buddy personality templates
const BUDDY_PERSONALITIES = {
  energetic: {
    sounds: ['boing', 'yay', 'woohoo'],
    animationStyle: 'bouncy',
    description: 'super excited and encouraging'
  },
  magical: {
    sounds: ['sparkle', 'magic', 'chime'],
    animationStyle: 'mystical',
    description: 'magical and supportive'
  },
  friendly: {
    sounds: ['roar', 'stomp', 'growl'],
    animationStyle: 'strong',
    description: 'friendly and brave'
  },
  playful: {
    sounds: ['purr', 'meow', 'chirp'],
    animationStyle: 'gentle',
    description: 'playful and encouraging'
  },
  loyal: {
    sounds: ['woof', 'bark', 'pant'],
    animationStyle: 'steady',
    description: 'loyal and supportive'
  },
  smart: {
    sounds: ['beep', 'boop', 'whir'],
    animationStyle: 'precise',
    description: 'smart and helpful'
  },
  cool: {
    sounds: ['roar', 'fire', 'whoosh'],
    animationStyle: 'powerful',
    description: 'cool and powerful'
  },
  focused: {
    sounds: ['howl', 'growl', 'breath'],
    animationStyle: 'calm',
    description: 'focused and strong'
  },
  mysterious: {
    sounds: ['beep', 'whoosh', 'hum'],
    animationStyle: 'ethereal',
    description: 'chill and mysterious'
  },
  minimal: {
    sounds: ['pulse', 'hum', 'tone'],
    animationStyle: 'subtle',
    description: 'minimal and focused'
  },
  zen: {
    sounds: ['rustle', 'grow', 'flow'],
    animationStyle: 'organic',
    description: 'calm and growing'
  },
  mystical: {
    sounds: ['chime', 'glow', 'resonate'],
    animationStyle: 'floating',
    description: 'mystical and serene'
  }
};

type AgeGroup = 'young' | 'elementary' | 'tween' | 'teen';

type BuddyCatalogItem = {
  id: string;
  name: string;
  emoji: string;
  baseColor: string;
  personality: keyof typeof BUDDY_PERSONALITIES;
  allowedAges: AgeGroup[];
};

const BUDDY_CATALOG: BuddyCatalogItem[] = [
  { id: 'bunny', name: 'Bouncy', emoji: 'üê∞', baseColor: '#FFB6C1', personality: 'energetic', allowedAges: ['young','elementary'] },
  { id: 'unicorn', name: 'Sparkles', emoji: 'ü¶Ñ', baseColor: '#E6E6FA', personality: 'magical', allowedAges: ['young'] },
  { id: 'dino', name: 'Rex', emoji: 'ü¶ï', baseColor: '#98FB98', personality: 'friendly', allowedAges: ['young','elementary'] },
  { id: 'cat', name: 'Whiskers', emoji: 'üê±', baseColor: '#FFD93D', personality: 'playful', allowedAges: ['elementary'] },
  { id: 'dog', name: 'Buddy', emoji: 'üê∂', baseColor: '#8B4513', personality: 'loyal', allowedAges: ['elementary'] },
  { id: 'robot', name: 'Beep', emoji: 'ü§ñ', baseColor: '#C0C0C0', personality: 'smart', allowedAges: ['elementary','tween','teen'] },
  { id: 'dragon', name: 'Blaze', emoji: 'üêâ', baseColor: '#FF6B6B', personality: 'cool', allowedAges: ['tween'] },
  { id: 'wolf', name: 'Shadow', emoji: 'üê∫', baseColor: '#4A5568', personality: 'focused', allowedAges: ['tween'] },
  { id: 'alien', name: 'Cosmic', emoji: 'üëΩ', baseColor: '#00D9FF', personality: 'mysterious', allowedAges: ['tween'] },
  { id: 'geometric', name: 'Hex', emoji: '‚¨°', baseColor: '#7C3AED', personality: 'minimal', allowedAges: ['teen'] },
  { id: 'plant', name: 'Zen', emoji: 'üå±', baseColor: '#10B981', personality: 'zen', allowedAges: ['teen'] },
  { id: 'orb', name: 'Focus', emoji: 'üîÆ', baseColor: '#EC4899', personality: 'mystical', allowedAges: ['teen'] },
];

function decorateBuddy(template: BuddyCatalogItem) {
  const personality = BUDDY_PERSONALITIES[template.personality];
  return {
    ...template,
    color: template.baseColor,
    sounds: personality.sounds,
    animationStyle: personality.animationStyle,
    description: personality.description
  };
}

export const getBuddiesForAge = (ageGroup: AgeGroup) => {
  return BUDDY_CATALOG.filter(b => b.allowedAges.includes(ageGroup)).map(decorateBuddy);
};

export const getBuddyForAge = (ageGroup: AgeGroup, buddyId: string) => {
  const list = getBuddiesForAge(ageGroup);
  return list.find(b => b.id === buddyId) || list[0];
};

// Animation file references (for Lottie)
export const ANIMATIONS = {
  studying: 'studying.json',
  celebrating: 'celebrating.json',
  idle: 'idle.json',
  encouraging: 'encouraging.json',
  confetti: 'confetti.json'
};

// Remove duplicate legacy exports referencing undefined BUDDIES_BY_AGE.
```

---

## study-buddy/src/utils/content/peerLines.ts
```ts
import { SUBJECT_SYSTEM, AGE_CONFIGS } from '@utils/config/constants';
import type { GeneratePeerLineInput } from '@types/index';

// Deterministic-ish helper to keep session-consistent variation
function seededRand(seed) {
  let x = 0;
  try { x = Array.from(String(seed)).reduce((a, c) => a + c.charCodeAt(0), 0); } catch {}
  const t = Math.sin(x) * 10000;
  return t - Math.floor(t);
}

const SUBJECT_HINTS = {
  math: ['Check your steps', 'One problem at a time', 'Show your work'],
  reading: ['Summarize the paragraph', 'Who is the main character?', 'Predict what happens next'],
  writing: ['Add one detail', 'Check punctuation', 'Reread your sentence'],
  science: ['State your hypothesis', 'Measure carefully', 'Record observations'],
  chemistry: ['Balance the equation', 'Units matter', 'Mind safety rules'],
  biology: ['Name the parts', 'Think about the process', 'Use correct terms'],
  history: ['Think causes and effects', 'Check the timeline', 'Who did what?'],
  geography: ['Picture the map', 'Relate places', 'Climate matters'],
  other: ['Stay with it', 'You got this', 'Small steps add up']
};

export function generatePeerLine({
  ageGroup = 'elementary',
  buddyPersonality,
  subjectId = 'other',
  seconds = 0,
  sessionLength = 1200,
  context = 'tick',
  sessionId = 'default',
}: GeneratePeerLineInput): string {
  const ageConfig = AGE_CONFIGS[ageGroup] || AGE_CONFIGS.elementary;
  const subject = SUBJECT_SYSTEM.subjects[subjectId] || SUBJECT_SYSTEM.subjects.other;
  const ratio = Math.max(0, Math.min(1, seconds / Math.max(1, sessionLength)));
  const r = seededRand(`${sessionId}:${seconds}:${subjectId}`);
  // Jitter phase thresholds slightly per session to avoid identical bucketing
  const jitter = (seededRand(`${sessionId}:jitter`) - 0.5) * 0.1; // ¬±0.05
  const earlyCut = Math.max(0.2, Math.min(0.4, 0.33 + jitter));
  const lateCut = Math.max(0.6, Math.min(0.8, 0.66 + jitter));

  // Early / mid / late templates tuned by age tone
  const tone = ageConfig.personality?.encouragementLevel || 'medium';
  const simple = tone === 'high' || ageGroup === 'young';

  const early = simple
    ? [
        `${subject.emoji} Great start!`,
        `Nice focus on ${subject.label}!`,
        `Let's go! ${subject.label} time!`
      ]
    : [
        `${subject.emoji} Settling in. Keep a steady pace.`,
        `Strong start on ${subject.label}. Stay consistent.`,
        `Dial in. Small steps on ${subject.label}.`
      ];

  const mid = simple
    ? [
        `Halfway vibes! ${subject.emoji}`,
        `Good rhythm. Keep going!`,
        `Nice work‚Äîstay with ${subject.label}!`
      ]
    : [
        `You're in the zone. Maintain pace.`,
        `Progress is stacking. Stay on task.`,
        `Solid momentum on ${subject.label}.`
      ];

  const late = simple
    ? [
        `Almost there!`,
        `Push to the finish!`,
        `Final stretch on ${subject.label}!`
      ]
    : [
        `Close it out with quality.`,
        `Finish strong‚Äîfocus on the next small chunk.`,
        `Wrap-up time: check your last step.`
      ];

  const hints = SUBJECT_HINTS[subject.id] || SUBJECT_HINTS.other;

  // Shuffle-bag per session and phase, with recency avoidance
  type Phase = 'early' | 'mid' | 'late';
  const phase: Phase = ratio > lateCut ? 'late' : ratio > earlyCut ? 'mid' : 'early';

  // Session-scoped cache
  const globalAny: any = (globalThis as any);
  globalAny.__peerLineCache = globalAny.__peerLineCache || {};
  const cacheKey = `${sessionId}:${subject.id}:${phase}`;
  const recencyKey = `${sessionId}:${subject.id}:recency:${phase}`;
  const basePool = phase === 'early' ? early : phase === 'mid' ? mid : late;

  // Initialize shuffled pool when missing or exhausted
  if (!Array.isArray(globalAny.__peerLineCache[cacheKey]) || globalAny.__peerLineCache[cacheKey].length === 0) {
    const shuffled = [...basePool]
      .map((line) => ({ line, k: seededRand(`${cacheKey}:${line}`) }))
      .sort((a, b) => a.k - b.k)
      .map((x) => x.line);
    globalAny.__peerLineCache[cacheKey] = shuffled;
  }
  // Maintain small LRU per phase to avoid near-term repeats
  globalAny.__peerLineCache[recencyKey] = globalAny.__peerLineCache[recencyKey] || [];
  const lru: string[] = globalAny.__peerLineCache[recencyKey];
  const lruMax = 3;

  // Pop next candidate not in LRU; if all are in LRU, pop first
  let candidate = globalAny.__peerLineCache[cacheKey].shift();
  let attempts = basePool.length;
  while (attempts-- > 0 && candidate && lru.includes(candidate) && globalAny.__peerLineCache[cacheKey].length > 0) {
    globalAny.__peerLineCache[cacheKey].push(candidate);
    candidate = globalAny.__peerLineCache[cacheKey].shift();
  }
  const pick = (candidate || basePool[Math.floor(r * basePool.length)]) as string;

  // Mix in subject hint about 40% of the time
  // Update LRU
  if (!lru.includes(pick)) {
    lru.push(pick);
    if (lru.length > lruMax) lru.shift();
  }
  const hintRand = seededRand(`${sessionId}:${seconds}:${subjectId}:hint`);
  const maybeHint = hintRand > 0.6 ? ` ‚Ä¢ ${hints[Math.floor(hintRand * hints.length)]}` : '';

  // Context tweaks
  if (context === 'backgroundReturn') {
    return `${subject.emoji} Ready to jump back in?${maybeHint}`;
  }
  return `${pick}${maybeHint}`;
}
```

---

## study-buddy/src/utils/content/peerLines.test.ts
```ts
import { generatePeerLine } from './peerLines';

describe('generatePeerLine', () => {
  const base = {
    ageGroup: 'tween' as const,
    subjectId: 'biology',
    sessionId: 'test-session',
    sessionLength: 1200,
  };

  it('picks early-phase lines at start of session', () => {
    const line = generatePeerLine({ ...base, seconds: 60, context: 'tick' });
    expect(line).toMatch(/Great start|Settling in|Strong start|Let's go/i);
  });

  it('picks late-phase lines near end of session', () => {
    const line = generatePeerLine({ ...base, seconds: 1100, context: 'tick' });
    expect(line).toMatch(/Almost there|Push to the finish|Wrap-up|Finish strong|Final stretch|Close it out/i);
  });

  it('adds biology hint sometimes', () => {
    const withHint = generatePeerLine({ ...base, seconds: 300, context: 'tick' });
    // Not deterministic, but ensure function returns a non-empty string
    expect(typeof withHint).toBe('string');
    expect(withHint.length).toBeGreaterThan(0);
  });

  it('avoids immediate repeats within phase (recency LRU)', () => {
    const samples: string[] = [];
    // Very early seconds to stay in early phase regardless of jitter
    for (let s = 5; s <= 45; s += 5) {
      samples.push(generatePeerLine({ ...base, seconds: s, context: 'tick' }));
    }
    // No adjacent duplicates
    for (let i = 1; i < samples.length; i++) {
      expect(samples[i]).not.toEqual(samples[i - 1]);
    }
    // Diversity > 1
    expect(new Set(samples).size).toBeGreaterThan(1);
  });

  it('produces ~40% hints over a window (non-strict)', () => {
    let hintCount = 0;
    const total = 50;
    for (let i = 0; i < total; i++) {
      const line = generatePeerLine({ ...base, seconds: 200 + i * 3, context: 'tick' });
      if (line.includes(' ‚Ä¢ ')) hintCount++;
    }
    // Expect between 20% and 70% due to randomness bounds
    const rate = hintCount / total;
    expect(rate).toBeGreaterThan(0.2);
    expect(rate).toBeLessThan(0.7);
  });
});
```

---

## study-buddy/src/utils/voice/voice.test.ts
```ts
import { resolveVoiceForBuddy } from './voice';
import * as Speech from 'expo-speech';

describe('resolveVoiceForBuddy', () => {
  it('returns sane defaults when voices API fails', async () => {
    const spy = jest.spyOn(Speech, 'getAvailableVoicesAsync' as any).mockRejectedValueOnce(new Error('fail'));
    const v = await resolveVoiceForBuddy({ ageGroup: 'tween' });
    expect(v.language).toMatch(/^en/);
    expect(typeof v.rate).toBe('number');
    expect(typeof v.pitch).toBe('number');
    spy.mockRestore();
  });

  it('selects an English voice when available', async () => {
    const voices = [
      { identifier: 'es-ES-1', language: 'es-ES' },
      { identifier: 'en-US-1', language: 'en-US' },
    ];
    const spy = jest.spyOn(Speech, 'getAvailableVoicesAsync' as any).mockResolvedValueOnce(voices as any);
    const v = await resolveVoiceForBuddy({ ageGroup: 'teen' });
    expect(v.voice).toBe('en-US-1');
    spy.mockRestore();
  });
});
```

---

## study-buddy/src/utils/voice/voice.ts
```ts
import * as Speech from 'expo-speech';
import { getCurrentLanguage, getLocale } from '@utils/intl/i18n';

// Resolve a voice configuration based on age group and buddy
// Returns: { language, rate, pitch, voice }
export async function resolveVoiceForBuddy({ ageGroup = 'elementary', buddy }: { ageGroup?: 'young' | 'elementary' | 'tween' | 'teen'; buddy?: { personality?: string } }): Promise<{ language: string; rate: number; pitch: number; voice?: string }> {
  // Reasonable defaults per age
  const base = {
    young: { language: 'en-US', rate: 0.9, pitch: 1.2 },
    elementary: { language: 'en-US', rate: 1.0, pitch: 1.1 },
    tween: { language: 'en-US', rate: 1.0, pitch: 1.0 },
    teen: { language: 'en-US', rate: 1.05, pitch: 0.95 },
  }[ageGroup] || { language: 'en-US', rate: 1.0, pitch: 1.0 };

  try {
    const voices = await Speech.getAvailableVoicesAsync();
    const userLang = getCurrentLanguage();
    const preferred = voices?.find(v => v.language?.toLowerCase().startsWith(userLang.toLowerCase()));
    const fallback = voices?.find(v => v.language?.startsWith('en'));
    return { ...base, language: preferred?.language || getLocale(), voice: (preferred || fallback)?.identifier };
  } catch {
    return { ...base, language: getLocale(), voice: undefined };
  }
}
```

---

## study-buddy/src/utils/voice/voice.lang.test.ts
```ts
import * as Speech from 'expo-speech';
import { resolveVoiceForBuddy } from './voice';
import * as I18n from '@utils/intl/i18n';

describe('resolveVoiceForBuddy language preference', () => {
  it('prefers user-selected non-English language when available', async () => {
    jest.spyOn(I18n, 'getCurrentLanguage').mockReturnValue('es');
    const voices = [
      { identifier: 'es-ES-1', language: 'es-ES' },
      { identifier: 'en-US-1', language: 'en-US' },
    ];
    const spy = jest.spyOn(Speech, 'getAvailableVoicesAsync' as any).mockResolvedValueOnce(voices as any);
    const v = await resolveVoiceForBuddy({ ageGroup: 'tween' });
    expect(v.language).toMatch(/^es/);
    expect(v.voice).toBe('es-ES-1');
    spy.mockRestore();
  });
});
```

---

## study-buddy/src/components/ScreenBackground.tsx
```tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { getAgeConfig } from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

type ScreenBackgroundProps = { ageGroup?: AgeGroup; children: React.ReactNode };

export default function ScreenBackground({ ageGroup = 'elementary', children }: ScreenBackgroundProps): JSX.Element {
  const config = getAgeConfig(ageGroup);
  const background = config.secondaryColor || '#F0F8FF';
  const accent = config.accentColor || '#4A90E2';
  const primary = config.primaryColor || '#4A90E2';

  return (
    <View style={[styles.container, { backgroundColor: background }]}>
      {/* Soft blobs for warmth */}
      <View style={[styles.blob, { backgroundColor: primary + '22', top: -80, right: -60, width: 220, height: 220 }]} />
      <View style={[styles.blob, { backgroundColor: accent + '1F', bottom: -60, left: -40, width: 260, height: 260 }]} />
      <View style={[styles.blob, { backgroundColor: '#FFFFFF55', top: 140, left: '20%', width: 140, height: 140 }]} />

      {/* Content */}
      <View style={styles.content}>{children}</View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  blob: {
    position: 'absolute',
    borderRadius: 9999,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.12,
    shadowRadius: 20,
    elevation: 6,
  },
});
```

---

## study-buddy/src/screens/ConsentScreen.tsx
```tsx
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, SafeAreaView, Linking } from 'react-native';
import { getScaledSize } from '@utils/config/constants';
import { track } from '@utils/analytics';
import type { StackScreenProps } from '@react-navigation/stack';
import type { RootStackParamList } from '../../App';
import { t } from '@utils/intl/i18n';

type Props = StackScreenProps<RootStackParamList, 'Consent'>;

export default function ConsentScreen({ navigation, route }: Props) {
  const ageGroup = route.params?.ageGroup || 'elementary';
  const open = (url) => Linking.openURL(url).catch(() => {});
  return (
    <SafeAreaView style={styles.safeArea}>
      <View style={styles.container}>
        <Text accessibilityRole="header" style={styles.title}>Parental Consent</Text>
        <Text style={styles.body}>
          We collect minimal usage data (sessions, basic events) to improve the app. Photos remain on-device. No ads.
        </Text>
        <Text style={styles.link} onPress={() => open('https://example.com/privacy')}>Privacy Policy</Text>
        <Text style={styles.link} onPress={() => open('https://example.com/terms')}>Terms of Service</Text>
        <TouchableOpacity
          style={styles.button}
          onPress={() => { track('consent_accepted'); navigation.replace('ModeSelection'); }}
          accessibilityRole="button"
          accessibilityLabel="I Agree"
        >
          <Text style={styles.buttonText}>I Agree</Text>
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: { flex: 1 },
  container: { flex: 1, padding: 24, justifyContent: 'center' },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 12, color: '#2C3E50', textAlign: 'center' },
  body: { color: '#2C3E50', textAlign: 'center', marginBottom: 12 },
  link: { color: '#4A90E2', textAlign: 'center', marginBottom: 8, textDecorationLine: 'underline' },
  button: { backgroundColor: '#4A90E2', borderRadius: 12, padding: 14, alignItems: 'center', marginTop: 8 },
  buttonText: { color: 'white', fontWeight: 'bold' }
});
```

---

## study-buddy/src/utils/analytics.ts
```ts
import Constants from 'expo-constants';
import { Platform } from 'react-native';
import { getAppConfig } from '@config/appConfig';

let posthog = null;

export const initAnalytics = async (): Promise<void> => {
  try {
    const { posthog: ph } = getAppConfig();
    const key = ph.apiKey;
    const host = ph.host;
    if (!key || !host) return;
    // Lazy import to avoid bundling if not set
    const { PostHog } = await import('posthog-react-native');
    posthog = new PostHog(key, { host, flushAt: 1 });
    await posthog.setup();
    posthog?.identify?.(undefined, { platform: Platform.OS });
  } catch {}
};

export const track = (event: string, props: Record<string, unknown> = {}): void => {
  try { posthog?.capture?.(event, props); } catch {}
};

export const flush = async (): Promise<void> => { try { await posthog?.flush?.(); } catch {} };
```

---

## study-buddy/src/utils/analytics/events.ts
```ts
import { track } from '@utils/analytics';

// Centralized, typed analytics events
export type EventsMap = {
  app_start: { version?: string };
  onboarding_complete: { ageGroup: string; buddyId?: string };
  consent_accepted: Record<string, never>;
  session_start: { subjectId: string; ageGroup: string };
  session_end: { duration: number; ageGroup: string; subjectId?: string };
  proof_photo_captured: { ageGroup: string; uri: string };
  notifications_permission: { status: string };
  purchase_success: { package?: string; price?: string };
  purchase_failed: { error: string };
  restore_success: Record<string, never>;
  restore_failed: { error: string };
};

export type EventName = keyof EventsMap;

export function trackTyped<E extends EventName>(event: E, payload: EventsMap[E]): void {
  track(event, payload as Record<string, unknown>);
}

// Convenience wrappers
export const Analytics = {
  sessionStart: (p: EventsMap['session_start']) => trackTyped('session_start', p),
  sessionEnd: (p: EventsMap['session_end']) => trackTyped('session_end', p),
  onboardingComplete: (p: EventsMap['onboarding_complete']) => trackTyped('onboarding_complete', p),
  consentAccepted: () => trackTyped('consent_accepted', {}),
  proofPhotoCaptured: (p: EventsMap['proof_photo_captured']) => trackTyped('proof_photo_captured', p),
  notificationsPermission: (p: EventsMap['notifications_permission']) => trackTyped('notifications_permission', p),
  purchaseSuccess: (p: EventsMap['purchase_success']) => trackTyped('purchase_success', p),
  purchaseFailed: (p: EventsMap['purchase_failed']) => trackTyped('purchase_failed', p),
  restoreSuccess: () => trackTyped('restore_success', {}),
  restoreFailed: (p: EventsMap['restore_failed']) => trackTyped('restore_failed', p),
};
```

---

## study-buddy/src/utils/permissions.ts
```ts
import { Alert, Platform } from 'react-native';
import * as Notifications from 'expo-notifications';
import { Camera } from 'expo-camera';
import { Audio } from 'expo-av';
import { trackTyped } from '@utils/analytics/events';

type PermissionResult = { granted: boolean; canAskAgain?: boolean };

export async function ensureNotificationPermission(): Promise<PermissionResult> {
  try {
    const existing = await Notifications.getPermissionsAsync();
    let status = existing.status;
    if (status !== 'granted') {
      await new Promise<void>((resolve) => {
        Alert.alert(
          'Notifications',
          'We use occasional check-ins to keep your child on track. You can change this anytime.',
          [
            { text: 'Not now', onPress: () => resolve() },
            { text: 'Continue', onPress: () => resolve() }
          ]
        );
      });
      const requested = await Notifications.requestPermissionsAsync();
      status = requested.status;
    }
    trackTyped('notifications_permission', { status });
    if (Platform.OS === 'android' && status === 'granted') {
      await Notifications.setNotificationChannelAsync('checkins', {
        name: 'Check-ins',
        importance: Notifications.AndroidImportance.DEFAULT,
        vibrationPattern: [0, 250, 250, 250],
        lightColor: '#FF231F7C',
      });
    }
    return { granted: status === 'granted', canAskAgain: existing.canAskAgain };
  } catch {
    return { granted: false };
  }
}

export async function ensureCameraPermission(): Promise<PermissionResult> {
  try {
    const existing = await Camera.getCameraPermissionsAsync();
    let status = existing.status;
    if (status !== 'granted') {
      const requested = await Camera.requestCameraPermissionsAsync();
      status = requested.status;
    }
    return { granted: status === 'granted', canAskAgain: existing.canAskAgain };
  } catch {
    return { granted: false };
  }
}

export async function ensureMicrophonePermission(): Promise<PermissionResult> {
  try {
    const existing = await Audio.getPermissionsAsync();
    let status = existing.status as Notifications.PermissionStatus | undefined;
    if (status !== 'granted') {
      const requested = await Audio.requestPermissionsAsync();
      status = requested.status as Notifications.PermissionStatus | undefined;
    }
    return { granted: status === 'granted', canAskAgain: existing.canAskAgain };
  } catch {
    return { granted: false };
  }
}
```

---

## study-buddy/src/utils/core/storageKeys.ts
```ts
import { z } from 'zod';
import { getStorageItem, setStorageItem, removeStorageItem } from '@utils/core/storage';

export const StorageKeys = {
  hasLaunched: 'hasLaunched',
  selectedAge: 'selectedAge',
  selectedBuddy: 'selectedBuddy',
  childName: 'childName',
  parentPin: 'parentPin',
  parentPinSetAt: 'parentPinSetAt',
  lastSessionLog: 'lastSessionLog',
  currentStreak: 'currentStreak',
  totalFocusTime: 'totalFocusTime',
  calmStreak: 'calmStreak',
  speechSettings: 'speechSettings',
  photoSettings: 'photoSettings',
  lastWorkPhoto: 'lastWorkPhoto',
  sessionsCount: 'sessionsCount',
  lastNotifAction: 'lastNotifAction',
  feedbackHistory: 'feedbackHistory',
  photoIndex: 'photoIndex',
} as const;

export type StorageKey = keyof typeof StorageKeys;

export async function getStringKey(key: StorageKey): Promise<string | null> {
  return getStorageItem(StorageKeys[key]);
}

export async function setStringKey(key: StorageKey, value: string): Promise<boolean> {
  return setStorageItem(StorageKeys[key], value);
}

export async function removeKey(key: StorageKey): Promise<boolean> {
  return removeStorageItem(StorageKeys[key]);
}

export async function getJson<T>(key: StorageKey, schema: z.ZodSchema<T>, fallback: T): Promise<T> {
  try {
    const raw = await getStorageItem(StorageKeys[key]);
    if (!raw) return fallback;
    const parsed = JSON.parse(raw);
    const result = schema.safeParse(parsed);
    if (!result.success) return fallback;
    return result.data;
  } catch {
    return fallback;
  }
}

export async function setJson<T>(key: StorageKey, value: T): Promise<boolean> {
  try {
    return await setStorageItem(StorageKeys[key], JSON.stringify(value));
  } catch {
    return false;
  }
}
```

---

## study-buddy/src/utils/purchases/index.ts
```ts
import { Platform } from 'react-native';
import Purchases from 'react-native-purchases';
import { getAppConfig } from '@config/appConfig';
import { Analytics, trackTyped } from '@utils/analytics/events';

export type PurchaseStatus = { isPremium: boolean };

const APP = getAppConfig();
const ENTITLEMENT_ID = APP.revenuecat?.entitlementId || 'premium';

export async function configurePurchases(): Promise<void> {
  const iosKey = APP.revenuecat?.iosApiKey || '';
  const androidKey = APP.revenuecat?.androidApiKey || '';
  const apiKey = Platform.select({ ios: iosKey, android: androidKey });
  if (!apiKey) return;
  await Purchases.configure({ apiKey });
}

export async function hasPremium(): Promise<PurchaseStatus> {
  try {
    const info = await Purchases.getCustomerInfo();
    return { isPremium: !!info?.entitlements?.active?.[ENTITLEMENT_ID] };
  } catch (e) {
    return { isPremium: false };
  }
}

export async function getCurrentOfferings() {
  return Purchases.getOfferings();
}

export async function purchasePackage(pkg: any): Promise<PurchaseStatus> {
  try {
    const { customerInfo } = await Purchases.purchasePackage(pkg);
    const isPremium = !!customerInfo?.entitlements?.active?.[ENTITLEMENT_ID];
    if (isPremium) {
      Analytics.purchaseSuccess({ package: pkg?.identifier, price: pkg?.product?.priceString });
    }
    return { isPremium };
  } catch (e: any) {
    if (!e?.userCancelled) {
      trackTyped('purchase_failed', { error: String(e) });
    }
    return { isPremium: false };
  }
}

export async function restore(): Promise<PurchaseStatus> {
  try {
    const info = await Purchases.restorePurchases();
    const isPremium = !!info?.entitlements?.active?.[ENTITLEMENT_ID];
    if (isPremium) Analytics.restoreSuccess();
    else trackTyped('restore_failed', { error: 'no_active' });
    return { isPremium };
  } catch (e) {
    trackTyped('restore_failed', { error: String(e) });
    return { isPremium: false };
  }
}
```

---

## study-buddy/src/utils/voice/speakWithBuddy.ts
```ts
import { smartSpeak } from '@utils/voice/speech';
import { resolveVoiceForBuddy } from '@utils/voice/voice';

type SpeakOptions = {
  screenType?: 'main' | 'calm' | 'celebration';
  forceSpeak?: boolean;
  language?: string;
};

export async function speakWithBuddy({
  buddy,
  ageGroup = 'elementary',
  text,
  options = {},
}: {
  buddy?: { personality?: string } | null;
  ageGroup?: 'young' | 'elementary' | 'tween' | 'teen';
  text: string;
  options?: SpeakOptions;
}): Promise<void> {
  const voice = await resolveVoiceForBuddy({ ageGroup, buddy: buddy || undefined });
  await smartSpeak(text, {
    screenType: options.screenType || 'main',
    forceSpeak: options.forceSpeak,
    language: voice.language,
    rate: voice.rate,
    pitch: voice.pitch,
    voice: voice.voice,
  });
}
```

---

## study-buddy/src/utils/feedback/index.ts
```ts
import * as Haptics from 'expo-haptics';
import { playSound } from '@utils/media/audio';

export type Impact = 'light' | 'medium' | 'heavy';

export async function impact(level: Impact = 'medium'): Promise<void> {
  const map = {
    light: Haptics.ImpactFeedbackStyle.Light,
    medium: Haptics.ImpactFeedbackStyle.Medium,
    heavy: Haptics.ImpactFeedbackStyle.Heavy,
  } as const;
  await Haptics.impactAsync(map[level]);
}

export async function success(): Promise<void> {
  await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
}

export async function warning(): Promise<void> {
  await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
}

export async function error(): Promise<void> {
  await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
}

export async function selection(): Promise<void> {
  await Haptics.selectionAsync();
}

export async function playClick(sound?: any): Promise<void> {
  // Optionally pass a short embedded sound; otherwise, haptics alone
  if (sound) {
    await playSound(sound);
  } else {
    await selection();
  }
}
```

---

## study-buddy/src/utils/media/index.ts
```ts
import { Camera } from 'expo-camera';
import { ensureCameraPermission } from '@utils/permissions';
import { savePhoto as savePhotoToDisk, cleanOldPhotos } from '@utils/media/photoManager';
import { getJson } from '@utils/core/storageKeys';
import { z } from 'zod';
import { Analytics } from '@utils/analytics/events';

type CameraRefLike = { takePictureAsync: (opts?: any) => Promise<{ uri: string }> } | null | undefined;

const PhotoSettingsSchema = z.object({
  autoDeleteDays: z.number().int().min(1).max(365).default(7),
  privacyOverlay: z.boolean().default(false),
});

export async function takeProofPhoto(cameraRef?: CameraRefLike, ageGroup: string = 'elementary'): Promise<string | null> {
  const perm = await ensureCameraPermission();
  if (!perm.granted) return null;

  // If a Camera ref is provided (screen-managed camera), capture using it
  if (cameraRef && typeof cameraRef.takePictureAsync === 'function') {
    const photo = await cameraRef.takePictureAsync();
    const saved = await savePhoto(photo.uri, ageGroup);
    return saved;
  }

  // Fallback: no ref provided ‚Äî cannot capture without UI camera. Return null.
  return null;
}

export async function savePhoto(uri: string, ageGroup: string = 'elementary'): Promise<string> {
  // Respect privacy settings (overlay is a visual concern handled by UI; photos are stored locally only)
  const settings = await getJson('photoSettings' as any, PhotoSettingsSchema, { autoDeleteDays: 7, privacyOverlay: false });
  const savedUri = await savePhotoToDisk(uri);
  Analytics.proofPhotoCaptured({ ageGroup, uri: savedUri });
  // Opportunistic cleanup
  cleanOldPhotos().catch(() => {});
  return savedUri;
}

export { cleanOldPhotos };
```

---

## study-buddy/src/utils/scheduler/index.ts
```ts
import { AppState, AppStateStatus } from 'react-native';

type IntervalHandle = number;
type TimeoutHandle = number;

class Scheduler {
  private intervals = new Set<IntervalHandle>();
  private timeouts = new Set<TimeoutHandle>();
  private pauseOnBackground = new Set<IntervalHandle>();
  private appState: AppStateStatus = AppState.currentState;

  constructor() {
    AppState.addEventListener('change', this.onAppStateChange);
  }

  private onAppStateChange = (next: AppStateStatus) => {
    if (this.appState.match(/inactive|background/) && next === 'active') {
      // Resume intervals if needed (no-op; JS intervals continue). Could re-sync timers here.
    }
    if (next.match(/inactive|background/)) {
      // Clear intervals that opted-in to pause on background
      for (const id of Array.from(this.pauseOnBackground)) {
        clearInterval(id);
        this.intervals.delete(id);
        this.pauseOnBackground.delete(id);
      }
    }
    this.appState = next;
  };

  setInterval(callback: () => void, ms: number, options: { pauseOnBackground?: boolean } = {}): IntervalHandle {
    const id = setInterval(callback, ms) as unknown as number;
    this.intervals.add(id);
    if (options.pauseOnBackground) this.pauseOnBackground.add(id);
    return id;
  }

  clearInterval(id: IntervalHandle): void {
    clearInterval(id as any);
    this.intervals.delete(id);
    this.pauseOnBackground.delete(id);
  }

  setTimeout(callback: () => void, ms: number): TimeoutHandle {
    const id = setTimeout(callback, ms) as unknown as number;
    this.timeouts.add(id);
    return id;
  }

  clearTimeout(id: TimeoutHandle): void {
    clearTimeout(id as any);
    this.timeouts.delete(id);
  }

  clearAll(): void {
    for (const id of this.intervals) clearInterval(id as any);
    for (const id of this.timeouts) clearTimeout(id as any);
    this.intervals.clear();
    this.timeouts.clear();
    this.pauseOnBackground.clear();
  }
}

export const scheduler = new Scheduler();
```

---

## study-buddy/src/assets/registry.ts
```ts
export type AnimationName = 'studying' | 'celebrating' | 'idle' | 'encouraging' | 'confetti';

export function getAnimation(name: AnimationName) {
  switch (name) {
    case 'studying':
      return require('../assets/animations/studying.json');
    case 'celebrating':
      return require('../assets/animations/celebrating.json');
    case 'idle':
      return require('../assets/animations/idle.json');
    case 'encouraging':
      return require('../assets/animations/encouraging.json');
    case 'confetti':
      return require('../assets/animations/confetti.json');
    default:
      return require('../assets/animations/idle.json');
  }
}
```

---

## study-buddy/src/ui/tokens.ts
```ts
import { getAgeConfig } from '@utils/config/constants';
import type { AgeGroup } from '@types/index';

export type Tokens = {
  colors: { primary: string; secondary: string; accent: string; text: string; muted: string; white: string };
  spacing: (n: number, age?: AgeGroup) => number;
  radius: (n?: number) => number;
  typography: { title: number; body: number; small: number };
};

export function useAgeTokens(ageGroup: AgeGroup = 'elementary'): Tokens {
  const cfg = getAgeConfig(ageGroup);
  const base = {
    colors: {
      primary: cfg.primaryColor || '#4A90E2',
      secondary: cfg.secondaryColor || '#F0F8FF',
      accent: cfg.accentColor || '#4A90E2',
      text: '#2C3E50',
      muted: '#7F8C8D',
      white: '#FFFFFF',
    },
    spacing: (n: number) => n * (cfg.buttonScale || 1.0) * 4,
    radius: (n: number = 10) => n,
    typography: {
      title: 24 * (cfg.fontSize || 1.0),
      body: 16 * (cfg.fontSize || 1.0),
      small: 12 * (cfg.fontSize || 1.0),
    },
  } as const;
  return base as Tokens;
}
```

---

## study-buddy/src/ui/components/Button.tsx
```tsx
import React from 'react';
import { TouchableOpacity, Text, StyleSheet } from 'react-native';
import type { AgeGroup } from '@types/index';
import { useAgeTokens } from '@ui/tokens';

type Props = { title: string; onPress: () => void; ageGroup?: AgeGroup; color?: string; style?: any };

export default function Button({ title, onPress, ageGroup = 'elementary', color, style }: Props) {
  const t = useAgeTokens(ageGroup);
  return (
    <TouchableOpacity style={[styles.btn, { backgroundColor: color || t.colors.primary, borderRadius: t.radius(16), paddingHorizontal: t.spacing(10), paddingVertical: t.spacing(5) }, style]} onPress={onPress} activeOpacity={0.85}>
      <Text style={[styles.txt, { color: t.colors.white, fontSize: t.typography.body * 1.1 }]}>{title}</Text>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  btn: { alignItems: 'center', justifyContent: 'center' },
  txt: { fontWeight: '700' },
});
```

---

## study-buddy/src/ui/components/Card.tsx
```tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import type { AgeGroup } from '@types/index';
import { useAgeTokens } from '@ui/tokens';

type Props = { children: React.ReactNode; ageGroup?: AgeGroup; style?: any };

export default function Card({ children, ageGroup = 'elementary', style }: Props) {
  const t = useAgeTokens(ageGroup);
  return (
    <View style={[styles.card, { backgroundColor: t.colors.white, borderRadius: t.radius(16), padding: t.spacing(6), shadowColor: '#000', shadowOpacity: 0.1, shadowRadius: 8, shadowOffset: { width: 0, height: 2 }, elevation: 5 }, style]}>
      {children}
    </View>
  );
}

const styles = StyleSheet.create({ card: {} });
```

---

## study-buddy/src/ui/components/ModalFrame.tsx
```tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import type { AgeGroup } from '@types/index';
import { useAgeTokens } from '@ui/tokens';

type Props = { children: React.ReactNode; ageGroup?: AgeGroup; style?: any };

export default function ModalFrame({ children, ageGroup = 'elementary', style }: Props) {
  const t = useAgeTokens(ageGroup);
  return (
    <View style={styles.backdrop}>
      <View style={[styles.content, { backgroundColor: t.colors.white, borderRadius: t.radius(20), padding: t.spacing(8) }, style]}>
        {children}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  backdrop: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.5)' },
  content: { width: '90%', maxWidth: 420, alignItems: 'center' },
});
```

---

## study-buddy/src/ui/alerts.ts
```ts
import { Alert } from 'react-native';

export function uiAlert(
  title: string,
  message?: string,
  buttons?: Array<{ text: string; onPress?: () => void; style?: 'default' | 'cancel' | 'destructive' }>
): void {
  try { Alert.alert(title, message, buttons); } catch {}
}

export function uiConfirm(title: string, message?: string, okText: string = 'OK', cancelText: string = 'Cancel'): Promise<boolean> {
  return new Promise((resolve) => {
    try {
      Alert.alert(title, message, [
        { text: cancelText, style: 'cancel', onPress: () => resolve(false) },
        { text: okText, onPress: () => resolve(true) },
      ]);
    } catch {
      resolve(false);
    }
  });
}
```

---

## study-buddy/src/utils/errors/index.ts
```ts
import * as Sentry from 'sentry-expo';

type ErrorContext = { ageGroup?: string; buddyId?: string; screen?: string; [k: string]: unknown };

export function captureError(error: unknown, context: ErrorContext = {}): void {
  try {
    Sentry.Native.captureException(error, { extra: context, tags: { screen: String(context.screen || '') } });
  } catch {}
}

export function captureMessage(message: string, context: ErrorContext = {}): void {
  try {
    Sentry.Native.captureMessage(message, { extra: context, tags: { screen: String(context.screen || '') } });
  } catch {}
}
```

---

## study-buddy/src/utils/nav/index.ts
```ts
import type { NavigationProp } from '@react-navigation/native';
import type { RootStackParamList } from '../../App';

export function navigateToCelebration(navigation: NavigationProp<RootStackParamList>, params: RootStackParamList['Celebration']): void {
  navigation.navigate('Celebration', params);
}

export function navigateToMain(navigation: NavigationProp<RootStackParamList>, params?: RootStackParamList['Main']): void {
  navigation.navigate('Main', params as any);
}

export function navigateToPaywall(navigation: NavigationProp<RootStackParamList>, params: RootStackParamList['Paywall']): void {
  navigation.navigate('Paywall', params);
}
```

---

## study-buddy/src/utils/adaptive/index.ts
```ts
import { getJson, setJson } from '@utils/core/storageKeys';
import { z } from 'zod';

type SubjectId = string;

type Model = {
  subjects: Record<SubjectId, { score: number; updatedAt: number }>;
  lastWeekStart?: string;
};

const Schema = z.object({
  subjects: z.record(z.object({ score: z.number(), updatedAt: z.number() })),
  lastWeekStart: z.string().optional(),
});

const DEFAULT_MODEL: Model = { subjects: {} };

function clamp(x: number, min = 0, max = 1) { return Math.max(min, Math.min(max, x)); }

export async function loadModel(): Promise<Model> {
  return await getJson('adaptiveModel' as any, Schema, DEFAULT_MODEL);
}

export async function saveModel(m: Model): Promise<void> {
  await setJson('adaptiveModel' as any, m);
}

// Update subject score: higher means easier for the child; lower means needs more support
// response values: 'easy'|'ok'|'hard'|'help'|'complete'|'most'|'half'|'started'
export async function recordInteraction(subjectId: string, response